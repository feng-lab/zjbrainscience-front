function require(x) { throw new Error('Cannot require ' + x) }
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = (x) => {
    if (typeof require !== "undefined")
      return require(x);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // node_modules/lodash/now.js
  var require_now = __commonJS({
    "node_modules/lodash/now.js"(exports, module) {
      var root = require_root();
      var now = function() {
        return root.Date.now();
      };
      module.exports = now;
    }
  });

  // node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js"(exports, module) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js"(exports, module) {
      var baseTrim = require_baseTrim();
      var isObject = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = toNumber;
    }
  });

  // node_modules/lodash/debounce.js
  var require_debounce = __commonJS({
    "node_modules/lodash/debounce.js"(exports, module) {
      var isObject = require_isObject();
      var now = require_now();
      var toNumber = require_toNumber();
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      function debounce3(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      module.exports = debounce3;
    }
  });

  // node_modules/lodash/throttle.js
  var require_throttle = __commonJS({
    "node_modules/lodash/throttle.js"(exports, module) {
      var debounce3 = require_debounce();
      var isObject = require_isObject();
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce3(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      module.exports = throttle2;
    }
  });

  // src/neuroglancer/mesh/draco/neuroglancer_draco.wasm
  var neuroglancer_draco_default;
  var init_neuroglancer_draco = __esm({
    "src/neuroglancer/mesh/draco/neuroglancer_draco.wasm"() {
      neuroglancer_draco_default = "data:application/wasm;base64,AGFzbQEAAAABUw1gAX8Bf2ACf38Bf2ABfwBgA39/fwF/YAJ/fwBgA39/fwBgBn9/f39/fwF/YAAAYAR/f39/AGAEf39/fwF/YAABf2AFf39/f38AYAV/f39/fwF/AngDA2VudiduZXVyb2dsYW5jZXJfZHJhY29fcmVjZWl2ZV9kZWNvZGVkX21lc2gACxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCXByb2NfZXhpdAACA2Vudh9lbXNjcmlwdGVuX25vdGlmeV9tZW1vcnlfZ3Jvd3RoAAID/wH9AQcMBAQECAEEBAkDAQMDAQUDAQMFAgEAAQEDAQMDAQABAwEEAQEBAQABAQMDAwkDAQMDAwEAAQUAAAEAAAABAQEBBQAFBAACBAIEAwEEAQECBAQCBAECBQQCCAIFAAADAAQABAAEAQIBBAQAAAEBAwQFBAIBAQACAQAAAQACAAIBAAIAAAIAAAIAAQEAAgACAAIAAgACAAIFBAIAAgACAQAICAIAAQEGAAAGAAIAAQYAAgAAAQEGAAIAAQYGBgACBgACBgACBgYEBQAAAgEAAQUCAAIAAAIBAAECAAIBAAEEBwMACgcHBQACBQAEAAMHAAADAAICBwMDAwAKAgAEBwFwAeUB5QEFBgEBAYCAAgYIAX8BQeCpAgsHmgEJBm1lbW9yeQIAGW5ldXJvZ2xhbmNlcl9kcmFjb19kZWNvZGUABAZtYWxsb2MA9QEZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC19pbml0aWFsaXplAOMBEF9fZXJybm9fbG9jYXRpb24A5gEJc3RhY2tTYXZlAP0BDHN0YWNrUmVzdG9yZQD+AQpzdGFja0FsbG9jAP8BCeECAQBBAQvkAXh5ExQnent8ffEBIDt+fxwdHh8gIiOAAYEBJCaCASgpKiuDAYQBHCwtLy6FATKGAYcBMzU0Njc4iQGKATs9PDptbj+LAYwBjQE+jgGPAUBBQkNIO19gkAGRAUBBQkNiO19gkgGTAUBBQkNkO19glAGVATtoO4gBfX1meYgBO5gBmQGaAZsBlgGXAXN0GXU7CQsMDQ4PEHZ3RZwBRJ0BngGfAaABoQGiAaoBpQE7X6YBiAGnAX2IATuoAakBeaUBqwGmAawBrQGuAa8BpgGwAbEBsgGzAbQBtQE7fbYBtwG4AbkBugG7AbUBO322AbwBvQGlATumAb4BpQGrAaYBvwHAAcEBrwGmAbABwgHDAcQBtAG1ATt9tgG3AcUBxgHHAbsBtQE7fbYBvAHIAaUBiAE7yQHNAc4BzwHQAcwB0wHLAdQB1QHXAdgB2QHaAdYB3AHdAd4B3wHgAQMKtIAJ/QE7AQN/A0AgAEEEdCIBQdQhaiABQdAhaiICNgIAIAFB2CFqIAI2AgAgAEEBaiIAQcAARw0AC0EwEPIBGgu8LwERfyMAQbABayIHJAAgByADNgKsASAHQgA3A5gBIAdCADcAnQEgB0EAOwGmASAHQgA3A5ABIAcgAa03A4gBIAcgADYCgAEgB0H4AGoiAUIANwMAIAdCADcCbCAHIAdB6ABqQQRyNgJoIAcgATYCdCAEBEAjAEFAaiIFJAAgBUEANgIUIAVBIBDqASIBNgIIIAVCmICAgICEgICAfzcCDCABQQA6ABggAUHlCCkAADcAECABQd0IKQAANwAIIAFB1QgpAAA3AAAjAEEgayIIJAAgBSgCFCELAkACQCAHQegAaiIJQRBqIgMoAgAiAUUNACADIQYgASEEA0AgBiAEIAQoAhAgC0giChshBiAEIApBAnRqKAIAIgQNAAsgAyAGRg0AIAsgBigCEE4NAQsgCEIANwIUIAggCEEQakEEcjYCECAIQQhqIgRCADcDACAIIAs2AgAgCCAENgIEAkAgAQRAIAlBEGohAwNAAkAgASgCECIEIAtKBEAgASgCACIEDQEgASEDDAQLIAQgC04NAyABQQRqIQMgASgCBCIERQ0DIAMhAQsgASEDIAQhAQwACwALIAMhAQsgCEEEciADKAIAIgYEf0EABUEgEOoBIgYgCzYCECAGIAE2AgggBkIANwIAIAZBGGoiAUIANwIAIAYgATYCFCADIAY2AgAgCSgCDCgCACIBBH8gCSABNgIMIAMoAgAFIAYLIQEgCSgCECABEMoBIAkgCSgCFEEBajYCFCAIKAIICxAGIAhBEGogCCgCFBAGCyAIQSBqJAAgBkEUaiEGIwBBIGsiBCQAIAQCfwJAIARBIGoiAyAEQRVqIgFrIghBCUwEQCAIQQFBgB4oAgBBAUtrSA0BCyABQTE6AAAgBCABQQFqNgIIQQAMAQsgBCADNgIIQT0LNgIMIAQoAgghCiMAQRBrIgwkACAFQRhqIQEjAEEQayIJJAACQCAKIARBFWoiC2siCEFvTQRAAkAgCEEKTQRAIAEgCDoACyABIQMMAQsgASAIQQtPBH8gCEEQakFwcSIDIANBAWsiAyADQQtGGwVBCgtBAWoiDRDqASIDNgIAIAEgDUGAgICAeHI2AgggASAINgIECwNAIAogC0cEQCADIAstAAA6AAAgA0EBaiEDIAtBAWohCwwBCwsgCUEAOgAPIAMgCS0ADzoAACAJQRBqJAAMAQsQ5wEACyAMQRBqJAAgBEEgaiQAIAUgBUEIajYCMCAFQQhqIQMCQAJAIAYoAgQiAQRAIAMoAgAgAyADLQALIgRBGHRBGHVBAEgiCBshCyADKAIEIAQgCBshCCAGQQRqIQMDQAJAAkACQAJAAkACQCABKAIUIAEtABsiBCAEQRh0QRh1QQBIIgobIgQgCCAEIAhJIgwbIgkEQCALIAFBEGoiDSgCACANIAobIgogCRDkASINRQRAIAQgCEsNAgwDCyANQX9KDQIMAQsgBCAITQ0CCyABKAIAIgQNBAwHCyAKIAsgCRDkASIEDQELIAwNAQwGCyAEQX9KDQULIAFBBGohAyABKAIEIgRFDQQgAyEBCyABIQMgBCEBDAALAAsgBkEEaiEBCyABIQMLIAUgAygCACIEBH9BAAVBKBDqASIEQRBqIQsCQCAFKAIwIggsAAtBAE4EQCALIAgpAgA3AgAgCyAIKAIINgIIDAELIAsgCCgCACAIKAIEEOwBCyAEIAE2AgggBEIANwIAIARBADYCJCAEQgA3AhwgAyAENgIAIAYoAgAoAgAiAQR/IAYgATYCACADKAIABSAECyEBIAYoAgQgARDKASAGIAYoAghBAWo2AghBAQs6ADwgBSAENgI4IAUoAjgiAyEBIAMsACdBf0wEQCABKAIcEOsBCyABIAUpAxg3AhwgASAFKAIgNgIkIAUsABNBf0wEQCAFKAIIEOsBCyAFQUBrJAALIAdB0ABqIQ8jAEEQayIBJABB7AAQ6gEiCkEEakEAQdAAEPoBGiAKQgA3AlQgCkHcEDYCACAKQgA3AlwgCkIANwJkIAdB6ABqIQkjAEHQAGsiAyQAIAMgB0GAAWoiBSkDIDcDSCADQUBrIAUpAxg3AwAgAyAFKQMQNwM4IAMgBSkDCDcDMCADIAUpAwA3AyggASADQShqIANBGGoQOQJAIAEoAgANACABQQRqIRAgASwAD0F/TARAIBAoAgAQ9wELIAMtAB9BAUcEQEEgEOoBIgRB+wooAAA2ABAgBEHzCikAADcACCAEQesKKQAANwAAIARBADoAFCABQX82AgAgECAEQRQQ7AEgBBD3AQwBCyADLQAgIQYjAEEQayIEJAACQAJAAkACQCAGDgIAAQILQTAQ6gEiBkIANwIEIAZCADcCKCAGQcgPNgIAIAZCADcCDCAGQgA3AhQgBkIANwIcIAZBADsBJCADQgA3AgggA0IANwIAIAMgBjYCEAwCC0E0EOoBIgZCADcCBCAGQgA3AiggBkEANgIwIAZB+A02AgAgBkIANwIMIAZCADcCFCAGQgA3AhwgBkEAOwEkIANCADcCCCADQgA3AgAgAyAGNgIQDAELQSAQ6gEiBkGqCygAADYAGCAGQaILKQAANwAQIAZBmgspAAA3AAggBkGSCykAADcAACAGQQA6ABwgBEF/NgIAIARBBHIiCyAGQRwQ7AEgBCwADyEMIAMgBCgCADYCACADQQRqIQgCQCAMQQBOBEAgCCALKQIANwIAIAggCygCCDYCCAwBCyAIIAQoAgQgBCgCCBDsAQsgA0EANgIQIAQsAA9Bf0wEQCAEKAIEEOsBCyAGEOsBCyAEQRBqJAACQCADKAIAIgQEQCABIAQ2AgAgAywAD0EATgRAIBAgA0EEciIEKQIANwIAIBAgBCgCCDYCCAwCCyAQIAMoAgQgAygCCBDsAQwBCyADKAIQIQYgA0EANgIQIAYgCjYCLCMAQSBrIgskACAGIAU2AiAgBiAJNgIoIAYgCjYCBCABIAUgC0EQahA5AkAgASgCAA0AIAFBBGohCCABLAAPQX9MBEAgCCgCABDrAQsgCy0AFyIJIAYgBigCACgCCBEAAEcEQEHAABDqASIEQfUJLwAAOwAwIARB7QkpAAA3ACggBEHlCSkAADcAICAEQd0JKQAANwAYIARB1QkpAAA3ABAgBEHNCSkAADcACCAEQcUJKQAANwAAIARBADoAMiABQX82AgAgCCAEQTIQ7AEgBBDrAQwBCyAGIAstABUiBDoAJCAGIAstABYiBToAJSAEQQFrQf8BcUECTwRAQSAQ6gEiBEHiCikAADcADiAEQdwKKQAANwAIIARB1AopAAA3AAAgBEEAOgAWIAFBezYCACAIIARBFhDsASAEEOsBDAELAkAgBEECRw0AQQJBAyAJGyAFTw0AQSAQ6gEiBEHLCikAADcADiAEQcUKKQAANwAIIARBvQopAAA3AAAgBEEAOgAWIAFBezYCACAIIARBFhDsASAEEOsBDAELIAYoAiAgBEEIdCAFciIEOwEmAkAgBEH//wNxQYMCSQ0AIAsuARpBf0oNACMAQRBrIg0kAEEkEOoBIgRCADcCBCAEQgA3AhggBEEQaiIFQgA3AgAgBCAEQQRqNgIAIARBADYCICAEIAU2AgwgDSAENgIIIA1BADYCAAJAAn8gBigCICEFIwBBEGsiCSQAAn8CQCAERQ0AIA0gBTYCACAJQQA2AgRBAEEBIAlBBGogBRAVRQ0BGgJAIAkoAgQiEwRAA0BBASAJIA0oAgAQFUUNA0EcEOoBIgVCADcCBCAFQRBqIgxCADcCACAFIAVBBGo2AgAgBSAMNgIMIAUgCSgCADYCGCANIAUQakUNAiAJIAU2AggCQCAEKAIcIgwgBCgCIEkEQCAJQQA2AgggDCAFNgIAIAQgDEEEajYCHAwBC0EAIQUCQAJAAkAgBCgCHCAEKAIYIg5rQQJ1IhFBAWoiDEGAgICABEkEQCAMIAQoAiAgDmsiDkEBdSISIAwgEksbQf////8DIA5BAnVB/////wFJGyIOBEAgDkGAgICABE8NAiAOQQJ0EOoBIQULIAkoAgghEiAJQQA2AgggBSARQQJ0aiIMIBI2AgAgBSAOQQJ0aiERIAxBBGohEiAEKAIcIgUgBCgCGCIORg0CA0AgBUEEayIFKAIAIRQgBUEANgIAIAxBBGsiDCAUNgIAIAUgDkcNAAsgBCARNgIgIAQoAhwhBSAEIBI2AhwgBCgCGCEOIAQgDDYCGCAFIA5GDQMDQCAFQQRrIgUoAgAhDCAFQQA2AgAgDARAIAxBDGogDCgCEBBrIAwgDCgCBBBsIAwQ9wELIAUgDkcNAAsMAwsQ5wEACxD4AQALIAQgETYCICAEIBI2AhwgBCAMNgIYCyAOBEAgDhD3AQsLIAkoAgghBSAJQQA2AgggBQRAIAVBDGogBSgCEBBrIAUgBSgCBBBsIAUQ6wELIBVBAWoiFSATRw0ACwsgDSAEEGoMAgsgBUEMaiAFKAIQEGsgBSAFKAIEEGwgBRDrAQtBAAshBSAJQRBqJAAgBQsEQCAGKAIEIgkoAgQhBSAJIAQ2AgQgBQRAIAUQaQsgAUIANwIAIAFCADcCCAwBC0EgEOoBIgVBxwsvAAA7ABggBUG/CykAADcAECAFQbcLKQAANwAIIAVBrwspAAA3AAAgBUEAOgAaIAFBfzYCACABQQRqIAVBGhDsASAFEPcBIA1BADYCCCAEEGkLIA1BEGokACABKAIADQEgCCwAC0F/Sg0AIAgoAgAQ6wELIAYgBigCACgCDBEAAEUEQEEwEOoBIgRBuwotAAA6ACAgBEGzCikAADcAGCAEQasKKQAANwAQIARBowopAAA3AAggBEGbCikAADcAACAEQQA6ACEgAUF/NgIAIAggBEEhEOwBIAQQ6wEMAQsgBiAGKAIAKAIUEQAARQRAIAtBygsQGyEEIAFBfzYCACAELAALQQBOBEAgCCALKQMANwIAIAggCygCCDYCCAwCCyAIIAQoAgAgBCgCBBDsASAELAALQX9KDQEgBCgCABDrAQwBCyAGIAYoAgAoAhgRAABFBEAgC0H4CRAbIQQgAUF/NgIAIAQsAAtBAE4EQCAIIAspAwA3AgAgCCALKAIINgIIDAILIAggBCgCACAEKAIEEOwBIAQsAAtBf0oNASAEKAIAEOsBDAELIAFCADcCACABQgA3AggLIAtBIGokACABKAIARQRAIBAsAAtBf0wEQCAQKAIAEPcBCyABQgA3AgAgAUIANwIICyAGIAYoAgAoAgQRAgALIAMoAhAhBCADQQA2AhAgBARAIAQgBCgCACgCBBECAAsgAywAD0F/Sg0AIAMoAgQQ9wELIANB0ABqJAACQAJAIAEoAgAiAwRAIA8gAzYCACAPQQRqIQMgASwAD0EATgRAIAMgAUEEciIEKQIANwIAIAMgBCgCCDYCCCAPQQA2AhAMAgsgAyABKAIEIAEoAggQ7AEgASwADyEDIA9BADYCECADQX9KDQEgASgCBBDrAQwBCyABLAAPQX9MBEAgASgCBBDrAQsgD0IANwIAIA8gCjYCECAPQgA3AggMAQsgCiAKKAIAKAIEEQIACyABQRBqJABBASEBAkAgBygCUA0AIAcoAmAiAygCUCELIAcgAygCZCADKAJgIgprIglBDG0iCDYCTEEDIQEgAygCGCADKAIUIgRrQQFIDQAgBCgCACIEQX9GDQAgAygCCCAEQQJ0aigCACIFRQ0AQQQhASAFLQAYQQNHDQBBBSEBAkAgBSgCHEEFaw4FAAEBAQABC0ELIQEgAygCVCAFKAI8QQJ0aigCAEEBRw0AIAsgBSgCUCIBRwRAIAFB6AdqIQEMAQsgByAJEPMBIgM2AkgCQCAJRQ0AQQAhBANAIAMgBEEMbCIGaiIBIAYgCmoiBigCADYCACABIAYoAgQ2AgQgASAGKAIINgIIIARBAWoiBCAIRw0ACyAFLQBUDQAgCEEDbCIGQQNxIQwgBSgCRCEBQQAhBCAGQQFrQQNPBEAgBkF8cSEGA0AgAyAEQQJ0IgpqIg0gASANKAIAQQJ0aigCADYCACADIApBBHJqIg0gASANKAIAQQJ0aigCADYCACADIApBCHJqIg0gASANKAIAQQJ0aigCADYCACADIApBDHJqIgogASAKKAIAQQJ0aigCADYCACAEQQRqIQQgBkEEayIGDQALCyAMRQ0AA0AgAyAEQQJ0aiIGIAEgBigCAEECdGooAgA2AgAgBEEBaiEEIAxBAWsiDA0ACwsgByAFKAIAKAIAIAUoAjBqIgE2AkQCQCACBEAgByAHQawBajYCQCAHIAkQ8wE2AjggByAHQcgAajYCNCAHIAdBxABqNgIwIAcgB0FAazYCLCAHIAdBzABqNgIoIAdBADYCICAHQgA3AxggB0IANwMQIAdCADcDCCAHQgA3AwBBACEEIAcoAigiCSgCAEEDbARAIAcoAiwoAgAhCiAHKAI0KAIAIQwgBygCMCgCACEDA0BBqgFB/wFBf0EgIAooAgBrdkEBdiIBQQFqIgIgAyAMIARBAnRqIgYoAghBDGxqIgUoAgAiCEkbQdUAIAEgCEkbIghBzAFxIAggAiAFKAIEIg1JGyAIQTNxIAEgDUkbIghB8AFxIAggAiAFKAIIIgVJGyAIQQ9xIAEgBUkbQaoBQf8BIAIgAyAGKAIEQQxsaiIFKAIAIghJG0HVACABIAhJGyIIQcwBcSAIIAIgBSgCBCINSRsgCEEzcSABIA1JGyIIQfABcSAIIAIgBSgCCCIFSRsgCEEPcSABIAVJG0GqAUH/ASACIAMgBigCAEEMbGoiBigCACIFSRtB1QAgASAFSRsiBUHMAXEgBSACIAYoAgQiCEkbIAVBM3EgASAISRsiBUHwAXEgBSACIAYoAggiBkkbIAVBD3EgASAGSRtxcUHAEWotAABBAnQgB2oiASABKAIEQQNqNgIEIARBA2oiBCAJKAIAQQNsSQ0ACwsgBygCDCEBIAcgBygCBCICIAcoAghqIgM2AgwgBygCECEEIAcgASADaiIBNgIQIAcoAhQhAyAHIAEgBGoiATYCFCAHKAIYIQQgByABIANqIgE2AhggBygCHCEDIAcgASAEaiIBNgIcIAcgASADajYCICAHQQA2AgQgByACNgIIQQAhAyAHKAIoIgwoAgBBA2wEQCAHKAI4IQ0gBygCSCEEIAcoAiwoAgAhDyAHKAI0KAIAIQYgBygCMCgCACEFA0BBqgFB/wFBf0EgIA8oAgBrdkEBdiIBQQFqIgIgBSAGIANBAnQiCEEIaiIQaigCAEEMbGoiCSgCACIKSRtB1QAgASAKSRsiCkHMAXEgCiACIAkoAgQiDkkbIApBM3EgASAOSRsiCkHwAXEgCiACIAkoAggiCUkbIApBD3EgASAJSRtBqgFB/wEgAiAFIAYgCEEEaiIOaigCAEEMbGoiCSgCACIKSRtB1QAgASAKSRsiCkHMAXEgCiACIAkoAgQiEUkbIApBM3EgASARSRsiCkHwAXEgCiACIAkoAggiCUkbIApBD3EgASAJSRtBqgFB/wEgAiAFIAYgCGooAgBBDGxqIgkoAgAiCkkbQdUAIAEgCkkbIgpBzAFxIAogAiAJKAIEIhFJGyAKQTNxIAEgEUkbIgpB8AFxIAogAiAJKAIIIglJGyAKQQ9xIAEgCUkbcXFBwBFqLQAAQQJ0IAdqIgEgASgCBCIBQQNqNgIEIA0gAUECdGoiASAEIAhqKAIANgIAIAEgBCAOaigCADYCBCABIAQgEGooAgA2AgggA0EDaiIDIAwoAgBBA2xJDQALCyAHKAJMIAsgBygCOCAHKAJEIAcQACAHKAI4IQEgB0EANgI4IAEEQCABEPYBCyAHKAJIIQMMAQsgB0EANgIAIAcgCEEDbDYCBCAIIAsgAyABIAcQAAtBACEBIAdBADYCSCADRQ0AIAMQ9gELIAcoAmAhAiAHQQA2AmAgAgRAIAIgAigCACgCBBECAAsgBywAX0F/TARAIAcoAlQQ9wELIAdB9ABqIAcoAngQBSAHQegAaiAHKAJsEAYgAARAIAAQ9gELIAdBsAFqJAAgAQsqACABBEAgACABKAIAEAUgACABKAIEEAUgAUEUaiABKAIYEAYgARD3AQsLRAAgAQRAIAAgASgCABAGIAAgASgCBBAGIAEsACdBf0wEQCABKAIcEPcBCyABLAAbQX9MBEAgASgCEBD3AQsgARD3AQsL6QEBBn8CQAJAIAEgACgCBCICIAAoAgAiBGsiBUsEQCABIAVrIgYgACgCCCIDIAJrTQRAIAAgBgR/IAJBACAGEPoBIAZqBSACCzYCBA8LIAFBf0wNAkEAIQICfyABIAMgBGsiA0EBdCIHIAEgB0sbQf////8HIANB/////wNJGyIDBEAgAxDqASECCyACIAVqC0EAIAYQ+gEaIAVBAU4EQCACIAQgBRD5ARoLIAAgAiADajYCCCAAIAEgAmo2AgQgACACNgIAIARFDQEgBBD3AQ8LIAEgBU8NACAAIAEgBGo2AgQLDwsQ5wEAC8wDAQZ/IAMgAmsiCEEBSARADwsCQCAAKAIIIgYgACgCBCIHayAITgRAIAcgAWsiCSAITgRAIAchBSADIQYMAgsgByEFIAMgAiAJaiIGRwRAIAYhBANAIAUgBC0AADoAACAFQQFqIQUgBEEBaiIEIANHDQALCyAAIAU2AgQgCUEBTg0BDwsgByAAKAIAIgRrIAhqIgVBf0oEQCABIARrIQMgAyAFIAYgBGsiBkEBdCIJIAUgCUsbQf////8HIAZB/////wNJGyIGBH8gBhDqAQVBAAsiBWogAiAIEPkBIQIgA0EBTgRAIAUgBCADEPkBGgsgAiAIaiECIAEgB0cEQANAIAIgAS0AADoAACACQQFqIQIgAUEBaiIBIAdHDQALIAAoAgAhBAsgACAFIAZqNgIIIAAgAjYCBCAAIAU2AgAgBARAIAQQ9wELDwsQ5wEACyAHIAUiBCAIayIDSwRAA0AgBCADLQAAOgAAIARBAWohBCADQQFqIgMgB0kNAAsLIAAgBDYCBCAFIAEgCGprIgAEQCAFIABrIAEgABD7ARoLIAIgBkYEQA8LIAEhBANAIAQgAi0AADoAACAEQQFqIQQgAkEBaiICIAZHDQALC+QCAQh/AkAgASgCWCIDRQ0AIAMoAgBBAUcNACAAIAMoAggoAAA2AgQCQCAAKAIMIAAoAggiBGtBAnUiBSABLAAYIgJJBEAgAEEIaiACIAVrEAogASwAGCECIAAoAgghBAwBCyACIAVPDQAgACAEIAJBAnRqNgIMC0EBIQggAygCCCEDAkAgAkEBSARAQQQhAQwBCyACQQNxIQUCQCACQQFrQQNJBEBBBCEBQQAhAgwBCyACQXxxIQlBACECQQQhAQNAIAQgAkECdCIGaiABIANqIgcqAAA4AgAgBCAGQQRyaiAHKgAEOAIAIAQgBkEIcmogByoACDgCACAEIAZBDHJqIAcqAAw4AgAgAkEEaiECIAFBEGohASAJQQRrIgkNAAsLIAVFDQADQCAEIAJBAnRqIAEgA2oqAAA4AgAgAkEBaiECIAFBBGohASAFQQFrIgUNAAsLIAAgASADaioAADgCFAsgCAv/AQEHfyABIAAoAggiBSAAKAIEIgJrQQJ1TQRAIAAgAQR/IAJBACABQQJ0IgAQ+gEgAGoFIAILNgIEDwsCQCACIAAoAgAiBGsiBkECdSIHIAFqIgNBgICAgARJBEBBACECAn8gAyAFIARrIgVBAXUiCCADIAhLG0H/////AyAFQQJ1Qf////8BSRsiAwRAIANBgICAgARPDQMgA0ECdBDqASECCyAHQQJ0IAJqC0EAIAFBAnQiARD6ASABaiEBIAZBAU4EQCACIAQgBhD5ARoLIAAgAiADQQJ0ajYCCCAAIAE2AgQgACACNgIAIAQEQCAEEPcBCw8LEOcBAAsQ+AEAC4cCAQV/IAFBATYCACABQQhqIQQgASgCDCABKAIIIgNrIgJBe00EfyAEIAJBBGoQByABIAEpAyBCAXw3AyAgASgCCAUgAwsgAmogACgCBDYAACAAKAIIIgIgACgCDEcEQEEAIQMDQCACIANBAnRqIQYgASgCDCABKAIIIgJrIgVBe00EfyAEIAVBBGoQByABIAEpAyBCAXw3AyAgASgCCAUgAgsgBWogBigCADYAACADQQFqIgMgACgCDCAAKAIIIgJrQQJ1SQ0ACwsgASgCDCABKAIIIgNrIgJBe00EfyAEIAJBBGoQByABIAEpAyBCAXw3AyAgASgCCAUgAwsgAmogACgCFDYAAAuAEgMPfwJ9BX4gAigCACACKAIERgRAIAMoAlAhBSADKAIwIQQgAygCACgCACEDIAAiAigCBCEGIAIqAhQhFEF/IAEsABgiB0ECdCAHQf////8DcSAHRxsQ6gEhCwJAAkAgBUUNACABKAIAIQkgASkDMCEVIAEoAkQhCCABLQBUIQAgASkDKCIWpyEKIAdBAU4EQCADIARqIQ5BfyAGdEF/c7IgFJUhFCAARQRAIAdBfnEhASAHQQFxIRBBACEDA0AgCyAJKAIAIBYgCCAMQQJ0ajUCAH4gFXynaiAKEPkBIQYgAigCCCEPQQAhBCABIQAgB0EBRwRAA0AgDiADQQJ0aiIRAn8gFCAGIARBAnQiDWoqAgAgDSAPaioCAJOUQwAAAD+SjiITi0MAAABPXQRAIBOoDAELQYCAgIB4CzYCACARAn8gFCAGIA1BBHIiDWoqAgAgDSAPaioCAJOUQwAAAD+SjiITi0MAAABPXQRAIBOoDAELQYCAgIB4CzYCBCAEQQJqIQQgA0ECaiEDIABBAmsiAA0ACwsgEARAIA4gA0ECdGoCfyAUIAYgBEECdCIAaioCACAAIA9qKgIAk5RDAAAAP5KOIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLNgIAIANBAWohAwsgDEEBaiIMIAVHDQALDAILIAdBfnEhASAHQQFxIQ8gBa0hGEEAIQMDQCALIAkoAgAgFiAXfiAVfKdqIAoQ+QEhBSACKAIIIQhBACEEIAEhACAHQQFHBEADQCAOIANBAnRqIgwCfyAUIAUgBEECdCIGaioCACAGIAhqKgIAk5RDAAAAP5KOIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLNgIAIAwCfyAUIAUgBkEEciIGaioCACAGIAhqKgIAk5RDAAAAP5KOIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLNgIEIARBAmohBCADQQJqIQMgAEECayIADQALCyAPBEAgDiADQQJ0agJ/IBQgBSAEQQJ0IgBqKgIAIAAgCGoqAgCTlEMAAAA/ko4iE4tDAAAAT10EQCATqAwBC0GAgICAeAs2AgAgA0EBaiEDCyAXQgF8IhcgGFINAAsMAQsgAEUEQEEAIQMgBUEBRwRAIAVBfnEhBANAIAsgCSgCACAWIAggA0ECdCIAajUCAH4gFXynaiAKEPkBIAkoAgAgFiAIIABBBHJqNQIAfiAVfKdqIAoQ+QEaIANBAmohAyAEQQJrIgQNAAsLIAVBAXFFDQEgCyAJKAIAIBYgCCADQQJ0ajUCAH4gFXynaiAKEPkBEKABDAILIAWtIhhCAYMhGSAFQQFHBEAgGEL+////D4MhGANAIAsgCSgCACAWIBd+IBV8p2ogChD5ASAJKAIAIBYgF0IBhH4gFXynaiAKEPkBGiAXQgJ8IRcgGEICfSIYUEUNAAsLIBlQDQAgCyAJKAIAIBYgF34gFXynaiAKEPkBGgsgCxCgAQtBAQ8LIAMoAjAhBCADKAIAKAIAIQggACIDKAIEIQwgAyoCFCEUQX8gASwAGCIHQQJ0IAdB/////wNxIAdHGxDqASELAkACQCACKAIEIAIoAgAiBWsiAEUNACABKAIAIQkgASkDMCEVIAEoAkQhBiABLQBUIQIgASkDKCIWpyEKIABBAnUiAEEBIABBAUsbIQ4CQCAHQQFOBEAgBCAIaiEPQX8gDHRBf3OyIBSVIRQgAkUNASAHQX5xIQEgB0EBcSEQQQAhAkEAIQgDQCALIAkoAgAgFiAFIAhBAnRqNQIAfiAVfKdqIAoQ+QEhBiADKAIIIQxBACEEIAEhACAHQQFHBEADQCAPIAJBAnRqIhECfyAUIAYgBEECdCINaioCACAMIA1qKgIAk5RDAAAAP5KOIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLNgIAIBECfyAUIAYgDUEEciINaioCACAMIA1qKgIAk5RDAAAAP5KOIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLNgIEIARBAmohBCACQQJqIQIgAEECayIADQALCyAQBEAgDyACQQJ0agJ/IBQgBiAEQQJ0IgBqKgIAIAAgDGoqAgCTlEMAAAA/ko4iE4tDAAAAT10EQCATqAwBC0GAgICAeAs2AgAgAkEBaiECCyAIQQFqIgggDkcNAAsMAgsgAgRAQQAhAiAAQQJPBEAgDkF+cSEEA0AgCyAJKAIAIBYgBSACQQJ0IgBqNQIAfiAVfKdqIAoQ+QEgCSgCACAWIAUgAEEEcmo1AgB+IBV8p2ogChD5ARogAkECaiECIARBAmsiBA0ACwsgDkEBcUUNAiALIAkoAgAgFiAFIAJBAnRqNQIAfiAVfKdqIAoQ+QEQoAEMAwtBACECIABBAk8EQCAOQX5xIQQDQCALIAkoAgAgFiAGIAUgAkECdCIAaigCAEECdGo1AgB+IBV8p2ogChD5ASAJKAIAIBYgBiAFIABBBHJqKAIAQQJ0ajUCAH4gFXynaiAKEPkBGiACQQJqIQIgBEECayIEDQALCyAOQQFxRQ0BIAsgCSgCACAWIAYgBSACQQJ0aigCAEECdGo1AgB+IBV8p2ogChD5ARoMAQsgB0F+cSEBIAdBAXEhEUEAIQJBACEIA0AgCyAJKAIAIBYgBiAFIAhBAnRqKAIAQQJ0ajUCAH4gFXynaiAKEPkBIQwgAygCCCENQQAhBCABIQAgB0EBRwRAA0AgDyACQQJ0aiISAn8gFCAMIARBAnQiEGoqAgAgDSAQaioCAJOUQwAAAD+SjiITi0MAAABPXQRAIBOoDAELQYCAgIB4CzYCACASAn8gFCAMIBBBBHIiEGoqAgAgDSAQaioCAJOUQwAAAD+SjiITi0MAAABPXQRAIBOoDAELQYCAgIB4CzYCBCAEQQJqIQQgAkECaiECIABBAmsiAA0ACwsgEQRAIA8gAkECdGoCfyAUIAwgBEECdCIAaioCACAAIA1qKgIAk5RDAAAAP5KOIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLNgIAIAJBAWohAgsgCEEBaiIIIA5HDQALCyALEKABC0EBC9YDAg5/AX0gAigCHEEJRgRAIAAoAgQhCEF/IAIsABgiB0ECdCIGIAdB/////wNxIAdHGxDqASEEAkBBfyAIdCIIQX5KDQAgAigCUCIJRQRAQQEhBQwBCyAHQQBMBEBBASEFIAlBAUcEQCAJQX5xIQEDQCACKAJAKAIAIANqIAQgBhD5ARogAyAGaiIAIAIoAkAoAgBqIAQgBhD5ARogACAGaiEDIAFBAmsiAQ0ACwsgCUEBcUUNASACKAJAKAIAIANqIAQgBhD5ARoMAQsgASgCACgCACABKAIwaiEMIAAqAhQgCEF/c7KVIREgB0F+cSEIIAdBAXEhDgNAIAAoAgghC0EAIQUgCCEBIAdBAUcEQANAIAQgBUECdCIKaiARIAwgA0ECdGoiDygCALKUIAogC2oqAgCSOAIAIAQgCkEEciIKaiARIA8oAgSylCAKIAtqKgIAkjgCACAFQQJqIQUgA0ECaiEDIAFBAmsiAQ0ACwsgDgRAIAQgBUECdCIBaiARIAwgA0ECdGooAgCylCABIAtqKgIAkjgCACADQQFqIQMLIAIoAkAoAgAgDWogBCAGEPkBGiAGIA1qIQ1BASEFIBBBAWoiECAJRw0ACwsgBBDrAQsgBQuRAQIDfwF+IwBBEGsiAiQAAkAgACgCBCIDQX9GDQAgASkDEEIAVQ0AIAEgASgCBCAAKAIIIAAoAgwQCCABKQMQQgFZDQAgASABKAIEIABBFGoiBCAEQQRqEAggASkDECEFIAIgACgCBDoADyAFQgBVDQAgASABKAIEIAJBD2ogAkEQahAICyACQRBqJAAgA0F/RwuDAgIDfwJ+AkAgACgCDCIEIAAoAggiA2tBAnUiBSABLAAYIgFJBEAgAEEIaiABIAVrEAogACgCCCEDIAAoAgwhBAwBCyABIAVPDQAgACADIAFBAnRqIgQ2AgwLQQAhAQJAIAIpAwggAikDECIGIAQgA2siBK0iB3xTDQAgAyACKAIAIAanaiAEEPkBGiACIAIpAxAgB3wiBjcDECACKQMIIAZCBHxTDQAgACACKAIAIAanaigAADYCFCACIAIpAxAiB0IEfCIGNwMQIAIpAwggBlcNACACKAIAIAanai0AACEDIAIgB0IFfDcDECADQQFrQR1LDQAgACADNgIEQQEhAQsgAQuCAgEEfyMAQSBrIgMkACAAIAEgACgCACgCLBEBACEEIAAgASAAKAIAKAIoEQEAIQUgA0IANwIYIANCADcCECABKAI4IQYgBUEBayIAQQtPBH9BACAEawUgAEECdEH4G2ooAgAgBGwLIQFB4AAQ6gEiAEEANgIAIAAgAykCDDcCBCAAIAMpAhQ3AgwgACADKAIcNgIUIABBADYCWCAAQQA2AjwgACAGNgI4IABCADcDMCAAIAGsNwMoIABBADoAICAAIAU2AhwgACAEOgAYIABCADcDQCAAQgA3A0ggAEIANwBNIAAgAhARGiAAQQE6AFQgACAAKAJENgJIIANBIGokACAAC8wBAgJ/An4gACgCQCICRQRAQSAQ6gEiAkIANwMQIAJBADYCCCACQgA3AwAgAkIANwMYIAAgAjYCQAtCgICAgHAhBCAAKAIcQQFrIgNBCk0EfiADQQN0QcgaaikDAAVCgICAgHALIAAwABh+QiCHIgUgAa1+IgRCAFkEQCACIASnEAcgAkEYaiACKQMYQgF8NwMAIAAgACgCQCICNgIAIAAgAikDEDcDCCAAIAIpAxg3AxAgACAFNwMoIABCADcDMCAAIAE2AlALIARCf1ULuQIBBX8gAiABayIDQQJ1IgYgACgCCCIFIAAoAgAiBGtBAnVNBEAgASABIAAoAgQiBSAEayIDaiACIAYgA0ECdSIHSxsiA0cEQANAIAQgASgCADYCACAEQQRqIQQgAUEEaiIBIANH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DCACEPcBCyABEPcBCyAAKAJEIgEEQCAAIAE2AkggARD3AQsgACgCQCEBIABBADYCQCABBEAgASgCACICBEAgASACNgIEIAIQ9wELIAEQ9wELIAAQ9wELC44DAgd/A34jAEEQayIEJAACQCABKQMQIgkgASkDCFkNACAAIAEoAgAgCadqLQAAOgAMIAEgASkDECIJQgF8Igo3AxACQCABLwEmQYEETQRAIAEpAwgiCyAJQgV8IglTDQIgASgCACAKp2ooAAAhAiABIAk3AxAMAQtBASAEQQxqIAEQFUUNASABKQMQIQkgASkDCCELIAQoAgwhAgsgAq0iCiALIAl9VQ0AIAJBAUgNACAAIAEoAgAgCadqIgU2AgAgAAJ/IAUgAkEBayIGaiIHLQAAIghBP00EQCAAIAY2AgQgBy0AAEE/cQwBCwJAAkAgCEEGdkEBaw4CAAEDCyACQQJIDQIgACACQQJrNgIEIAIgBWpBAmsiAi0AAUEIdEGA/gBxIAItAAByDAELIAJBA0gNASAAIAJBA2s2AgQgAiAFakEDayICLQACQRB0QYCA/AFxIAItAAFBCHRyIAItAAByC0GAIGoiADYCCCAAQf//P0sNACABIAkgCnw3AxBBASEDCyAEQRBqJAAgAwskAQF/IABBjBE2AgAgACgCCCIBBEAgACABNgIMIAEQ9wELIAALnwIBCH8gAEEEaiEGAkACQCAAKAIEIgBFDQAgASgCACABIAEtAAsiBEEYdEEYdUEASCICGyEHIAEoAgQgBCACGyEDIAYhAgNAAkAgAyAAKAIUIAAtABsiASABQRh0QRh1QQBIIgkbIgggAyAISSIFGyIEBEAgAEEQaiIBKAIAIAEgCRsgByAEEOQBIgENAQtBfyAFIAMgCEsbIQELIAIgACABQQBIGyECIAAgAUEddkEEcWooAgAiAA0ACyACIAZGDQACQCACKAIUIAItABsiACAAQRh0QRh1QQBIIgQbIgUgAyADIAVLGyIBBEAgByACQRBqIgAoAgAgACAEGyABEOQBIgANAQsgAyAFSQ0BDAILIABBf0oNAQsgBiECCyACC3cBA38gARD8ASICQXBJBEACQAJAIAJBC08EQCACQRBqQXBxIgQQ6gEhAyAAIARBgICAgHhyNgIIIAAgAzYCACAAIAI2AgQMAQsgACACOgALIAAhAyAC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aiIENgIkC0EAIQICQCABKQMIIAEpAxAiByAEIANrIgStIgh8Uw0AIAMgASgCACAHp2ogBBD5ARogASABKQMQIAh8Igc3AxAgASkDCCAHQgR8Uw0AIAAgASgCACAHp2ooAAA2AiwgASABKQMQIghCBHwiBzcDECABKQMIIAdXDQAgASgCACAHp2otAAAhAyABIAhCBXw3AxAgA0EBa0EdSw0AIAAgAzYCHEEBIQILIAILEgAgAEEYaiAAECEgACgCCBANC+IKAgJ/An4jAEEwayIDJAAgA0HGECkBADcBJiADQcAQKQMANwMgIANBuBApAwA3AxggA0GwECkDADcDEAJAAkAgASkDCCABKQMQIgVCBXxTBEAgA0EQahD8ASIBQXBPDQICQAJAIAFBC08EQCABQRBqQXBxIgQQ6gEhAiADIARBgICAgHhyNgIIIAMgAjYCACADIAE2AgQMAQsgAyABOgALIAMhAiABRQ0BCyACIANBEGogARD5ARoLIAEgAmpBADoAACAAQX42AgAgAEEEaiEAIAMsAAtBAE4EQCAAIAMpAwA3AgAgACADKAIINgIIDAILIAAgAygCACIAIAMoAgQQ7AEgABD3AQwBCyACIAEoAgAgBadqIgQoAAA2AAAgAiAELQAEOgAEIAEgASkDEEIFfCIFNwMQIAJBvwlBBRDkAQRAQSAQ6gEiAUGQCy0AADoAECABQYgLKQAANwAIIAFBgAspAAA3AAAgAUEAOgARIABBfzYCACAAQQRqIAFBERDsASABEPcBDAELIAUgASkDCFkEQCADQRBqEPwBIgFBcE8NAgJAAkAgAUELTwRAIAFBEGpBcHEiBBDqASECIAMgBEGAgICAeHI2AgggAyACNgIAIAMgATYCBAwBCyADIAE6AAsgAyECIAFFDQELIAIgA0EQaiABEPkBGgsgASACakEAOgAAIABBfjYCACAAQQRqIQAgAywAC0EATgRAIAAgAykDADcCACAAIAMoAgg2AggMAgsgACADKAIAIgAgAygCBBDsASAAEPcBDAELIAIgASgCACAFp2otAAA6AAUgASABKQMQQgF8IgU3AxAgBSABKQMIWQRAIANBEGoQ/AEiAUFwTw0CAkACQCABQQtPBEAgAUEQakFwcSIEEOoBIQIgAyAEQYCAgIB4cjYCCCADIAI2AgAgAyABNgIEDAELIAMgAToACyADIQIgAUUNAQsgAiADQRBqIAEQ+QEaCyABIAJqQQA6AAAgAEF+NgIAIABBBGohACADLAALQQBOBEAgACADKQMANwIAIAAgAygCCDYCCAwCCyAAIAMoAgAiACADKAIEEOwBIAAQ9wEMAQsgAiABKAIAIAWnai0AADoABiABIAEpAxBCAXwiBTcDECAFIAEpAwhZBEAgA0EQahD8ASIBQXBPDQICQAJAIAFBC08EQCABQRBqQXBxIgQQ6gEhAiADIARBgICAgHhyNgIIIAMgAjYCACADIAE2AgQMAQsgAyABOgALIAMhAiABRQ0BCyACIANBEGogARD5ARoLIAEgAmpBADoAACAAQX42AgAgAEEEaiEAIAMsAAtBAE4EQCAAIAMpAwA3AgAgACADKAIINgIIDAILIAAgAygCACIAIAMoAgQQ7AEgABD3AQwBCyACIAEoAgAgBadqLQAAOgAHIAEgASkDEEIBfCIFNwMQIAUgASkDCFkEQCADIANBEGoQGyEBIABBfjYCACAAQQRqIQAgASwAC0EATgRAIAAgAykDADcCACAAIAMoAgg2AggMAgsgACABKAIAIAEoAgQQ7AEgASwAC0F/Sg0BIAEoAgAQ9wEMAQsgAiABKAIAIAWnai0AADoACCABIAEpAxAiBUIBfCIGNwMQIAEpAwggBUIDfFMEQCADIANBEGoQGyEBIABBfjYCACAAQQRqIQAgASwAC0EATgRAIAAgAykDADcCACAAIAMoAgg2AggMAgsgACABKAIAIAEoAgQQ7AEgASwAC0F/Sg0BIAEoAgAQ9wEMAQsgAiABKAIAIAanai8AADsBCiABIAEpAxBCAnw3AxAgAEIANwIIIABCADcCAAsgA0EwaiQADwsQ5wEACxoAIAAoAiwEQCAAIAAoAgAoAjARAAAPC0EACwQAQQELFgAgACgCMCIAIAEgACgCACgCFBEBAAueCgICfwF+IAAoAiAiASkDCCABKQMQIgNVBH8gASgCACADp2otAAAhAiABIANCAXw3AxAgACgCMCEBIABBADYCMCABBEAgASABKAIAKAIEEQIACwJAAkACQAJAAkACQCACDgMAAQIEC0GAAxDqASIBQbQONgIAIAFBBGpBAEHQABD6ARogAUIANwNgIAFBfzYCXCABQn83AlQgAUIANwNoIAFCADcDcCABQgA3A3ggAUIANwOAASABQgA3A4gBIAFCADcDkAEgAUIANwKcASABQYCAgPwDNgKYASABQgA3AqQBIAFCADcCrAEgAUIANwK0ASABQgA3ArwBIAFCADcCxAEgAUIANwLMASABQQA2AugBIAFBADsBjgIgAUL/////DzcC1AEgAUIANwLcASABQgA3AIUCIAFCADcDgAIgAUIANwP4ASABQgA3A/ABIAFCADcDmAIgAUEANgKQAiABQgA3A6ACIAFCADcDqAIgAUIANwCtAiABQgA3A9ACIAFBADYCyAIgAUIANwPYAiABQgA3A+ACIAFCADcA5QIgAUIANwG2AiABQgA3AL0CIAFCADcB9AIgAUIANwHuAgwCC0GoAxDqASIBQegONgIAIAFBBGpBAEHQABD6ARogAUIANwNgIAFBfzYCXCABQn83AlQgAUIANwNoIAFCADcDcCABQgA3A3ggAUIANwOAASABQgA3A4gBIAFCADcDkAEgAUIANwKcASABQYCAgPwDNgKYASABQgA3AqQBIAFCADcCrAEgAUIANwK0ASABQgA3ArwBIAFCADcCxAEgAUIANwLMASABQQA2AugBIAFBADsBjgIgAUL/////DzcC1AEgAUIANwLcASABQgA3AIUCIAFCADcDgAIgAUIANwP4ASABQgA3A/ABIAFCADcDmAIgAUEANgKQAiABQgA3A6ACIAFCADcDqAIgAUIANwCtAiABQgA3A9ACIAFBADYCyAIgAUIANwPYAiABQgA3A+ACIAFCADcA5QIgAUIANwG2AiABQgA3AL0CIAFCADcAlQMgAUIANwGOAyABQgA3AYYDIAFCADcB/gIgAUIANwH2AiABQgA3Ae4CIAFCfzcDoAMMAQtBuAMQ6gEiAUGYDzYCACABQQRqQQBB0AAQ+gEaIAFCADcDYCABQX82AlwgAUJ/NwJUIAFCADcDaCABQgA3A3AgAUIANwN4IAFCADcDgAEgAUIANwOIASABQgA3A5ABIAFCADcCnAEgAUGAgID8AzYCmAEgAUIANwKkASABQgA3AqwBIAFCADcCtAEgAUIANwK8ASABQgA3AsQBIAFCADcCzAEgAUEANgLoASABQQA7AY4CIAFC/////w83AtQBIAFCADcC3AEgAUIANwCFAiABQgA3A4ACIAFCADcD+AEgAUIANwPwASABQgA3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ADcCnAEgAUIANwKkASABQQE6AKwBIAFCADcCsAEgAUIANwK4ASABQgA3AsABIAFCADcCyAEgAUIANwLQASABQgA3AtwBIAEgAzYC2AEgAUIANwLkASABQgA3AuwBIAFBAToA9AEgAUIANwL4ASABQgA3AoACIAFCADcCiAIgAUIANwKQAiABQgA3ApgCIAFBoAJqIgEgAkcNAAsLIAAgAjYCBAwBCwJAAkACQCACIAAoAgAiAmtBkAFtIgYgA2oiAUHyuJwOSQRAIAEgBCACa0GQAW0iAkEBdCIEIAEgBEsbQfG4nA4gAkG4nI4HSRsiBAR/IARB8ricDk8NAiAEQZABbBDqAQVBAAsiByAGQZABbGoiAiEBIANBkAFsIgNBkAFrIgVBkAFuQQFxRQRAIAJBfzYCACAHIAZBkAFsaiIBQgA3AgQgAUIANwJoIAFBAToAZCABQgA3AhQgAUIANwIMIAFCADcCICABQQE6ABwgAUIANwIoIAFCADcCMCABQgA3AjggAUFAa0IANwIAIAFCADcCTCABIAFBBGo2AkggAUIANwJUIAFCADcCXCABQgA3AnAgAUIANwJ4IAFCADcCgAEgAUIANwKIASACQZABaiEBCyACIANqIQYgBUGQAU8EQANAIAFCADcCBCABQX82AgAgAUIANwJoIAFBAToAZCABQgA3AgwgAUIANwIUIAFCADcCICABQQE6ABwgAUIANwIoIAFCADcCMCABQgA3AjggAUFAa0IANwIAIAFCADcCTCABIAFBBGo2AkggAUIANwJUIAFCADcCXCABQgA3AnAgAUIANwJ4IAFCADcCgAEgAUIANwKIASABQZQBaiIDQgA3AgAgAUF/NgKQASABQgA3ApwBIAFCADcCpAEgAUEBOgCsASABQgA3ArABIAFCADcCuAEgAUIANwLAASABQgA3AsgBIAFCADcC0AEgAUIANwLcASABIAM2AtgBIAFCADcC5AEgAUIANwLsASABQQE6APQBIAFCADcC+AEgAUIANwKAAiABQgA3AogCIAFCADcCkAIgAUIANwKYAiABQaACaiIBIAZHDQALCyAHIARBkAFsaiEHIAAoAgQiASAAKAIAIgRGDQIDQCACQZABayIDIAFBkAFrIgEiAigCADYCACADIAIoAgQ2AgQgAyACKAIINgIIIAMgAigCDDYCDCACQQA2AgwgAkIANwIEIAMgAigCEDYCECADIAIoAhQ2AhQgAyACKAIYNgIYIAJBADYCGCACQgA3AhAgAi0AHCEFIANBADYCKCADQgA3AiAgAyAFOgAcIAMgAigCIDYCICADIAIoAiQ2AiQgAyACKAIoNgIoIAJBADYCKCACQgA3AiAgA0EANgI0IANCADcCLCADIAIoAiw2AiwgAyACKAIwNgIwIAMgAigCNDYCNCACQQA2AjQgAkIANwIsIANBQGsiBUEANgIAIANCADcCOCADIAIoAjg2AjggAyACKAI8NgI8IAUgAkFAayIFKAIANgIAIAVBADYCACACQgA3AjggAyACKAJENgJEIAIoAkghBSADQQA2AlQgA0IANwJMIAMgBTYCSCADIAIoAkw2AkwgAyACKAJQNgJQIAMgAigCVDYCVCACQQA2AlQgAkIANwJMIANBADYCYCADQgA3AlggAyACKAJYNgJYIAMgAigCXDYCXCADIAIoAmA2AmAgAkEANgJgIAJCADcCWCACLQBkIQUgA0EANgJwIANCADcCaCADIAU6AGQgAyACKAJoNgJoIAMgAigCbDYCbCADIAIoAnA2AnAgAkEANgJwIAJCADcCaCADQQA2AnwgA0IANwJ0IAMgAigCdDYCdCADIAIoAng2AnggAyACKAJ8NgJ8IAJBADYCfCACQgA3AnQgAigCgAEhBSADQQA2AowBIANCADcChAEgAyAFNgKAASADIAIoAoQBNgKEASADIAIoAogBNgKIASADIAIoAowBNgKMASACQQA2AowBIAJCADcChAEgAyECIAEgBEcNAAsgACAHNgIIIAAoAgQhASAAIAY2AgQgACgCACEEIAAgAjYCACABIARGDQMDQCABQQxrKAIAIgAEQCABQQhrIAA2AgAgABDrAQsgAUEcaygCACIABEAgAUEYayAANgIAIAAQ6wELIAFBKGsoAgAiAARAIAFBJGsgADYCACAAEOsBCyABQYwBaxBYIAFBkAFrIgAhASAAIARHDQALDAMLEOcBAAsQ+AEACyAAIAc2AgggACAGNgIEIAAgAjYCAAsgBARAIAQQ6wELCw8LIAEgA0kEQCAEIAFBkAFsaiIBIAJHBEADQCACQQxrKAIAIgMEQCACQQhrIAM2AgAgAxD3AQsgAkEcaygCACIDBEAgAkEYayADNgIAIAMQ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QRxrKAIAIgIEQCABQRhrIAI2AgAgAhD3AQsgAUEoaygCACICBEAgAUEkayACNgIAIAIQ9wELIAFBjAFrEFggAUGQAWsiAiEBIAIgA0cNAAsgACgC2AELIQEgACADNgLcASABEPcBCyAAKALEASIBBEAgACABNgLIASABEPcBCyAAKAK4ASIBBEAgACABNgK8ASABEPcBCyAAKAKsASIBBEAgACABNgKwASABEPcBCyAAKAKgASIBBEAgACABNgKkASABEPcBCyAAKAKQASIBBEADQCABKAIAIQMgARD3ASADIgENAAsLIAAoAogBIQEgAEEANgKIASABBEAgARD3AQsgACgCeCIBBEAgARD3AQsgACgCbCIBBEAgARD3AQsgACgCYCIBBEAgARD3AQsgACgCSCIBBEAgACABNgJMIAEQ9wELIAAoAjwiAQRAIAEQ9wELIAAoAjAiAQRAIAAgATYCNCABEPcBCyAAKAIkIgEEQCAAIAE2AiggARD3AQsgACgCGCIBBEAgACABNgIcIAEQ9wELIAAoAgwiAQRAIAAgATYCECABEPcBCyAAKAIIIQEgAEEANgIIIAEEQCABEEkLIAALCgAgABCSARD3AQuAAQEDfyAAQYQQNgIAIAAoAhQiAQRAIAAgATYCGCABEPcBCyAAKAIIIgIEQCACIAAoAgwiA0YEfyACBQNAIANBBGsiAygCACEBIANBADYCACABBEAgASABKAIAKAIEEQIACyACIANHDQALIAAoAggLIQEgACACNgIMIAEQ9wELIAALgwEBA38gAEGEEDYCACAAKAIUIgEEQCAAIAE2AhggARD3AQsgACgCCCICBEAgAiAAKAIMIgNGBH8gAgUDQCADQQRrIgMoAgAhASADQQA2AgAgAQRAIAEgASgCACgCBBECAAsgAiADRw0ACyAAKAIICyEBIAAgAjYCDCABEPcBCyAAEPcBC+YBAQN/IABB9BA2AgAgACgCRCIBBEAgACABNgJIIAEQ9wELIAAoAjgiAQRAIAAgATYCPCABEPcBCyAAKAIsIgEEQCAAIAE2AjAgARD3AQsgACgCICIBBEAgACABNgIkIAEQ9wELIAAoAhQiAQRAIAAgATYCGCABEPcBCyAAKAIIIgIEQCACIAAoAgwiA0YEfyACBQNAIANBBGsiAygCACEBIANBADYCACABBEAg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CCICLQAMDQECQAJ/IAIgAigCCCIDKAIAIgRGBEACQCADKAIEIgRFDQAgBC0ADA0ADAMLAkAgASACKAIARgRAIAIhAQwBCyACIAIoAgQiASgCACIANgIEIAEgAAR/IAAgAjYCCCACKAIIBSADCzYCCCACKAIIIgAgACgCACACR0ECdGogATYCACABIAI2AgAgAiABNgIIIAEoAgghAwsgAUEBOgAMIANBADoADCADIAMoAgAiACgCBCIBNgIAIAEEQCABIAM2AggLIAAgAygCCDYCCCADKAIIIgEgASgCACADR0ECdGogADYCACAAIAM2AgQgA0EIagwBCwJAIARFDQAgBC0ADA0ADAILAkAgASACKAIARwRAIAIhAQwBCyACIAEoAgQiADYCACABIAAEfyAAIAI2AgggAigCCAUgAws2AgggAigCCCIAIAAoAgAgAkdBAnRqIAE2AgAgASACNgIEIAIgATYCCCABKAIIIQMLIAFBAToADCADQQA6AAwgAyADKAIEIgAoAgAiATYCBCABBEAgASADNgIICyAAIAMoAgg2AgggAygCCCIBIAEoAgAgA0dBAnRqIAA2AgAgACADNgIAIANBCGoLIAA2AgAMAgsgBEEMaiEBIAJBAToADCADIAAgA0YiAjoADCABQQE6AAAgAyEBIAJFDQALCwuJAQECfyMAQRBrIgMkACAAIAE2AgQgASgCACEEIAEoAgQhASADQQA6AA8gAEEYaiABIARrQQJ1QQNuIANBD2oQRiAAKAIEIgEoAhwhBCABKAIYIQEgA0EAOgAOIABBJGogBCABa0ECdSADQQ5qEEYgACACKQIINwIQIAAgAikCADcCCCADQRBqJAALjwEBAX8gAEHcGTYCACAAKAJYIgEEQCAAIAE2AlwgARD3AQsgACgCSCIBBEAgACABNgJMIAEQ9wELIAAoAjwiAQRAIABBQGsgATYCACABEPcBCyAAKAIwIgEEQCAAIAE2AjQgARD3AQsgAEHwGTYCACAAKAIkIgEEQCABEPcBCyAAKAIYIgEEQCABEPcBCyAAC5QBAQF/IABB3Bk2AgggAEHEGTYCACAAKAJgIgEEQCAAIAE2AmQgARD3AQsgACgCUCIBBEAgACABNgJUIAEQ9wELIAAoAkQiAQRAIAAgATYCSCABEPcBCyAAKAI4IgEEQCAAIAE2Ajwg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AiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL8gICAn8BfgJAIAJFDQAgACACaiIDQQFrIAE6AAAgACABOgAAIAJBA0kNACADQQJrIAE6AAAgACABOgABIANBA2sgAToAACAAIAE6AAIgAkEHSQ0AIANBBGsgAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAAL6QIBAn8CQCAAIAFGDQAgASAAIAJqIgRrQQAgAkEBdGtNBEAgACABIAIQ+QEPCyAAIAFzQQNxIQMCQAJAIAAgAUkEQCADBEAgACEDDAMLIABBA3FFBEAgACEDDAILIAAhAwNAIAJFDQQgAyABLQAAOgAAIAFBAWohASACQQFrIQIgA0EBaiIDQQNxDQALDAELAkAgAw0AIARBA3EEQANAIAJFDQUgACACQQFrIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBBGsiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQQFrIgJqIAEgAmotAAA6AAAgAg0ACwwCCyACQQNNDQADQCADIAEoAgA2AgAgAUEEaiEBIANBBGohAyACQQRrIgJBA0sNAAsLIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQQFrIgINAAsLIAALfwEDfyAAIQECQCAAQQNxBEADQCABLQAARQ0CIAFBAWoiAUEDcQ0ACwsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACyADQf8BcUUEQCACIABrDwsDQCACLQABIQMgAkEBaiIBIQIgAw0ACwsgASAAawsEACMA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";
    }
  });

  // src/neuroglancer/mesh/draco/index.ts
  var draco_exports = {};
  __export(draco_exports, {
    decodeDraco: () => decodeDraco,
    decodeDracoPartitioned: () => decodeDracoPartitioned
  });
  async function decodeDracoPartitioned(buffer, vertexQuantizationBits, partition) {
    const m = await dracoModulePromise;
    const offset = m.instance.exports.malloc(buffer.byteLength);
    const heap = new Uint8Array(m.instance.exports.memory.buffer);
    heap.set(buffer, offset);
    numPartitions = partition ? 8 : 1;
    const code = m.instance.exports.neuroglancer_draco_decode(offset, buffer.byteLength, partition, vertexQuantizationBits, true);
    if (code === 0) {
      const r = decodeResult;
      decodeResult = void 0;
      if (r instanceof Error)
        throw r;
      return r;
    }
    throw new Error(`Failed to decode draco mesh: ${code}`);
  }
  async function decodeDraco(buffer) {
    const m = await dracoModulePromise;
    const offset = m.instance.exports.malloc(buffer.byteLength);
    const heap = new Uint8Array(m.instance.exports.memory.buffer);
    heap.set(buffer, offset);
    const code = m.instance.exports.neuroglancer_draco_decode(offset, buffer.byteLength, false, 0, false);
    if (code === 0) {
      const r = decodeResult;
      decodeResult = void 0;
      if (r instanceof Error)
        throw r;
      r.vertexPositions = new Float32Array(r.vertexPositions.buffer);
      return r;
    }
    throw new Error(`Failed to decode draco mesh: ${code}`);
  }
  var decodeResult, numPartitions, wasmModule, libraryEnv, dracoModulePromise;
  var init_draco = __esm({
    "src/neuroglancer/mesh/draco/index.ts"() {
      init_neuroglancer_draco();
      decodeResult = void 0;
      numPartitions = 0;
      libraryEnv = {
        emscripten_notify_memory_growth: (memoryIndex) => {
          memoryIndex;
        },
        neuroglancer_draco_receive_decoded_mesh: function(numFaces, numVertices, indicesPointer, vertexPositionsPointer, subchunkOffsetsPointer) {
          const numIndices = numFaces * 3;
          const memory = wasmModule.instance.exports.memory;
          const indices = new Uint32Array(memory.buffer, indicesPointer, numIndices).slice();
          const vertexPositions = new Uint32Array(memory.buffer, vertexPositionsPointer, 3 * numVertices).slice();
          const subChunkOffsets = new Uint32Array(memory.buffer, subchunkOffsetsPointer, numPartitions + 1).slice();
          const mesh = {
            indices,
            vertexPositions,
            subChunkOffsets
          };
          decodeResult = mesh;
        },
        proc_exit: (code) => {
          throw `proc exit: ${code}`;
        }
      };
      dracoModulePromise = (async () => {
        const response = await fetch(neuroglancer_draco_default);
        const wasmCode = await response.arrayBuffer();
        const m = wasmModule = await WebAssembly.instantiate(wasmCode, {
          env: libraryEnv,
          wasi_snapshot_preview1: libraryEnv
        });
        m.instance.exports._initialize();
        return m;
      })();
    }
  });

  // node_modules/nifti-reader-js/src/utilities.js
  var require_utilities = __commonJS({
    "node_modules/nifti-reader-js/src/utilities.js"(exports, module) {
      "use strict";
      var nifti = nifti || {};
      nifti.Utils = nifti.Utils || {};
      nifti.Utils.crcTable = null;
      nifti.Utils.GUNZIP_MAGIC_COOKIE1 = 31;
      nifti.Utils.GUNZIP_MAGIC_COOKIE2 = 139;
      nifti.Utils.getStringAt = function(data, start, end) {
        var str6 = "", ctr, ch;
        for (ctr = start; ctr < end; ctr += 1) {
          ch = data.getUint8(ctr);
          if (ch !== 0) {
            str6 += String.fromCharCode(ch);
          }
        }
        return str6;
      };
      nifti.Utils.getByteAt = function(data, start) {
        return data.getInt8(start);
      };
      nifti.Utils.getShortAt = function(data, start, littleEndian) {
        return data.getInt16(start, littleEndian);
      };
      nifti.Utils.getIntAt = function(data, start, littleEndian) {
        return data.getInt32(start, littleEndian);
      };
      nifti.Utils.getFloatAt = function(data, start, littleEndian) {
        return data.getFloat32(start, littleEndian);
      };
      nifti.Utils.getDoubleAt = function(data, start, littleEndian) {
        return data.getFloat64(start, littleEndian);
      };
      nifti.Utils.getLongAt = function(data, start, littleEndian) {
        var ctr, array = [], value = 0;
        for (ctr = 0; ctr < 8; ctr += 1) {
          array[ctr] = nifti.Utils.getByteAt(data, start + ctr, littleEndian);
        }
        for (ctr = array.length - 1; ctr >= 0; ctr--) {
          value = value * 256 + array[ctr];
        }
        return value;
      };
      nifti.Utils.toArrayBuffer = function(buffer) {
        var ab, view, i;
        ab = new ArrayBuffer(buffer.length);
        view = new Uint8Array(ab);
        for (i = 0; i < buffer.length; i += 1) {
          view[i] = buffer[i];
        }
        return ab;
      };
      nifti.Utils.isString = function(obj) {
        return typeof obj === "string" || obj instanceof String;
      };
      nifti.Utils.formatNumber = function(num, shortFormat) {
        var val = 0;
        if (nifti.Utils.isString(num)) {
          val = Number(num);
        } else {
          val = num;
        }
        if (shortFormat) {
          val = val.toPrecision(5);
        } else {
          val = val.toPrecision(7);
        }
        return parseFloat(val);
      };
      nifti.Utils.makeCRCTable = function() {
        var c;
        var crcTable = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          crcTable[n] = c;
        }
        return crcTable;
      };
      nifti.Utils.crc32 = function(dataView) {
        var crcTable = nifti.Utils.crcTable || (nifti.Utils.crcTable = nifti.Utils.makeCRCTable());
        var crc = 0 ^ -1;
        for (var i = 0; i < dataView.byteLength; i++) {
          crc = crc >>> 8 ^ crcTable[(crc ^ dataView.getUint8(i)) & 255];
        }
        return (crc ^ -1) >>> 0;
      };
      var moduleType = typeof module;
      if (moduleType !== "undefined" && module.exports) {
        module.exports = nifti.Utils;
      }
    }
  });

  // node_modules/nifti-reader-js/src/nifti1.js
  var require_nifti1 = __commonJS({
    "node_modules/nifti-reader-js/src/nifti1.js"(exports, module) {
      "use strict";
      var nifti = nifti || {};
      nifti.Utils = nifti.Utils || (typeof __require !== "undefined" ? require_utilities() : null);
      nifti.NIFTI1 = nifti.NIFTI1 || function() {
        this.littleEndian = false;
        this.dim_info = 0;
        this.dims = [];
        this.intent_p1 = 0;
        this.intent_p2 = 0;
        this.intent_p3 = 0;
        this.intent_code = 0;
        this.datatypeCode = 0;
        this.numBitsPerVoxel = 0;
        this.slice_start = 0;
        this.slice_end = 0;
        this.slice_code = 0;
        this.pixDims = [];
        this.vox_offset = 0;
        this.scl_slope = 1;
        this.scl_inter = 0;
        this.xyzt_units = 0;
        this.cal_max = 0;
        this.cal_min = 0;
        this.slice_duration = 0;
        this.toffset = 0;
        this.description = "";
        this.aux_file = "";
        this.intent_name = "";
        this.qform_code = 0;
        this.sform_code = 0;
        this.quatern_b = 0;
        this.quatern_c = 0;
        this.quatern_d = 0;
        this.qoffset_x = 0;
        this.qoffset_y = 0;
        this.qoffset_z = 0;
        this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
        this.magic = 0;
        this.isHDR = false;
        this.extensionFlag = [0, 0, 0, 0];
        this.extensionSize = 0;
        this.extensionCode = 0;
      };
      nifti.NIFTI1.TYPE_NONE = 0;
      nifti.NIFTI1.TYPE_BINARY = 1;
      nifti.NIFTI1.TYPE_UINT8 = 2;
      nifti.NIFTI1.TYPE_INT16 = 4;
      nifti.NIFTI1.TYPE_INT32 = 8;
      nifti.NIFTI1.TYPE_FLOAT32 = 16;
      nifti.NIFTI1.TYPE_COMPLEX64 = 32;
      nifti.NIFTI1.TYPE_FLOAT64 = 64;
      nifti.NIFTI1.TYPE_RGB24 = 128;
      nifti.NIFTI1.TYPE_INT8 = 256;
      nifti.NIFTI1.TYPE_UINT16 = 512;
      nifti.NIFTI1.TYPE_UINT32 = 768;
      nifti.NIFTI1.TYPE_INT64 = 1024;
      nifti.NIFTI1.TYPE_UINT64 = 1280;
      nifti.NIFTI1.TYPE_FLOAT128 = 1536;
      nifti.NIFTI1.TYPE_COMPLEX128 = 1792;
      nifti.NIFTI1.TYPE_COMPLEX256 = 2048;
      nifti.NIFTI1.XFORM_UNKNOWN = 0;
      nifti.NIFTI1.XFORM_SCANNER_ANAT = 1;
      nifti.NIFTI1.XFORM_ALIGNED_ANAT = 2;
      nifti.NIFTI1.XFORM_TALAIRACH = 3;
      nifti.NIFTI1.XFORM_MNI_152 = 4;
      nifti.NIFTI1.SPATIAL_UNITS_MASK = 7;
      nifti.NIFTI1.TEMPORAL_UNITS_MASK = 56;
      nifti.NIFTI1.UNITS_UNKNOWN = 0;
      nifti.NIFTI1.UNITS_METER = 1;
      nifti.NIFTI1.UNITS_MM = 2;
      nifti.NIFTI1.UNITS_MICRON = 3;
      nifti.NIFTI1.UNITS_SEC = 8;
      nifti.NIFTI1.UNITS_MSEC = 16;
      nifti.NIFTI1.UNITS_USEC = 24;
      nifti.NIFTI1.UNITS_HZ = 32;
      nifti.NIFTI1.UNITS_PPM = 40;
      nifti.NIFTI1.UNITS_RADS = 48;
      nifti.NIFTI1.MAGIC_COOKIE = 348;
      nifti.NIFTI1.STANDARD_HEADER_SIZE = 348;
      nifti.NIFTI1.MAGIC_NUMBER_LOCATION = 344;
      nifti.NIFTI1.MAGIC_NUMBER = [110, 43, 49];
      nifti.NIFTI1.MAGIC_NUMBER2 = [110, 105, 49];
      nifti.NIFTI1.EXTENSION_HEADER_SIZE = 8;
      nifti.NIFTI1.prototype.readHeader = function(data) {
        var rawData = new DataView(data), magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian), ctr, ctrOut, ctrIn, index;
        if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {
          this.littleEndian = true;
          magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
        }
        if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {
          throw new Error("This does not appear to be a NIFTI file!");
        }
        this.dim_info = nifti.Utils.getByteAt(rawData, 39);
        for (ctr = 0; ctr < 8; ctr += 1) {
          index = 40 + ctr * 2;
          this.dims[ctr] = nifti.Utils.getShortAt(rawData, index, this.littleEndian);
        }
        this.intent_p1 = nifti.Utils.getFloatAt(rawData, 56, this.littleEndian);
        this.intent_p2 = nifti.Utils.getFloatAt(rawData, 60, this.littleEndian);
        this.intent_p3 = nifti.Utils.getFloatAt(rawData, 64, this.littleEndian);
        this.intent_code = nifti.Utils.getShortAt(rawData, 68, this.littleEndian);
        this.datatypeCode = nifti.Utils.getShortAt(rawData, 70, this.littleEndian);
        this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 72, this.littleEndian);
        this.slice_start = nifti.Utils.getShortAt(rawData, 74, this.littleEndian);
        for (ctr = 0; ctr < 8; ctr += 1) {
          index = 76 + ctr * 4;
          this.pixDims[ctr] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
        }
        this.vox_offset = nifti.Utils.getFloatAt(rawData, 108, this.littleEndian);
        this.scl_slope = nifti.Utils.getFloatAt(rawData, 112, this.littleEndian);
        this.scl_inter = nifti.Utils.getFloatAt(rawData, 116, this.littleEndian);
        this.slice_end = nifti.Utils.getShortAt(rawData, 120, this.littleEndian);
        this.slice_code = nifti.Utils.getByteAt(rawData, 122);
        this.xyzt_units = nifti.Utils.getByteAt(rawData, 123);
        this.cal_max = nifti.Utils.getFloatAt(rawData, 124, this.littleEndian);
        this.cal_min = nifti.Utils.getFloatAt(rawData, 128, this.littleEndian);
        this.slice_duration = nifti.Utils.getFloatAt(rawData, 132, this.littleEndian);
        this.toffset = nifti.Utils.getFloatAt(rawData, 136, this.littleEndian);
        this.description = nifti.Utils.getStringAt(rawData, 148, 228);
        this.aux_file = nifti.Utils.getStringAt(rawData, 228, 252);
        this.qform_code = nifti.Utils.getShortAt(rawData, 252, this.littleEndian);
        this.sform_code = nifti.Utils.getShortAt(rawData, 254, this.littleEndian);
        this.quatern_b = nifti.Utils.getFloatAt(rawData, 256, this.littleEndian);
        this.quatern_c = nifti.Utils.getFloatAt(rawData, 260, this.littleEndian);
        this.quatern_d = nifti.Utils.getFloatAt(rawData, 264, this.littleEndian);
        this.qoffset_x = nifti.Utils.getFloatAt(rawData, 268, this.littleEndian);
        this.qoffset_y = nifti.Utils.getFloatAt(rawData, 272, this.littleEndian);
        this.qoffset_z = nifti.Utils.getFloatAt(rawData, 276, this.littleEndian);
        for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
          for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 280 + (ctrOut * 4 + ctrIn) * 4;
            this.affine[ctrOut][ctrIn] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
          }
        }
        this.affine[3][0] = 0;
        this.affine[3][1] = 0;
        this.affine[3][2] = 0;
        this.affine[3][3] = 1;
        this.intent_name = nifti.Utils.getStringAt(rawData, 328, 344);
        this.magic = nifti.Utils.getStringAt(rawData, 344, 348);
        this.isHDR = this.magic === nifti.NIFTI1.MAGIC_NUMBER2;
        if (rawData.byteLength > nifti.NIFTI1.MAGIC_COOKIE) {
          this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 348);
          this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 348 + 1);
          this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 348 + 2);
          this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 348 + 3);
          if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
          }
        }
      };
      nifti.NIFTI1.prototype.toFormattedString = function() {
        var fmt = nifti.Utils.formatNumber, string = "";
        string += "Dim Info = " + this.dim_info + "\n";
        string += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + "\n";
        string += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + "\n";
        string += "Intent Code = " + this.intent_code + "\n";
        string += "Datatype = " + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n";
        string += "Bits Per Voxel = " + this.numBitsPerVoxel + "\n";
        string += "Slice Start = " + this.slice_start + "\n";
        string += "Voxel Dimensions (1-8): " + fmt(this.pixDims[0]) + ", " + fmt(this.pixDims[1]) + ", " + fmt(this.pixDims[2]) + ", " + fmt(this.pixDims[3]) + ", " + fmt(this.pixDims[4]) + ", " + fmt(this.pixDims[5]) + ", " + fmt(this.pixDims[6]) + ", " + fmt(this.pixDims[7]) + "\n";
        string += "Image Offset = " + this.vox_offset + "\n";
        string += "Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n";
        string += "Slice End = " + this.slice_end + "\n";
        string += "Slice Code = " + this.slice_code + "\n";
        string += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n";
        string += "Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n";
        string += "Slice Duration = " + this.slice_duration + "\n";
        string += "Time Axis Shift = " + this.toffset + "\n";
        string += 'Description: "' + this.description + '"\n';
        string += 'Auxiliary File: "' + this.aux_file + '"\n';
        string += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n";
        string += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n";
        string += "Quaternion Parameters:  b = " + fmt(this.quatern_b) + "  c = " + fmt(this.quatern_c) + "  d = " + fmt(this.quatern_d) + "\n";
        string += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + "\n";
        string += "S-Form Parameters X: " + fmt(this.affine[0][0]) + ", " + fmt(this.affine[0][1]) + ", " + fmt(this.affine[0][2]) + ", " + fmt(this.affine[0][3]) + "\n";
        string += "S-Form Parameters Y: " + fmt(this.affine[1][0]) + ", " + fmt(this.affine[1][1]) + ", " + fmt(this.affine[1][2]) + ", " + fmt(this.affine[1][3]) + "\n";
        string += "S-Form Parameters Z: " + fmt(this.affine[2][0]) + ", " + fmt(this.affine[2][1]) + ", " + fmt(this.affine[2][2]) + ", " + fmt(this.affine[2][3]) + "\n";
        string += 'Intent Name: "' + this.intent_name + '"\n';
        if (this.extensionFlag[0]) {
          string += "Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n";
        }
        return string;
      };
      nifti.NIFTI1.prototype.getDatatypeCodeString = function(code) {
        if (code === nifti.NIFTI1.TYPE_UINT8) {
          return "1-Byte Unsigned Integer";
        } else if (code === nifti.NIFTI1.TYPE_INT16) {
          return "2-Byte Signed Integer";
        } else if (code === nifti.NIFTI1.TYPE_INT32) {
          return "4-Byte Signed Integer";
        } else if (code === nifti.NIFTI1.TYPE_FLOAT32) {
          return "4-Byte Float";
        } else if (code === nifti.NIFTI1.TYPE_FLOAT64) {
          return "8-Byte Float";
        } else if (code === nifti.NIFTI1.TYPE_RGB24) {
          return "RGB";
        } else if (code === nifti.NIFTI1.TYPE_INT8) {
          return "1-Byte Signed Integer";
        } else if (code === nifti.NIFTI1.TYPE_UINT16) {
          return "2-Byte Unsigned Integer";
        } else if (code === nifti.NIFTI1.TYPE_UINT32) {
          return "4-Byte Unsigned Integer";
        } else if (code === nifti.NIFTI1.TYPE_INT64) {
          return "8-Byte Signed Integer";
        } else if (code === nifti.NIFTI1.TYPE_UINT64) {
          return "8-Byte Unsigned Integer";
        } else {
          return "Unknown";
        }
      };
      nifti.NIFTI1.prototype.getTransformCodeString = function(code) {
        if (code === nifti.NIFTI1.XFORM_SCANNER_ANAT) {
          return "Scanner";
        } else if (code === nifti.NIFTI1.XFORM_ALIGNED_ANAT) {
          return "Aligned";
        } else if (code === nifti.NIFTI1.XFORM_TALAIRACH) {
          return "Talairach";
        } else if (code === nifti.NIFTI1.XFORM_MNI_152) {
          return "MNI";
        } else {
          return "Unknown";
        }
      };
      nifti.NIFTI1.prototype.getUnitsCodeString = function(code) {
        if (code === nifti.NIFTI1.UNITS_METER) {
          return "Meters";
        } else if (code === nifti.NIFTI1.UNITS_MM) {
          return "Millimeters";
        } else if (code === nifti.NIFTI1.UNITS_MICRON) {
          return "Microns";
        } else if (code === nifti.NIFTI1.UNITS_SEC) {
          return "Seconds";
        } else if (code === nifti.NIFTI1.UNITS_MSEC) {
          return "Milliseconds";
        } else if (code === nifti.NIFTI1.UNITS_USEC) {
          return "Microseconds";
        } else if (code === nifti.NIFTI1.UNITS_HZ) {
          return "Hz";
        } else if (code === nifti.NIFTI1.UNITS_PPM) {
          return "PPM";
        } else if (code === nifti.NIFTI1.UNITS_RADS) {
          return "Rads";
        } else {
          return "Unknown";
        }
      };
      nifti.NIFTI1.prototype.getQformMat = function() {
        return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x, this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
      };
      nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm = function(qb, qc, qd, qx, qy, qz, dx, dy, dz, qfac) {
        var R = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], a, b = qb, c = qc, d = qd, xd, yd, zd;
        R[3][0] = R[3][1] = R[3][2] = 0;
        R[3][3] = 1;
        a = 1 - (b * b + c * c + d * d);
        if (a < 1e-7) {
          a = 1 / Math.sqrt(b * b + c * c + d * d);
          b *= a;
          c *= a;
          d *= a;
          a = 0;
        } else {
          a = Math.sqrt(a);
        }
        xd = dx > 0 ? dx : 1;
        yd = dy > 0 ? dy : 1;
        zd = dz > 0 ? dz : 1;
        if (qfac < 0) {
          zd = -zd;
        }
        R[0][0] = (a * a + b * b - c * c - d * d) * xd;
        R[0][1] = 2 * (b * c - a * d) * yd;
        R[0][2] = 2 * (b * d + a * c) * zd;
        R[1][0] = 2 * (b * c + a * d) * xd;
        R[1][1] = (a * a + c * c - b * b - d * d) * yd;
        R[1][2] = 2 * (c * d - a * b) * zd;
        R[2][0] = 2 * (b * d - a * c) * xd;
        R[2][1] = 2 * (c * d + a * b) * yd;
        R[2][2] = (a * a + d * d - c * c - b * b) * zd;
        R[0][3] = qx;
        R[1][3] = qy;
        R[2][3] = qz;
        return R;
      };
      nifti.NIFTI1.prototype.convertNiftiSFormToNEMA = function(R) {
        var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest, M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
        k = 0;
        Q = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        P = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        xi = R[0][0];
        xj = R[0][1];
        xk = R[0][2];
        yi = R[1][0];
        yj = R[1][1];
        yk = R[1][2];
        zi = R[2][0];
        zj = R[2][1];
        zk = R[2][2];
        val = Math.sqrt(xi * xi + yi * yi + zi * zi);
        if (val === 0) {
          return null;
        }
        xi /= val;
        yi /= val;
        zi /= val;
        val = Math.sqrt(xj * xj + yj * yj + zj * zj);
        if (val === 0) {
          return null;
        }
        xj /= val;
        yj /= val;
        zj /= val;
        val = xi * xj + yi * yj + zi * zj;
        if (Math.abs(val) > 1e-4) {
          xj -= val * xi;
          yj -= val * yi;
          zj -= val * zi;
          val = Math.sqrt(xj * xj + yj * yj + zj * zj);
          if (val === 0) {
            return null;
          }
          xj /= val;
          yj /= val;
          zj /= val;
        }
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0) {
          xk = yi * zj - zi * yj;
          yk = zi * xj - zj * xi;
          zk = xi * yj - yi * xj;
        } else {
          xk /= val;
          yk /= val;
          zk /= val;
        }
        val = xi * xk + yi * yk + zi * zk;
        if (Math.abs(val) > 1e-4) {
          xk -= val * xi;
          yk -= val * yi;
          zk -= val * zi;
          val = Math.sqrt(xk * xk + yk * yk + zk * zk);
          if (val === 0) {
            return null;
          }
          xk /= val;
          yk /= val;
          zk /= val;
        }
        val = xj * xk + yj * yk + zj * zk;
        if (Math.abs(val) > 1e-4) {
          xk -= val * xj;
          yk -= val * yj;
          zk -= val * zj;
          val = Math.sqrt(xk * xk + yk * yk + zk * zk);
          if (val === 0) {
            return null;
          }
          xk /= val;
          yk /= val;
          zk /= val;
        }
        Q[0][0] = xi;
        Q[0][1] = xj;
        Q[0][2] = xk;
        Q[1][0] = yi;
        Q[1][1] = yj;
        Q[1][2] = yk;
        Q[2][0] = zi;
        Q[2][1] = zj;
        Q[2][2] = zk;
        detQ = this.nifti_mat33_determ(Q);
        if (detQ === 0) {
          return null;
        }
        vbest = -666;
        ibest = pbest = qbest = rbest = 1;
        jbest = 2;
        kbest = 3;
        for (i = 1; i <= 3; i += 1) {
          for (j = 1; j <= 3; j += 1) {
            if (i !== j) {
              for (k = 1; k <= 3; k += 1) {
                if (!(i === k || j === k)) {
                  P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0;
                  for (p = -1; p <= 1; p += 2) {
                    for (q = -1; q <= 1; q += 2) {
                      for (r = -1; r <= 1; r += 2) {
                        P[0][i - 1] = p;
                        P[1][j - 1] = q;
                        P[2][k - 1] = r;
                        detP = this.nifti_mat33_determ(P);
                        if (detP * detQ > 0) {
                          M = this.nifti_mat33_mul(P, Q);
                          val = M[0][0] + M[1][1] + M[2][2];
                          if (val > vbest) {
                            vbest = val;
                            ibest = i;
                            jbest = j;
                            kbest = k;
                            pbest = p;
                            qbest = q;
                            rbest = r;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        iChar = jChar = kChar = iSense = jSense = kSense = 0;
        switch (ibest * pbest) {
          case 1:
            iChar = "X";
            iSense = "+";
            break;
          case -1:
            iChar = "X";
            iSense = "-";
            break;
          case 2:
            iChar = "Y";
            iSense = "+";
            break;
          case -2:
            iChar = "Y";
            iSense = "-";
            break;
          case 3:
            iChar = "Z";
            iSense = "+";
            break;
          case -3:
            iChar = "Z";
            iSense = "-";
            break;
        }
        switch (jbest * qbest) {
          case 1:
            jChar = "X";
            jSense = "+";
            break;
          case -1:
            jChar = "X";
            jSense = "-";
            break;
          case 2:
            jChar = "Y";
            jSense = "+";
            break;
          case -2:
            jChar = "Y";
            jSense = "-";
            break;
          case 3:
            jChar = "Z";
            jSense = "+";
            break;
          case -3:
            jChar = "Z";
            jSense = "-";
            break;
        }
        switch (kbest * rbest) {
          case 1:
            kChar = "X";
            kSense = "+";
            break;
          case -1:
            kChar = "X";
            kSense = "-";
            break;
          case 2:
            kChar = "Y";
            kSense = "+";
            break;
          case -2:
            kChar = "Y";
            kSense = "-";
            break;
          case 3:
            kChar = "Z";
            kSense = "+";
            break;
          case -3:
            kChar = "Z";
            kSense = "-";
            break;
        }
        return iChar + jChar + kChar + iSense + jSense + kSense;
      };
      nifti.NIFTI1.prototype.nifti_mat33_mul = function(A, B) {
        var C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], i, j;
        for (i = 0; i < 3; i += 1) {
          for (j = 0; j < 3; j += 1) {
            C[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j];
          }
        }
        return C;
      };
      nifti.NIFTI1.prototype.nifti_mat33_determ = function(R) {
        var r11, r12, r13, r21, r22, r23, r31, r32, r33;
        r11 = R[0][0];
        r12 = R[0][1];
        r13 = R[0][2];
        r21 = R[1][0];
        r22 = R[1][1];
        r23 = R[1][2];
        r31 = R[2][0];
        r32 = R[2][1];
        r33 = R[2][2];
        return r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13;
      };
      nifti.NIFTI1.prototype.getExtensionLocation = function() {
        return nifti.NIFTI1.MAGIC_COOKIE + 4;
      };
      nifti.NIFTI1.prototype.getExtensionSize = function(data) {
        return nifti.Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
      };
      nifti.NIFTI1.prototype.getExtensionCode = function(data) {
        return nifti.Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
      };
      var moduleType = typeof module;
      if (moduleType !== "undefined" && module.exports) {
        module.exports = nifti.NIFTI1;
      }
    }
  });

  // node_modules/nifti-reader-js/src/nifti2.js
  var require_nifti2 = __commonJS({
    "node_modules/nifti-reader-js/src/nifti2.js"(exports, module) {
      "use strict";
      var nifti = nifti || {};
      nifti.Utils = nifti.Utils || (typeof __require !== "undefined" ? require_utilities() : null);
      nifti.NIFTI1 = nifti.NIFTI1 || (typeof __require !== "undefined" ? require_nifti1() : null);
      nifti.NIFTI2 = nifti.NIFTI2 || function() {
        this.littleEndian = false;
        this.dim_info = 0;
        this.dims = [];
        this.intent_p1 = 0;
        this.intent_p2 = 0;
        this.intent_p3 = 0;
        this.intent_code = 0;
        this.datatypeCode = 0;
        this.numBitsPerVoxel = 0;
        this.slice_start = 0;
        this.slice_end = 0;
        this.slice_code = 0;
        this.pixDims = [];
        this.vox_offset = 0;
        this.scl_slope = 1;
        this.scl_inter = 0;
        this.xyzt_units = 0;
        this.cal_max = 0;
        this.cal_min = 0;
        this.slice_duration = 0;
        this.toffset = 0;
        this.description = "";
        this.aux_file = "";
        this.intent_name = "";
        this.qform_code = 0;
        this.sform_code = 0;
        this.quatern_b = 0;
        this.quatern_c = 0;
        this.quatern_d = 0;
        this.qoffset_x = 0;
        this.qoffset_y = 0;
        this.qoffset_z = 0;
        this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
        this.magic = 0;
        this.extensionFlag = [0, 0, 0, 0];
      };
      nifti.NIFTI2.MAGIC_COOKIE = 540;
      nifti.NIFTI2.MAGIC_NUMBER_LOCATION = 4;
      nifti.NIFTI2.MAGIC_NUMBER = [110, 43, 50, 0, 13, 10, 26, 10];
      nifti.NIFTI2.prototype.readHeader = function(data) {
        var rawData = new DataView(data), magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian), ctr, ctrOut, ctrIn, index, array;
        if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {
          this.littleEndian = true;
          magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
        }
        if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {
          throw new Error("This does not appear to be a NIFTI file!");
        }
        this.datatypeCode = nifti.Utils.getShortAt(rawData, 12, this.littleEndian);
        this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 14, this.littleEndian);
        for (ctr = 0; ctr < 8; ctr += 1) {
          index = 16 + ctr * 8;
          this.dims[ctr] = nifti.Utils.getLongAt(rawData, index, this.littleEndian);
        }
        this.intent_p1 = nifti.Utils.getDoubleAt(rawData, 80, this.littleEndian);
        this.intent_p2 = nifti.Utils.getDoubleAt(rawData, 88, this.littleEndian);
        this.intent_p3 = nifti.Utils.getDoubleAt(rawData, 96, this.littleEndian);
        for (ctr = 0; ctr < 8; ctr += 1) {
          index = 104 + ctr * 8;
          this.pixDims[ctr] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
        }
        this.vox_offset = nifti.Utils.getLongAt(rawData, 168, this.littleEndian);
        this.scl_slope = nifti.Utils.getDoubleAt(rawData, 176, this.littleEndian);
        this.scl_inter = nifti.Utils.getDoubleAt(rawData, 184, this.littleEndian);
        this.cal_max = nifti.Utils.getDoubleAt(rawData, 192, this.littleEndian);
        this.cal_min = nifti.Utils.getDoubleAt(rawData, 200, this.littleEndian);
        this.slice_duration = nifti.Utils.getDoubleAt(rawData, 208, this.littleEndian);
        this.toffset = nifti.Utils.getDoubleAt(rawData, 216, this.littleEndian);
        this.slice_start = nifti.Utils.getLongAt(rawData, 224, this.littleEndian);
        this.slice_end = nifti.Utils.getLongAt(rawData, 232, this.littleEndian);
        this.description = nifti.Utils.getStringAt(rawData, 240, 240 + 80);
        this.aux_file = nifti.Utils.getStringAt(rawData, 320, 320 + 24);
        this.qform_code = nifti.Utils.getIntAt(rawData, 344, this.littleEndian);
        this.sform_code = nifti.Utils.getIntAt(rawData, 348, this.littleEndian);
        this.quatern_b = nifti.Utils.getDoubleAt(rawData, 352, this.littleEndian);
        this.quatern_c = nifti.Utils.getDoubleAt(rawData, 360, this.littleEndian);
        this.quatern_d = nifti.Utils.getDoubleAt(rawData, 368, this.littleEndian);
        this.qoffset_x = nifti.Utils.getDoubleAt(rawData, 376, this.littleEndian);
        this.qoffset_y = nifti.Utils.getDoubleAt(rawData, 384, this.littleEndian);
        this.qoffset_z = nifti.Utils.getDoubleAt(rawData, 392, this.littleEndian);
        for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
          for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 400 + (ctrOut * 4 + ctrIn) * 8;
            this.affine[ctrOut][ctrIn] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
          }
        }
        this.affine[3][0] = 0;
        this.affine[3][1] = 0;
        this.affine[3][2] = 0;
        this.affine[3][3] = 1;
        this.slice_code = nifti.Utils.getIntAt(rawData, 496, this.littleEndian);
        this.xyzt_units = nifti.Utils.getIntAt(rawData, 500, this.littleEndian);
        this.intent_code = nifti.Utils.getIntAt(rawData, 504, this.littleEndian);
        this.intent_name = nifti.Utils.getStringAt(rawData, 508, 508 + 16);
        this.dim_info = nifti.Utils.getByteAt(rawData, 524);
        if (rawData.byteLength > nifti.NIFTI2.MAGIC_COOKIE) {
          this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 540);
          this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 540 + 1);
          this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 540 + 2);
          this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 540 + 3);
          if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
          }
        }
      };
      nifti.NIFTI2.prototype.toFormattedString = function() {
        var fmt = nifti.Utils.formatNumber, string = "";
        string += "Datatype = " + +this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n";
        string += "Bits Per Voxel =  = " + this.numBitsPerVoxel + "\n";
        string += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + "\n";
        string += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + "\n";
        string += "Voxel Dimensions (1-8): " + fmt(this.pixDims[0]) + ", " + fmt(this.pixDims[1]) + ", " + fmt(this.pixDims[2]) + ", " + fmt(this.pixDims[3]) + ", " + fmt(this.pixDims[4]) + ", " + fmt(this.pixDims[5]) + ", " + fmt(this.pixDims[6]) + ", " + fmt(this.pixDims[7]) + "\n";
        string += "Image Offset = " + this.vox_offset + "\n";
        string += "Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n";
        string += "Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n";
        string += "Slice Duration = " + this.slice_duration + "\n";
        string += "Time Axis Shift = " + this.toffset + "\n";
        string += "Slice Start = " + this.slice_start + "\n";
        string += "Slice End = " + this.slice_end + "\n";
        string += 'Description: "' + this.description + '"\n';
        string += 'Auxiliary File: "' + this.aux_file + '"\n';
        string += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n";
        string += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n";
        string += "Quaternion Parameters:  b = " + fmt(this.quatern_b) + "  c = " + fmt(this.quatern_c) + "  d = " + fmt(this.quatern_d) + "\n";
        string += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + "\n";
        string += "S-Form Parameters X: " + fmt(this.affine[0][0]) + ", " + fmt(this.affine[0][1]) + ", " + fmt(this.affine[0][2]) + ", " + fmt(this.affine[0][3]) + "\n";
        string += "S-Form Parameters Y: " + fmt(this.affine[1][0]) + ", " + fmt(this.affine[1][1]) + ", " + fmt(this.affine[1][2]) + ", " + fmt(this.affine[1][3]) + "\n";
        string += "S-Form Parameters Z: " + fmt(this.affine[2][0]) + ", " + fmt(this.affine[2][1]) + ", " + fmt(this.affine[2][2]) + ", " + fmt(this.affine[2][3]) + "\n";
        string += "Slice Code = " + this.slice_code + "\n";
        string += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n";
        string += "Intent Code = " + this.intent_code + "\n";
        string += 'Intent Name: "' + this.intent_name + '"\n';
        string += "Dim Info = " + this.dim_info + "\n";
        return string;
      };
      nifti.NIFTI2.prototype.getExtensionLocation = function() {
        return nifti.NIFTI2.MAGIC_COOKIE + 4;
      };
      nifti.NIFTI2.prototype.getExtensionSize = nifti.NIFTI1.prototype.getExtensionSize;
      nifti.NIFTI2.prototype.getExtensionCode = nifti.NIFTI1.prototype.getExtensionCode;
      nifti.NIFTI2.prototype.getDatatypeCodeString = nifti.NIFTI1.prototype.getDatatypeCodeString;
      nifti.NIFTI2.prototype.getTransformCodeString = nifti.NIFTI1.prototype.getTransformCodeString;
      nifti.NIFTI2.prototype.getUnitsCodeString = nifti.NIFTI1.prototype.getUnitsCodeString;
      nifti.NIFTI2.prototype.getQformMat = nifti.NIFTI1.prototype.getQformMat;
      nifti.NIFTI2.prototype.convertNiftiQFormToNiftiSForm = nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm;
      nifti.NIFTI2.prototype.convertNiftiSFormToNEMA = nifti.NIFTI1.prototype.convertNiftiSFormToNEMA;
      nifti.NIFTI2.prototype.nifti_mat33_mul = nifti.NIFTI1.prototype.nifti_mat33_mul;
      nifti.NIFTI2.prototype.nifti_mat33_determ = nifti.NIFTI1.prototype.nifti_mat33_determ;
      var moduleType = typeof module;
      if (moduleType !== "undefined" && module.exports) {
        module.exports = nifti.NIFTI2;
      }
    }
  });

  // node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/pako/lib/zlib/trees.js"(exports, module) {
      "use strict";
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero3(buf) {
        let len4 = buf.length;
        while (--len4 >= 0) {
          buf[len4] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
      var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
      var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
      var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero3(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero3(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero3(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero3(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero3(base_length);
      var base_dist = new Array(D_CODES);
      zero3(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      var d_code = (dist3) => {
        return dist3 < 256 ? _dist_code[dist3] : _dist_code[256 + (dist3 >>> 7)];
      };
      var put_short = (s, w) => {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      };
      var send_bits = (s, value, length4) => {
        if (s.bi_valid > Buf_size - length4) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length4 - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length4;
        }
      };
      var send_code = (s, c, tree) => {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
      };
      var bi_reverse = (code, len4) => {
        let res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len4 > 0);
        return res >>> 1;
      };
      var bi_flush = (s) => {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      };
      var gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      };
      var gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS + 1);
        let code = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          let len4 = tree[n * 2 + 1];
          if (len4 === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len4]++, len4);
        }
      };
      var tr_static_init = () => {
        let n;
        let bits;
        let length4;
        let code;
        let dist3;
        const bl_count = new Array(MAX_BITS + 1);
        length4 = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length4;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length4++] = code;
          }
        }
        _length_code[length4 - 1] = code;
        dist3 = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist3;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist3++] = code;
          }
        }
        dist3 >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist3 << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist3++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      };
      var init_block = (s) => {
        let n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      };
      var bi_windup = (s) => {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      };
      var copy_block = (s, buf, len4, header) => {
        bi_windup(s);
        if (header) {
          put_short(s, len4);
          put_short(s, ~len4);
        }
        s.pending_buf.set(s.window.subarray(buf, buf + len4), s.pending);
        s.pending += len4;
      };
      var smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      };
      var pqdownheap = (s, tree, k) => {
        const v = s.heap[k];
        let j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      };
      var compress_block = (s, ltree, dtree) => {
        let dist3;
        let lc;
        let lx = 0;
        let code;
        let extra;
        if (s.last_lit !== 0) {
          do {
            dist3 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist3 === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist3--;
              code = d_code(dist3);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist3 -= base_dist[code];
                send_bits(s, dist3, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      };
      var build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      };
      var scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var build_bl_tree = (s) => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      };
      var send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      };
      var detect_data_type = (s) => {
        let black_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      };
      var static_init_done = false;
      var _tr_init = (s) => {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      };
      var _tr_stored_block = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      };
      var _tr_align = (s) => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      };
      var _tr_flush_block = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      };
      var _tr_tally = (s, dist3, lc) => {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist3 >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist3 & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist3 === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist3--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist3) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      };
      module.exports._tr_init = _tr_init;
      module.exports._tr_stored_block = _tr_stored_block;
      module.exports._tr_flush_block = _tr_flush_block;
      module.exports._tr_tally = _tr_tally;
      module.exports._tr_align = _tr_align;
    }
  });

  // node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      var adler32 = (adler, buf, len4, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len4 !== 0) {
          n = len4 > 2e3 ? 2e3 : len4;
          len4 -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      };
      module.exports = adler32;
    }
  });

  // node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      var makeTable = () => {
        let c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      };
      var crcTable = new Uint32Array(makeTable());
      var crc32 = (crc, buf, len4, pos) => {
        const t = crcTable;
        const end = pos + len4;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      };
      module.exports = crc32;
    }
  });

  // node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      };
    }
  });

  // node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      };
    }
  });

  // node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
      "use strict";
      var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var {
        Z_NO_FLUSH,
        Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_BLOCK,
        Z_OK,
        Z_STREAM_END,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_BUF_ERROR,
        Z_DEFAULT_COMPRESSION,
        Z_FILTERED,
        Z_HUFFMAN_ONLY,
        Z_RLE,
        Z_FIXED,
        Z_DEFAULT_STRATEGY,
        Z_UNKNOWN,
        Z_DEFLATED
      } = require_constants();
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      var err = (strm, errorCode) => {
        strm.msg = msg[errorCode];
        return errorCode;
      };
      var rank = (f) => {
        return (f << 1) - (f > 4 ? 9 : 0);
      };
      var zero3 = (buf) => {
        let len4 = buf.length;
        while (--len4 >= 0) {
          buf[len4] = 0;
        }
      };
      var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
      var HASH = HASH_ZLIB;
      var flush_pending = (strm) => {
        const s = strm.state;
        let len4 = s.pending;
        if (len4 > strm.avail_out) {
          len4 = strm.avail_out;
        }
        if (len4 === 0) {
          return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len4), strm.next_out);
        strm.next_out += len4;
        s.pending_out += len4;
        strm.total_out += len4;
        strm.avail_out -= len4;
        s.pending -= len4;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      };
      var flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      };
      var put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
      };
      var putShortMSB = (s, b) => {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      };
      var read_buf = (strm, buf, start, size) => {
        let len4 = strm.avail_in;
        if (len4 > size) {
          len4 = size;
        }
        if (len4 === 0) {
          return 0;
        }
        strm.avail_in -= len4;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len4), start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len4, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len4, start);
        }
        strm.next_in += len4;
        strm.total_in += len4;
        return len4;
      };
      var longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len4;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len4 = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len4 > best_len) {
            s.match_start = cur_match;
            best_len = len4;
            if (len4 >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      };
      var fill_window = (s) => {
        const _w_size = s.w_size;
        let p, n, m, more, str6;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str6 = s.strstart - s.insert;
            s.ins_h = s.window[str6];
            s.ins_h = HASH(s, s.ins_h, s.window[str6 + 1]);
            while (s.insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[str6 + MIN_MATCH - 1]);
              s.prev[str6 & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str6;
              str6++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      };
      var deflate_stored = (s, flush) => {
        let max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          const max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      };
      var deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_huff = (s, flush) => {
        let bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
      ];
      var lm_init = (s) => {
        s.window_size = 2 * s.w_size;
        zero3(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      };
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero3(this.dyn_ltree);
        zero3(this.dyn_dtree);
        zero3(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero3(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero3(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      var deflateResetKeep = (strm) => {
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        _tr_init(s);
        return Z_OK;
      };
      var deflateReset = (strm) => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      };
      var deflateSetHeader = (strm, head) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      };
      var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        const s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      };
      var deflateInit = (strm, level) => {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      };
      var deflate = (strm, flush) => {
        let beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        const s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              _tr_align(s);
            } else if (flush !== Z_BLOCK) {
              _tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero3(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      };
      var deflateEnd = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      };
      var deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero3(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          let tmpDict = new Uint8Array(s.w_size);
          tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          let str6 = s.strstart;
          let n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = HASH(s, s.ins_h, s.window[str6 + MIN_MATCH - 1]);
            s.prev[str6 & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str6;
            str6++;
          } while (--n);
          s.strstart = str6;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      };
      module.exports.deflateInit = deflateInit;
      module.exports.deflateInit2 = deflateInit2;
      module.exports.deflateReset = deflateReset;
      module.exports.deflateResetKeep = deflateResetKeep;
      module.exports.deflateSetHeader = deflateSetHeader;
      module.exports.deflate = deflate;
      module.exports.deflateEnd = deflateEnd;
      module.exports.deflateSetDictionary = deflateSetDictionary;
      module.exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/pako/lib/utils/common.js"(exports, module) {
      "use strict";
      var _has = (obj, key) => {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      module.exports.assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          const source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (const p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      module.exports.flattenChunks = (chunks) => {
        let len4 = 0;
        for (let i = 0, l = chunks.length; i < l; i++) {
          len4 += chunks[i].length;
        }
        const result = new Uint8Array(len4);
        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
          let chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      };
    }
  });

  // node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/pako/lib/utils/strings.js"(exports, module) {
      "use strict";
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new Uint8Array(256);
      for (let q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      module.exports.string2buf = (str6) => {
        let buf, c, c2, m_pos, i, str_len = str6.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str6.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str6.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str6.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str6.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      var buf2binstring = (buf, len4) => {
        if (len4 < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len4 ? buf : buf.subarray(0, len4));
          }
        }
        let result = "";
        for (let i = 0; i < len4; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      };
      module.exports.buf2string = (buf, max4) => {
        let i, out;
        const len4 = max4 || buf.length;
        const utf16buf = new Array(len4 * 2);
        for (out = 0, i = 0; i < len4; ) {
          let c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          let c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len4) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      module.exports.utf8border = (buf, max4) => {
        max4 = max4 || buf.length;
        if (max4 > buf.length) {
          max4 = buf.length;
        }
        let pos = max4 - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max4;
        }
        if (pos === 0) {
          return max4;
        }
        return pos + _utf8len[buf[pos]] > max4 ? pos : max4;
      };
    }
  });

  // node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/pako/lib/deflate.js"(exports, module) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_SYNC_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED
      } = require_constants();
      function Deflate(options) {
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          let dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
          return false;
        }
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          status = zlib_deflate.deflate(strm, _flush_mode);
          if (status === Z_STREAM_END) {
            if (strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
          }
          if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          this.result = utils.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        const deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.constants = require_constants();
    }
  });

  // node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len4;
        let dist3;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len4 = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len4 += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist3 = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist3 += hold & (1 << op) - 1;
                        if (dist3 > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist3 > op) {
                          op = dist3 - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len4) {
                              len4 -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist3;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len4) {
                              len4 -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len4) {
                                op = wnext;
                                len4 -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist3;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len4) {
                              len4 -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist3;
                              from_source = output;
                            }
                          }
                          while (len4 > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len4 -= 3;
                          }
                          if (len4) {
                            output[_out++] = from_source[from++];
                            if (len4 > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist3;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len4 -= 3;
                          } while (len4 > 2);
                          if (len4) {
                            output[_out++] = output[from++];
                            if (len4 > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len4 = bits >> 3;
        _in -= len4;
        bits -= len4 << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = new Uint16Array([
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ]);
      var lext = new Uint8Array([
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ]);
      var dbase = new Uint16Array([
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ]);
      var dext = new Uint8Array([
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ]);
      var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len4 = 0;
        let sym = 0;
        let min4 = 0, max4 = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let base_index = 0;
        let end;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let extra_index = 0;
        let here_bits, here_op, here_val;
        for (len4 = 0; len4 <= MAXBITS; len4++) {
          count[len4] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max4 = MAXBITS; max4 >= 1; max4--) {
          if (count[max4] !== 0) {
            break;
          }
        }
        if (root > max4) {
          root = max4;
        }
        if (max4 === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min4 = 1; min4 < max4; min4++) {
          if (count[min4] !== 0) {
            break;
          }
        }
        if (root < min4) {
          root = min4;
        }
        left = 1;
        for (len4 = 1; len4 <= MAXBITS; len4++) {
          left <<= 1;
          left -= count[len4];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max4 !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len4 = 1; len4 < MAXBITS; len4++) {
          offs[len4 + 1] = offs[len4] + count[len4];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len4 = min4;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len4 - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len4 - drop;
          fill = 1 << curr;
          min4 = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len4 - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len4] === 0) {
            if (len4 === max4) {
              break;
            }
            len4 = lens[lens_index + work[sym]];
          }
          if (len4 > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min4;
            curr = len4 - drop;
            left = 1 << curr;
            while (curr + drop < max4) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len4 - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
      module.exports = inflate_table;
    }
  });

  // node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
      "use strict";
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var {
        Z_FINISH,
        Z_BLOCK,
        Z_TREES,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR,
        Z_BUF_ERROR,
        Z_DEFLATED
      } = require_constants();
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      var zswap32 = (q) => {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      };
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      var inflateResetKeep = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      };
      var inflateReset = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      };
      var inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      };
      var inflateInit2 = (strm, windowBits) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        const state = new InflateState();
        strm.state = state;
        state.window = null;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      };
      var inflateInit = (strm) => {
        return inflateInit2(strm, DEF_WBITS);
      };
      var virgin = true;
      var lenfix;
      var distfix;
      var fixedtables = (state) => {
        if (virgin) {
          lenfix = new Int32Array(512);
          distfix = new Int32Array(32);
          let sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      };
      var updatewindow = (strm, src, end, copy7) => {
        let dist3;
        const state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new Uint8Array(state.wsize);
        }
        if (copy7 >= state.wsize) {
          state.window.set(src.subarray(end - state.wsize, end), 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist3 = state.wsize - state.wnext;
          if (dist3 > copy7) {
            dist3 = copy7;
          }
          state.window.set(src.subarray(end - copy7, end - copy7 + dist3), state.wnext);
          copy7 -= dist3;
          if (copy7) {
            state.window.set(src.subarray(end - copy7, end), 0);
            state.wnext = copy7;
            state.whave = state.wsize;
          } else {
            state.wnext += dist3;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist3;
            }
          }
        }
        return 0;
      };
      var inflate = (strm, flush) => {
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy7;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len4;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len4 = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len4;
                } else if (len4 > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << state.wbits;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy7 = state.length;
                  if (copy7 > have) {
                    copy7 = have;
                  }
                  if (copy7) {
                    if (state.head) {
                      len4 = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Uint8Array(state.head.extra_len);
                      }
                      state.head.extra.set(input.subarray(next, next + copy7), len4);
                    }
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy7, next);
                    }
                    have -= copy7;
                    next += copy7;
                    state.length -= copy7;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy7 = 0;
                  do {
                    len4 = input[next + copy7++];
                    if (state.head && len4 && state.length < 65536) {
                      state.head.name += String.fromCharCode(len4);
                    }
                  } while (len4 && copy7 < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy7, next);
                  }
                  have -= copy7;
                  next += copy7;
                  if (len4) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy7 = 0;
                  do {
                    len4 = input[next + copy7++];
                    if (state.head && len4 && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len4);
                    }
                  } while (len4 && copy7 < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy7, next);
                  }
                  have -= copy7;
                  next += copy7;
                  if (len4) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy7 = state.length;
                if (copy7) {
                  if (copy7 > have) {
                    copy7 = have;
                  }
                  if (copy7 > left) {
                    copy7 = left;
                  }
                  if (copy7 === 0) {
                    break inf_leave;
                  }
                  output.set(input.subarray(next, next + copy7), put);
                  have -= copy7;
                  next += copy7;
                  left -= copy7;
                  put += copy7;
                  state.length -= copy7;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len4 = state.lens[state.have - 1];
                      copy7 = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len4 = 0;
                      copy7 = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len4 = 0;
                      copy7 = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy7 > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy7--) {
                      state.lens[state.have++] = len4;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy7 = _out - left;
                if (state.offset > copy7) {
                  copy7 = state.offset - copy7;
                  if (copy7 > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy7 > state.wnext) {
                    copy7 -= state.wnext;
                    from = state.wsize - copy7;
                  } else {
                    from = state.wnext - copy7;
                  }
                  if (copy7 > state.length) {
                    copy7 = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy7 = state.length;
                }
                if (copy7 > left) {
                  copy7 = left;
                }
                left -= copy7;
                state.length -= copy7;
                do {
                  output[put++] = from_source[from++];
                } while (--copy7);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      };
      var inflateEnd = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        let state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      };
      var inflateGetHeader = (strm, head) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      };
      var inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      };
      module.exports.inflateReset = inflateReset;
      module.exports.inflateReset2 = inflateReset2;
      module.exports.inflateResetKeep = inflateResetKeep;
      module.exports.inflateInit = inflateInit;
      module.exports.inflateInit2 = inflateInit2;
      module.exports.inflate = inflate;
      module.exports.inflateEnd = inflateEnd;
      module.exports.inflateGetHeader = inflateGetHeader;
      module.exports.inflateSetDictionary = inflateSetDictionary;
      module.exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/pako/lib/inflate.js"(exports, module) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR
      } = require_constants();
      function Inflate(options) {
        this.options = utils.assign({
          chunkSize: 1024 * 64,
          windowBits: 15,
          to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended)
          return false;
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, _flush_mode);
          if (status === Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
              status = zlib_inflate.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
              status = Z_NEED_DICT;
            }
          }
          while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
            zlib_inflate.inflateReset(strm);
            status = zlib_inflate.inflate(strm, _flush_mode);
          }
          switch (status) {
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
              this.onEnd(status);
              this.ended = true;
              return false;
          }
          last_avail_out = strm.avail_out;
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
              if (this.options.to === "string") {
                let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                let tail = strm.next_out - next_out_utf8;
                let utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail)
                  strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                this.onData(utf8str);
              } else {
                this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
              }
            }
          }
          if (status === Z_OK && last_avail_out === 0)
            continue;
          if (status === Z_STREAM_END) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        const inflator = new Inflate(options);
        inflator.push(input);
        if (inflator.err)
          throw inflator.msg || msg[inflator.err];
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = inflate;
      module.exports.constants = require_constants();
    }
  });

  // node_modules/pako/index.js
  var require_pako = __commonJS({
    "node_modules/pako/index.js"(exports, module) {
      "use strict";
      var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
      var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
      var constants = require_constants();
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = ungzip;
      module.exports.constants = constants;
    }
  });

  // node_modules/nifti-reader-js/src/nifti.js
  var require_nifti = __commonJS({
    "node_modules/nifti-reader-js/src/nifti.js"(exports, module) {
      "use strict";
      var nifti = nifti || {};
      nifti.NIFTI1 = nifti.NIFTI1 || (typeof __require !== "undefined" ? require_nifti1() : null);
      nifti.NIFTI2 = nifti.NIFTI2 || (typeof __require !== "undefined" ? require_nifti2() : null);
      nifti.Utils = nifti.Utils || (typeof __require !== "undefined" ? require_utilities() : null);
      var pako = pako || (typeof __require !== "undefined" ? require_pako() : null);
      nifti.isNIFTI1 = function(data) {
        var buf, mag1, mag2, mag3;
        if (data.byteLength < nifti.NIFTI1.STANDARD_HEADER_SIZE) {
          return false;
        }
        buf = new DataView(data);
        if (buf)
          mag1 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION);
        mag2 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 1);
        mag3 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 2);
        return !!(mag1 === nifti.NIFTI1.MAGIC_NUMBER[0] && mag2 === nifti.NIFTI1.MAGIC_NUMBER[1] && mag3 === nifti.NIFTI1.MAGIC_NUMBER[2]);
      };
      nifti.isNIFTI2 = function(data) {
        var buf, mag1, mag2, mag3;
        if (data.byteLength < nifti.NIFTI1.STANDARD_HEADER_SIZE) {
          return false;
        }
        buf = new DataView(data);
        mag1 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION);
        mag2 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 1);
        mag3 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 2);
        return !!(mag1 === nifti.NIFTI2.MAGIC_NUMBER[0] && mag2 === nifti.NIFTI2.MAGIC_NUMBER[1] && mag3 === nifti.NIFTI2.MAGIC_NUMBER[2]);
      };
      nifti.isNIFTI = function(data) {
        return nifti.isNIFTI1(data) || nifti.isNIFTI2(data);
      };
      nifti.isCompressed = function(data) {
        var buf, magicCookie1, magicCookie2;
        if (data) {
          buf = new DataView(data);
          magicCookie1 = buf.getUint8(0);
          magicCookie2 = buf.getUint8(1);
          if (magicCookie1 === nifti.Utils.GUNZIP_MAGIC_COOKIE1) {
            return true;
          }
          if (magicCookie2 === nifti.Utils.GUNZIP_MAGIC_COOKIE2) {
            return true;
          }
        }
        return false;
      };
      nifti.decompress = function(data) {
        return pako.inflate(data).buffer;
      };
      nifti.readHeader = function(data) {
        var header = null;
        if (nifti.isCompressed(data)) {
          data = nifti.decompress(data);
        }
        if (nifti.isNIFTI1(data)) {
          header = new nifti.NIFTI1();
        } else if (nifti.isNIFTI2(data)) {
          header = new nifti.NIFTI2();
        }
        if (header) {
          header.readHeader(data);
        } else {
          console.error("That file does not appear to be NIFTI!");
        }
        return header;
      };
      nifti.hasExtension = function(header) {
        return header.extensionFlag[0] != 0;
      };
      nifti.readImage = function(header, data) {
        var imageOffset = header.vox_offset, timeDim = 1, statDim = 1;
        if (header.dims[4]) {
          timeDim = header.dims[4];
        }
        if (header.dims[5]) {
          statDim = header.dims[5];
        }
        var imageSize = header.dims[1] * header.dims[2] * header.dims[3] * timeDim * statDim * (header.numBitsPerVoxel / 8);
        return data.slice(imageOffset, imageOffset + imageSize);
      };
      nifti.readExtension = function(header, data) {
        var loc = header.getExtensionLocation(), size = header.extensionSize;
        return data.slice(loc, loc + size);
      };
      nifti.readExtensionData = function(header, data) {
        var loc = header.getExtensionLocation(), size = header.extensionSize;
        return data.slice(loc + 8, loc + size - 8);
      };
      var moduleType = typeof module;
      if (moduleType !== "undefined" && module.exports) {
        module.exports = nifti;
      }
    }
  });

  // src/neuroglancer/util/cancellation.ts
  var CancellationError = class {
    constructor() {
      this.name = "CancellationError";
      this.message = "CANCELED";
    }
    toString() {
      return "CANCELED";
    }
  };
  var CANCELED = new CancellationError();
  function throwIfCanceled(token) {
    if (token.isCanceled === true) {
      throw CANCELED;
    }
  }
  var noopFunction = () => {
  };
  var uncancelableToken = {
    isCanceled: false,
    add: () => noopFunction,
    remove: noopFunction
  };
  var CancellationTokenSource = class {
    cancel() {
      const { handlers: handlers2 } = this;
      if (handlers2 !== null) {
        this.handlers = null;
        if (handlers2 !== void 0) {
          for (let handler of handlers2) {
            handler();
          }
        }
      }
    }
    get isCanceled() {
      return this.handlers === null;
    }
    add(handler) {
      let { handlers: handlers2 } = this;
      if (handlers2 === null) {
        handler();
        return noopFunction;
      }
      if (handlers2 === void 0) {
        handlers2 = this.handlers = new Set();
      }
      handlers2.add(handler);
      return () => {
        this.remove(handler);
      };
    }
    remove(handler) {
      const { handlers: handlers2 } = this;
      if (handlers2 != null) {
        handlers2.delete(handler);
      }
    }
  };
  var MultipleConsumerCancellationTokenSource = class extends CancellationTokenSource {
    constructor() {
      super(...arguments);
      this.consumers = new Set();
    }
    addConsumer(cancellationToken = uncancelableToken) {
      const { consumers } = this;
      if (consumers.has(cancellationToken) || cancellationToken.isCanceled) {
        return;
      }
      consumers.add(cancellationToken);
      cancellationToken.add(() => {
        consumers.delete(cancellationToken);
        if (consumers.size === 0) {
          this.cancel();
        }
      });
    }
  };
  function makeCancelablePromise(cancellationToken, executor) {
    return new Promise((resolve, reject) => {
      if (cancellationToken === uncancelableToken) {
        executor(resolve, reject, uncancelableToken);
        return;
      }
      const scopedToken = new CancellationTokenSource();
      const unregister = cancellationToken.add(() => {
        scopedToken.cancel();
      });
      executor((value) => {
        unregister();
        resolve(value);
      }, (error) => {
        unregister();
        reject(error);
      }, scopedToken);
    });
  }

  // src/neuroglancer/util/disposable.ts
  var DEBUG_REF_COUNTS = false;
  function invokeDisposer(disposer) {
    if (typeof disposer === "object") {
      disposer.dispose();
    } else {
      disposer();
    }
  }
  function invokeDisposers(disposers) {
    for (let i = disposers.length; i > 0; --i) {
      invokeDisposer(disposers[i - 1]);
    }
  }
  function registerEventListener(target, type, listener, options) {
    target.addEventListener(type, listener, options);
    return () => target.removeEventListener(type, listener, options);
  }
  var RefCounted = class {
    constructor() {
      this.refCount = 1;
    }
    addRef() {
      ++this.refCount;
      return this;
    }
    dispose() {
      if (DEBUG_REF_COUNTS) {
        if (this.refCount === 0) {
          debugger;
        }
        (this.disposedStacks = this.disposedStacks || []).push(new Error().stack);
      }
      if (--this.refCount !== 0) {
        return;
      }
      this.refCountReachedZero();
    }
    refCountReachedZero() {
      this.disposed();
      let { disposers } = this;
      if (disposers !== void 0) {
        invokeDisposers(disposers);
        this.disposers = void 0;
      }
      this.wasDisposed = true;
    }
    disposed() {
    }
    registerDisposer(f) {
      let { disposers } = this;
      if (disposers == null) {
        this.disposers = [f];
      } else {
        disposers.push(f);
      }
      return f;
    }
    unregisterDisposer(f) {
      let { disposers } = this;
      if (disposers != null) {
        let index = disposers.indexOf(f);
        if (index !== -1) {
          disposers.splice(index, 1);
        }
      }
      return f;
    }
    registerEventListener(target, type, listener, options) {
      this.registerDisposer(registerEventListener(target, type, listener, options));
    }
    registerCancellable(cancellable) {
      this.registerDisposer(() => {
        cancellable.cancel();
      });
      return cancellable;
    }
  };
  var RefCountedValue = class extends RefCounted {
    constructor(value) {
      super();
      this.value = value;
    }
  };

  // src/neuroglancer/worker_rpc.ts
  var IS_WORKER = !(typeof Window !== "undefined" && self instanceof Window);
  var DEBUG = false;
  var DEBUG_MESSAGES = false;
  var PROMISE_RESPONSE_ID = "rpc.promise.response";
  var PROMISE_CANCEL_ID = "rpc.promise.cancel";
  var handlers = new Map();
  function registerRPC(key, handler) {
    handlers.set(key, handler);
  }
  var RPCError = class extends Error {
    constructor(name, message) {
      super(message);
      this.name = name;
      this.message = message;
    }
  };
  function registerPromiseRPC(key, handler) {
    registerRPC(key, function(x) {
      let id = x["id"];
      const cancellationToken = new CancellationTokenSource();
      let promise = handler.call(this, x, cancellationToken);
      this.set(id, { promise, cancellationToken });
      promise.then(({ value, transfers }) => {
        this.delete(id);
        this.invoke(PROMISE_RESPONSE_ID, { "id": id, "value": value }, transfers);
      }, (error) => {
        this.delete(id);
        this.invoke(PROMISE_RESPONSE_ID, { "id": id, "error": error.message, "errorName": error.name });
      });
    });
  }
  registerRPC(PROMISE_CANCEL_ID, function(x) {
    let id = x["id"];
    const request = this.get(id);
    if (request !== void 0) {
      let { cancellationToken } = request;
      cancellationToken.cancel();
    }
  });
  registerRPC(PROMISE_RESPONSE_ID, function(x) {
    let id = x["id"];
    let { resolve, reject } = this.get(id);
    this.delete(id);
    if (x.hasOwnProperty("value")) {
      resolve(x["value"]);
    } else {
      const errorName = x["errorName"];
      if (errorName === CANCELED.name) {
        reject(CANCELED);
      } else {
        reject(new RPCError(x["errorName"], x["error"]));
      }
    }
  });
  var INITIAL_RPC_ID = IS_WORKER ? -1 : 0;
  var RPC = class {
    constructor(target) {
      this.target = target;
      this.objects = new Map();
      this.nextId = INITIAL_RPC_ID;
      target.onmessage = (e) => {
        let data = e.data;
        if (DEBUG_MESSAGES) {
          console.log("Received message", data);
        }
        handlers.get(data.functionName).call(this, data);
      };
    }
    get numObjects() {
      return this.objects.size;
    }
    set(id, value) {
      this.objects.set(id, value);
    }
    delete(id) {
      this.objects.delete(id);
    }
    get(id) {
      return this.objects.get(id);
    }
    getRef(x) {
      let rpcId = x["id"];
      let obj = this.get(rpcId);
      obj.referencedGeneration = x["gen"];
      obj.addRef();
      return obj;
    }
    getOptionalRef(x) {
      if (x === void 0)
        return void 0;
      let rpcId = x["id"];
      let obj = this.get(rpcId);
      obj.referencedGeneration = x["gen"];
      obj.addRef();
      return obj;
    }
    invoke(name, x, transfers) {
      x.functionName = name;
      if (DEBUG_MESSAGES) {
        console.trace("Sending message", x);
      }
      this.target.postMessage(x, transfers);
    }
    promiseInvoke(name, x, cancellationToken = uncancelableToken, transfers) {
      return makeCancelablePromise(cancellationToken, (resolve, reject, token) => {
        const id = x["id"] = this.newId();
        this.set(id, { resolve, reject });
        this.invoke(name, x, transfers);
        token.add(() => {
          this.invoke(PROMISE_CANCEL_ID, { "id": id });
        });
      });
    }
    newId() {
      return IS_WORKER ? this.nextId-- : this.nextId++;
    }
  };
  var SharedObject = class extends RefCounted {
    constructor() {
      super(...arguments);
      this.rpc = null;
      this.rpcId = null;
    }
    initializeSharedObject(rpc2, rpcId = rpc2.newId()) {
      this.rpc = rpc2;
      this.rpcId = rpcId;
      this.isOwner = false;
      rpc2.set(rpcId, this);
    }
    initializeCounterpart(rpc2, options = {}) {
      this.initializeSharedObject(rpc2);
      this.unreferencedGeneration = 0;
      this.referencedGeneration = 0;
      this.isOwner = true;
      options["id"] = this.rpcId;
      options["type"] = this.RPC_TYPE_ID;
      rpc2.invoke("SharedObject.new", options);
    }
    dispose() {
      super.dispose();
    }
    addCounterpartRef() {
      return { "id": this.rpcId, "gen": ++this.referencedGeneration };
    }
    refCountReachedZero() {
      if (this.isOwner === true) {
        if (this.referencedGeneration === this.unreferencedGeneration) {
          this.ownerDispose();
        }
      } else if (this.isOwner === false) {
        this.rpc.invoke("SharedObject.refCountReachedZero", { "id": this.rpcId, "gen": this.referencedGeneration });
      } else {
        super.refCountReachedZero();
      }
    }
    ownerDispose() {
      if (DEBUG) {
        console.log(`[${IS_WORKER}] #rpc object = ${this.rpc.numObjects}`);
      }
      let { rpc: rpc2, rpcId } = this;
      super.refCountReachedZero();
      rpc2.delete(rpcId);
      rpc2.invoke("SharedObject.dispose", { "id": rpcId });
    }
    counterpartRefCountReachedZero(generation) {
      this.unreferencedGeneration = generation;
      if (this.refCount === 0 && generation === this.referencedGeneration) {
        this.ownerDispose();
      }
    }
  };
  function initializeSharedObjectCounterpart(obj, rpc2, options = {}) {
    if (rpc2 != null) {
      obj.initializeSharedObject(rpc2, options["id"]);
    }
  }
  var SharedObjectCounterpart = class extends SharedObject {
    constructor(rpc2, options = {}) {
      super();
      initializeSharedObjectCounterpart(this, rpc2, options);
    }
  };
  registerRPC("SharedObject.dispose", function(x) {
    let obj = this.get(x["id"]);
    if (obj.refCount !== 0) {
      throw new Error(`Attempted to dispose object with non-zero reference count.`);
    }
    if (DEBUG) {
      console.log(`[${IS_WORKER}] #rpc objects: ${this.numObjects}`);
    }
    obj.disposed();
    this.delete(obj.rpcId);
    obj.rpcId = null;
    obj.rpc = null;
  });
  var WORKER_RPC_ID = "Worker";
  registerRPC(WORKER_RPC_ID, function(x) {
    const { port, path } = x;
    const worker = new Worker(path);
    worker.postMessage({ port }, [port]);
  });
  registerRPC("SharedObject.refCountReachedZero", function(x) {
    let obj = this.get(x["id"]);
    let generation = x["gen"];
    obj.counterpartRefCountReachedZero(generation);
  });
  var sharedObjectConstructors = new Map();
  function registerSharedObjectOwner(identifier) {
    return (constructorFunction) => {
      constructorFunction.prototype.RPC_TYPE_ID = identifier;
    };
  }
  function registerSharedObject(identifier) {
    return (constructorFunction) => {
      if (identifier !== void 0) {
        constructorFunction.prototype.RPC_TYPE_ID = identifier;
      } else {
        identifier = constructorFunction.prototype.RPC_TYPE_ID;
        if (identifier === void 0) {
          throw new Error("RPC_TYPE_ID should have already been defined");
        }
      }
      sharedObjectConstructors.set(identifier, constructorFunction);
    };
  }
  registerRPC("SharedObject.new", function(x) {
    let rpc2 = this;
    let typeName = x["type"];
    let constructorFunction = sharedObjectConstructors.get(typeName);
    let obj = new constructorFunction(rpc2, x);
    --obj.refCount;
  });

  // src/neuroglancer/worker_rpc_context.ts
  var rpc = new RPC(self);
  self.rpc = rpc;

  // src/neuroglancer/chunk_manager/backend.ts
  var import_throttle = __toModule(require_throttle());

  // src/neuroglancer/chunk_manager/base.ts
  var ChunkState;
  (function(ChunkState2) {
    ChunkState2[ChunkState2["GPU_MEMORY"] = 0] = "GPU_MEMORY";
    ChunkState2[ChunkState2["SYSTEM_MEMORY"] = 1] = "SYSTEM_MEMORY";
    ChunkState2[ChunkState2["SYSTEM_MEMORY_WORKER"] = 2] = "SYSTEM_MEMORY_WORKER";
    ChunkState2[ChunkState2["DOWNLOADING"] = 3] = "DOWNLOADING";
    ChunkState2[ChunkState2["QUEUED"] = 4] = "QUEUED";
    ChunkState2[ChunkState2["NEW"] = 5] = "NEW";
    ChunkState2[ChunkState2["FAILED"] = 6] = "FAILED";
    ChunkState2[ChunkState2["EXPIRED"] = 7] = "EXPIRED";
  })(ChunkState || (ChunkState = {}));
  var numChunkStates = 8;
  var ChunkPriorityTier;
  (function(ChunkPriorityTier2) {
    ChunkPriorityTier2[ChunkPriorityTier2["FIRST_TIER"] = 0] = "FIRST_TIER";
    ChunkPriorityTier2[ChunkPriorityTier2["FIRST_ORDERED_TIER"] = 0] = "FIRST_ORDERED_TIER";
    ChunkPriorityTier2[ChunkPriorityTier2["VISIBLE"] = 0] = "VISIBLE";
    ChunkPriorityTier2[ChunkPriorityTier2["PREFETCH"] = 1] = "PREFETCH";
    ChunkPriorityTier2[ChunkPriorityTier2["LAST_ORDERED_TIER"] = 1] = "LAST_ORDERED_TIER";
    ChunkPriorityTier2[ChunkPriorityTier2["RECENT"] = 2] = "RECENT";
    ChunkPriorityTier2[ChunkPriorityTier2["LAST_TIER"] = 2] = "LAST_TIER";
  })(ChunkPriorityTier || (ChunkPriorityTier = {}));
  var numChunkPriorityTiers = 3;
  var ChunkDownloadStatistics;
  (function(ChunkDownloadStatistics2) {
    ChunkDownloadStatistics2[ChunkDownloadStatistics2["totalTime"] = 0] = "totalTime";
    ChunkDownloadStatistics2[ChunkDownloadStatistics2["totalChunks"] = 1] = "totalChunks";
  })(ChunkDownloadStatistics || (ChunkDownloadStatistics = {}));
  var ChunkMemoryStatistics;
  (function(ChunkMemoryStatistics2) {
    ChunkMemoryStatistics2[ChunkMemoryStatistics2["numChunks"] = 0] = "numChunks";
    ChunkMemoryStatistics2[ChunkMemoryStatistics2["systemMemoryBytes"] = 1] = "systemMemoryBytes";
    ChunkMemoryStatistics2[ChunkMemoryStatistics2["gpuMemoryBytes"] = 2] = "gpuMemoryBytes";
  })(ChunkMemoryStatistics || (ChunkMemoryStatistics = {}));
  var numChunkMemoryStatistics = 3;
  var numChunkDownloadStatistics = 2;
  var numChunkStatistics = numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics + numChunkDownloadStatistics;
  function getChunkStateStatisticIndex(state, priorityTier) {
    return state * numChunkPriorityTiers + priorityTier;
  }
  function getChunkDownloadStatisticIndex(statistic) {
    return numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics + statistic;
  }
  var PREFETCH_PRIORITY_MULTIPLIER = 1e13;
  var CHUNK_QUEUE_MANAGER_RPC_ID = "ChunkQueueManager";
  var CHUNK_MANAGER_RPC_ID = "ChunkManager";
  var CHUNK_SOURCE_INVALIDATE_RPC_ID = "ChunkSource.invalidate";
  var REQUEST_CHUNK_STATISTICS_RPC_ID = "ChunkQueueManager.requestChunkStatistics";
  var CHUNK_LAYER_STATISTICS_RPC_ID = "ChunkManager.chunkLayerStatistics";

  // src/neuroglancer/util/linked_list.0.ts
  var linked_list_0_default = class {
    static insertAfter(head, x) {
      let next = head.next0;
      x.next0 = next;
      x.prev0 = head;
      head.next0 = x;
      next.prev0 = x;
    }
    static insertBefore(head, x) {
      let prev = head.prev0;
      x.prev0 = prev;
      x.next0 = head;
      head.prev0 = x;
      prev.next0 = x;
    }
    static front(head) {
      let next = head.next0;
      if (next === head) {
        return null;
      }
      return next;
    }
    static back(head) {
      let next = head.prev0;
      if (next === head) {
        return null;
      }
      return next;
    }
    static pop(x) {
      let next = x.next0;
      let prev = x.prev0;
      next.prev0 = prev;
      prev.next0 = next;
      x.next0 = null;
      x.prev0 = null;
      return x;
    }
    static *iterator(head) {
      for (let x = head.next0; x !== head; x = x.next0) {
        yield x;
      }
    }
    static *reverseIterator(head) {
      for (let x = head.prev0; x !== head; x = x.prev0) {
        yield x;
      }
    }
    static initializeHead(head) {
      head.next0 = head.prev0 = head;
    }
  };

  // src/neuroglancer/util/linked_list.1.ts
  var linked_list_1_default = class {
    static insertAfter(head, x) {
      let next = head.next1;
      x.next1 = next;
      x.prev1 = head;
      head.next1 = x;
      next.prev1 = x;
    }
    static insertBefore(head, x) {
      let prev = head.prev1;
      x.prev1 = prev;
      x.next1 = head;
      head.prev1 = x;
      prev.next1 = x;
    }
    static front(head) {
      let next = head.next1;
      if (next === head) {
        return null;
      }
      return next;
    }
    static back(head) {
      let next = head.prev1;
      if (next === head) {
        return null;
      }
      return next;
    }
    static pop(x) {
      let next = x.next1;
      let prev = x.prev1;
      next.prev1 = prev;
      prev.next1 = next;
      x.next1 = null;
      x.prev1 = null;
      return x;
    }
    static *iterator(head) {
      for (let x = head.next1; x !== head; x = x.next1) {
        yield x;
      }
    }
    static *reverseIterator(head) {
      for (let x = head.prev1; x !== head; x = x.prev1) {
        yield x;
      }
    }
    static initializeHead(head) {
      head.next1 = head.prev1 = head;
    }
  };

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };

  // node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add,
    adjoint: () => adjoint,
    clone: () => clone,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  function clone(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a, b, scale6) {
    out[0] = a[0] + b[0] * scale6;
    out[1] = a[1] + b[1] * scale6;
    out[2] = a[2] + b[2] * scale6;
    out[3] = a[3] + b[3] * scale6;
    out[4] = a[4] + b[4] * scale6;
    out[5] = a[5] + b[5] * scale6;
    out[6] = a[6] + b[6] * scale6;
    out[7] = a[7] + b[7] * scale6;
    out[8] = a[8] + b[8] * scale6;
    return out;
  }
  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
  }
  var mul = multiply;
  var sub = subtract;

  // node_modules/gl-matrix/esm/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add2,
    adjoint: () => adjoint2,
    clone: () => clone2,
    copy: () => copy2,
    create: () => create2,
    determinant: () => determinant2,
    equals: () => equals2,
    exactEquals: () => exactEquals2,
    frob: () => frob2,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation2,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling2,
    fromTranslation: () => fromTranslation2,
    fromValues: () => fromValues2,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity2,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul2,
    multiply: () => multiply2,
    multiplyScalar: () => multiplyScalar2,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
    ortho: () => ortho,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    rotate: () => rotate2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    scale: () => scale2,
    set: () => set2,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create2() {
    var out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone2(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function copy2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a03 = a[3];
      var a12 = a[6], a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  function determinant2(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate2(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len4 = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len4 < EPSILON) {
      return null;
    }
    len4 = 1 / len4;
    x *= len4;
    y *= len4;
    z *= len4;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromTranslation2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromScaling2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation2(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len4 = Math.hypot(x, y, z);
    var s, c, t;
    if (len4 < EPSILON) {
      return null;
    }
    len4 = 1 / len4;
    x *= len4;
    y *= len4;
    z *= len4;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q, v) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  function fromRotationTranslationScale(out, q, v, s) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len4;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity2(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len4 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len4 = Math.hypot(x0, x1, x2);
    if (!len4) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len4 = 1 / len4;
      x0 *= len4;
      x1 *= len4;
      x2 *= len4;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len4 = Math.hypot(y0, y1, y2);
    if (!len4) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len4 = 1 / len4;
      y0 *= len4;
      y1 *= len4;
      y2 *= len4;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len4 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
      z0 *= len4;
      z1 *= len4;
      z2 *= len4;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len4 = x0 * x0 + x1 * x1 + x2 * x2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
      x0 *= len4;
      x1 *= len4;
      x2 *= len4;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str2(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
  function frob2(a) {
    return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  function subtract2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  function multiplyScalar2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  function multiplyScalarAndAdd2(out, a, b, scale6) {
    out[0] = a[0] + b[0] * scale6;
    out[1] = a[1] + b[1] * scale6;
    out[2] = a[2] + b[2] * scale6;
    out[3] = a[3] + b[3] * scale6;
    out[4] = a[4] + b[4] * scale6;
    out[5] = a[5] + b[5] * scale6;
    out[6] = a[6] + b[6] * scale6;
    out[7] = a[7] + b[7] * scale6;
    out[8] = a[8] + b[8] * scale6;
    out[9] = a[9] + b[9] * scale6;
    out[10] = a[10] + b[10] * scale6;
    out[11] = a[11] + b[11] * scale6;
    out[12] = a[12] + b[12] * scale6;
    out[13] = a[13] + b[13] * scale6;
    out[14] = a[14] + b[14] * scale6;
    out[15] = a[15] + b[15] * scale6;
    return out;
  }
  function exactEquals2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  function equals2(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul2 = multiply2;
  var sub2 = subtract2;

  // node_modules/gl-matrix/esm/quat.js
  var quat_exports = {};
  __export(quat_exports, {
    add: () => add5,
    calculateW: () => calculateW,
    clone: () => clone5,
    conjugate: () => conjugate,
    copy: () => copy5,
    create: () => create5,
    dot: () => dot3,
    equals: () => equals5,
    exactEquals: () => exactEquals5,
    exp: () => exp,
    fromEuler: () => fromEuler,
    fromMat3: () => fromMat3,
    fromValues: () => fromValues5,
    getAngle: () => getAngle,
    getAxisAngle: () => getAxisAngle,
    identity: () => identity3,
    invert: () => invert3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp3,
    ln: () => ln,
    mul: () => mul5,
    multiply: () => multiply5,
    normalize: () => normalize3,
    pow: () => pow,
    random: () => random3,
    rotateX: () => rotateX3,
    rotateY: () => rotateY3,
    rotateZ: () => rotateZ3,
    rotationTo: () => rotationTo,
    scale: () => scale5,
    set: () => set5,
    setAxes: () => setAxes,
    setAxisAngle: () => setAxisAngle,
    slerp: () => slerp,
    sqlerp: () => sqlerp,
    sqrLen: () => sqrLen3,
    squaredLength: () => squaredLength3,
    str: () => str5
  });

  // node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add3,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone3,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals3,
    exactEquals: () => exactEquals3,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues3,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    round: () => round,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set3,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone3(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues3(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function copy3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function set3(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  function scaleAndAdd(out, a, b, scale6) {
    out[0] = a[0] + b[0] * scale6;
    out[1] = a[1] + b[1] * scale6;
    out[2] = a[2] + b[2] * scale6;
    return out;
  }
  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len4 = x * x + y * y + z * z;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = a[0] * len4;
    out[1] = a[1] * len4;
    out[2] = a[2] * len4;
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function random(out, scale6) {
    scale6 = scale6 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale6;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale6;
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX2(out, a, b, c) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY2(out, a, b, c) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ2(out, a, b, c) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var tempA2 = fromValues3(a[0], a[1], a[2]);
    var tempB2 = fromValues3(b[0], b[1], b[2]);
    normalize(tempA2, tempA2);
    normalize(tempB2, tempB2);
    var cosine = dot(tempA2, tempB2);
    if (cosine > 1) {
      return 0;
    } else if (cosine < -1) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str3(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
  }
  function exactEquals3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  function equals3(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
  }
  var sub3 = subtract3;
  var mul3 = multiply3;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var len = length;
  var sqrLen = squaredLength;
  var forEach = function() {
    var vec = create3();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // node_modules/gl-matrix/esm/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add4,
    ceil: () => ceil2,
    clone: () => clone4,
    copy: () => copy4,
    create: () => create4,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals4,
    exactEquals: () => exactEquals4,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues4,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max2,
    min: () => min2,
    mul: () => mul4,
    multiply: () => multiply4,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    round: () => round2,
    scale: () => scale4,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set4,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat2,
    zero: () => zero2
  });
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone4(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  function fromValues4(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function copy4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  function set4(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function add4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  function subtract4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  function multiply4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  function divide2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  function ceil2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  function floor2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  function min2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  function max2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  function round2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  function scale4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  function scaleAndAdd2(out, a, b, scale6) {
    out[0] = a[0] + b[0] * scale6;
    out[1] = a[1] + b[1] * scale6;
    out[2] = a[2] + b[2] * scale6;
    out[3] = a[3] + b[3] * scale6;
    return out;
  }
  function distance2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredDistance2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  function length2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredLength2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  function inverse2(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
  }
  function normalize2(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len4 = x * x + y * y + z * z + w * w;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = x * len4;
    out[1] = y * len4;
    out[2] = z * len4;
    out[3] = w * len4;
    return out;
  }
  function dot2(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  function cross2(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  function random2(out, scale6) {
    scale6 = scale6 || 1;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale6 * v1;
    out[1] = scale6 * v2;
    out[2] = scale6 * v3 * d;
    out[3] = scale6 * v4 * d;
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat2(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  function exactEquals4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  function equals4(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
  }
  var sub4 = subtract4;
  var mul4 = multiply4;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var len2 = length2;
  var sqrLen2 = squaredLength2;
  var forEach2 = function() {
    var vec = create4();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  }();

  // node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }
    return rad;
  }
  function getAngle(a, b) {
    var dotproduct = dot3(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  function multiply5(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
  }
  function exp(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
  }
  function ln(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
  }
  function pow(out, a, b) {
    ln(out, a);
    scale5(out, out, b);
    exp(out, out);
    return out;
  }
  function slerp(out, a, b, t) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function random3(out) {
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
  }
  function invert3(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot4 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot4 ? 1 / dot4 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i = 0;
      if (m[4] > m[0])
        i = 1;
      if (m[8] > m[i * 3 + i])
        i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  function str5(a) {
    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  var clone5 = clone4;
  var fromValues5 = fromValues4;
  var copy5 = copy4;
  var set5 = set4;
  var add5 = add4;
  var mul5 = multiply5;
  var scale5 = scale4;
  var dot3 = dot2;
  var lerp3 = lerp2;
  var length3 = length2;
  var len3 = length3;
  var squaredLength3 = squaredLength2;
  var sqrLen3 = squaredLength3;
  var normalize3 = normalize2;
  var exactEquals5 = exactEquals4;
  var equals5 = equals4;
  var rotationTo = function() {
    var tmpvec3 = create3();
    var xUnitVec3 = fromValues3(1, 0, 0);
    var yUnitVec3 = fromValues3(0, 1, 0);
    return function(out, a, b) {
      var dot4 = dot(a, b);
      if (dot4 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 1e-6)
          cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot4 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot4;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // src/neuroglancer/util/array.ts
  function arraysEqual(a, b) {
    const length4 = a.length;
    if (b.length !== length4)
      return false;
    for (let i = 0; i < length4; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }

  // src/neuroglancer/util/geom.ts
  var identityMat4 = mat4_exports.create();
  var kAxes = [
    vec3_exports.fromValues(1, 0, 0),
    vec3_exports.fromValues(0, 1, 0),
    vec3_exports.fromValues(0, 0, 1)
  ];
  var kZeroVec = vec3_exports.fromValues(0, 0, 0);
  var kZeroVec4 = vec4_exports.fromValues(0, 0, 0, 0);
  var kOneVec = vec3_exports.fromValues(1, 1, 1);
  var kInfinityVec = vec3_exports.fromValues(Infinity, Infinity, Infinity);
  var kIdentityQuat = quat_exports.create();
  function prod3(x) {
    return x[0] * x[1] * x[2];
  }
  function vec3Key(x) {
    return `${x[0]},${x[1]},${x[2]}`;
  }
  function transformVectorByMat4(out, a, m) {
    let x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z;
    out[1] = m[1] * x + m[5] * y + m[9] * z;
    out[2] = m[2] * x + m[6] * y + m[10] * z;
    return out;
  }
  function transformVectorByMat4Transpose(out, a, m) {
    let x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[1] * y + m[2] * z;
    out[1] = m[4] * x + m[5] * y + m[6] * z;
    out[2] = m[8] * x + m[9] * y + m[10] * z;
    return out;
  }
  function translationRotationScaleZReflectionToMat4(out, translation, rotation, scale6, zReflection) {
    const temp = out;
    out[0] = scale6[0];
    out[1] = scale6[1];
    out[2] = scale6[2] * zReflection;
    return mat4_exports.fromRotationTranslationScale(out, rotation, translation, temp);
  }
  function mat3FromMat4(out, m) {
    const m00 = m[0], m01 = m[1], m02 = m[2], m10 = m[4], m11 = m[5], m12 = m[6], m20 = m[8], m21 = m[9], m22 = m[10];
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function getFrustrumPlanes(out, m) {
    const m00 = m[0], m10 = m[1], m20 = m[2], m30 = m[3], m01 = m[4], m11 = m[5], m21 = m[6], m31 = m[7], m02 = m[8], m12 = m[9], m22 = m[10], m32 = m[11], m03 = m[12], m13 = m[13], m23 = m[14], m33 = m[15];
    out[0] = m30 + m00;
    out[1] = m31 + m01;
    out[2] = m32 + m02;
    out[3] = m33 + m03;
    out[4] = m30 - m00;
    out[5] = m31 - m01;
    out[6] = m32 - m02;
    out[7] = m33 - m03;
    out[8] = m30 + m10;
    out[9] = m31 + m11;
    out[10] = m32 + m12;
    out[11] = m33 + m13;
    out[12] = m30 - m10;
    out[13] = m31 - m11;
    out[14] = m32 - m12;
    out[15] = m33 - m13;
    const nearA = m30 + m20;
    const nearB = m31 + m21;
    const nearC = m32 + m22;
    const nearD = m33 + m23;
    const farA = m30 - m20;
    const farB = m31 - m21;
    const farC = m32 - m22;
    const farD = m33 - m23;
    const nearNorm = Math.sqrt(nearA ** 2 + nearB ** 2 + nearC ** 2);
    out[16] = nearA / nearNorm;
    out[17] = nearB / nearNorm;
    out[18] = nearC / nearNorm;
    out[19] = nearD / nearNorm;
    const farNorm = Math.sqrt(farA ** 2 + farB ** 2 + farC ** 2);
    out[20] = farA / farNorm;
    out[21] = farB / farNorm;
    out[22] = farC / farNorm;
    out[23] = farD / farNorm;
    return out;
  }
  function isAABBVisible(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes) {
    for (let i = 0; i < 6; ++i) {
      const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
      const sum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) + Math.max(c * zLower, c * zUpper) + d;
      if (sum < 0) {
        return false;
      }
    }
    return true;
  }
  function isAABBIntersectingPlane(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes) {
    for (let i = 0; i < 4; ++i) {
      const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
      const sum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) + Math.max(c * zLower, c * zUpper) + d;
      if (sum < 0) {
        return false;
      }
    }
    {
      const i = 5;
      const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
      const maxSum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) + Math.max(c * zLower, c * zUpper);
      const minSum = Math.min(a * xLower, a * xUpper) + Math.min(b * yLower, b * yUpper) + Math.min(c * zLower, c * zUpper);
      const epsilon = Math.abs(d) * 1e-6;
      if (minSum > -d + epsilon || maxSum < -d - epsilon)
        return false;
    }
    return true;
  }
  function getViewFrustrumVolume(projectionMat) {
    if (projectionMat[15] === 1) {
      const depth = 2 / Math.abs(projectionMat[10]);
      const width = 2 / Math.abs(projectionMat[0]);
      const height = 2 / Math.abs(projectionMat[5]);
      return width * height * depth;
    }
    const a = projectionMat[10];
    const b = projectionMat[14];
    const near = 2 * b / (2 * a - 2);
    const far = (a - 1) * near / (a + 1);
    const baseArea = 4 / (projectionMat[0] * projectionMat[5]);
    return baseArea / 3 * (Math.abs(far) ** 3 - Math.abs(near) ** 3);
  }
  function getViewFrustrumDepthRange(projectionMat) {
    if (projectionMat[15] === 1) {
      const depth2 = 2 / Math.abs(projectionMat[10]);
      return depth2;
    }
    const a = projectionMat[10];
    const b = projectionMat[14];
    const near = 2 * b / (2 * a - 2);
    const far = (a - 1) * near / (a + 1);
    const depth = Math.abs(far - near);
    return depth;
  }
  var tempVec3 = vec3_exports.create();

  // src/neuroglancer/util/json.ts
  function verifyFloat(obj) {
    let t = typeof obj;
    if (t === "number" || t === "string") {
      let x = parseFloat("" + obj);
      if (!Number.isNaN(x)) {
        return x;
      }
    }
    throw new Error(`Expected floating-point number, but received: ${JSON.stringify(obj)}.`);
  }
  function verifyFiniteFloat(obj) {
    let x = verifyFloat(obj);
    if (Number.isFinite(x)) {
      return x;
    }
    throw new Error(`Expected finite floating-point number, but received: ${x}.`);
  }
  function verifyFiniteNonNegativeFloat(obj) {
    let x = verifyFloat(obj);
    if (Number.isFinite(x) && x >= 0) {
      return x;
    }
    throw new Error(`Expected finite non-negative floating-point number, but received: ${x}.`);
  }
  function stableStringify(x) {
    if (typeof x === "object") {
      if (x === null) {
        return "null";
      }
      if (Array.isArray(x)) {
        let s2 = "[";
        let size2 = x.length;
        let i2 = 0;
        if (i2 < size2) {
          s2 += stableStringify(x[i2]);
          while (++i2 < size2) {
            s2 += ",";
            s2 += stableStringify(x[i2]);
          }
        }
        s2 += "]";
        return s2;
      }
      let s = "{";
      let keys = Object.keys(x).sort();
      let i = 0;
      let size = keys.length;
      if (i < size) {
        let key = keys[i];
        s += JSON.stringify(key);
        s += ":";
        s += stableStringify(x[key]);
        while (++i < size) {
          s += ",";
          key = keys[i];
          s += JSON.stringify(key);
          s += ":";
          s += stableStringify(x[key]);
        }
      }
      s += "}";
      return s;
    }
    return JSON.stringify(x);
  }
  var SINGLE_QUOTE_STRING_PATTERN = /('(?:[^'\\]|(?:\\.))*')/;
  var DOUBLE_QUOTE_STRING_PATTERN = /("(?:[^"\\]|(?:\\.))*")/;
  var SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN = new RegExp(`${SINGLE_QUOTE_STRING_PATTERN.source}|${DOUBLE_QUOTE_STRING_PATTERN.source}`);
  var DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN = new RegExp(`${DOUBLE_QUOTE_STRING_PATTERN.source}|${SINGLE_QUOTE_STRING_PATTERN.source}`);
  var DOUBLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\[^']))*)("|\\')/;
  function convertStringLiteral(x, quoteInitial, quoteReplace, quoteSearch) {
    if (x.length >= 2 && x.charAt(0) === quoteInitial && x.charAt(x.length - 1) === quoteInitial) {
      let inner = x.substr(1, x.length - 2);
      let s = quoteReplace;
      while (inner.length > 0) {
        let m = inner.match(quoteSearch);
        if (m === null) {
          s += inner;
          break;
        }
        s += m[1];
        if (m[2] === quoteReplace) {
          s += "\\";
          s += quoteReplace;
        } else {
          s += quoteInitial;
        }
        inner = inner.substr(m.index + m[0].length);
      }
      s += quoteReplace;
      return s;
    }
    return x;
  }
  function normalizeStringLiteral(x) {
    return convertStringLiteral(x, "'", '"', DOUBLE_QUOTE_PATTERN);
  }
  function pythonLiteralToJSON(x) {
    let s = "";
    while (x.length > 0) {
      let m = x.match(SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN);
      let before;
      let replacement;
      if (m === null) {
        before = x;
        x = "";
        replacement = "";
      } else {
        before = x.substr(0, m.index);
        x = x.substr(m.index + m[0].length);
        let singleQuoteString = m[1];
        if (singleQuoteString !== void 0) {
          replacement = normalizeStringLiteral(singleQuoteString);
        } else {
          replacement = m[2];
        }
      }
      s += before.replace(/\(/g, "[").replace(/\)/g, "]").replace("True", "true").replace("False", "false").replace(/,\s*([\}\]])/g, "$1");
      s += replacement;
    }
    return s;
  }
  function pythonLiteralParse(x) {
    return JSON.parse(pythonLiteralToJSON(x));
  }
  function expectArray(x, length4) {
    if (!Array.isArray(x)) {
      throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);
    }
    if (length4 !== void 0 && x.length !== length4) {
      throw new Error(`Expected array of length ${length4}, but received: ${JSON.stringify(x)}.`);
    }
    return x;
  }
  function parseArray(x, parseElement) {
    if (!Array.isArray(x)) {
      throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);
    }
    return x.map(parseElement);
  }
  function parseFixedLengthArray(out, obj, parseElement) {
    const length4 = out.length;
    if (!Array.isArray(obj) || obj.length !== length4) {
      throw new Error(`Expected length ${length4} array, but received: ${JSON.stringify(obj)}.`);
    }
    for (let i = 0; i < length4; ++i) {
      out[i] = parseElement(obj[i], i);
    }
    return out;
  }
  function verifyObject(obj) {
    if (typeof obj !== "object" || obj == null || Array.isArray(obj)) {
      throw new Error(`Expected JSON object, but received: ${JSON.stringify(obj)}.`);
    }
    return obj;
  }
  function verifyInt(obj) {
    let result = parseInt(obj, 10);
    if (!Number.isInteger(result)) {
      throw new Error(`Expected integer, but received: ${JSON.stringify(obj)}.`);
    }
    return result;
  }
  function verifyString(obj) {
    if (typeof obj !== "string") {
      throw new Error(`Expected string, but received: ${JSON.stringify(obj)}.`);
    }
    return obj;
  }
  function verifyOptionalString(obj) {
    if (obj === void 0) {
      return void 0;
    }
    return verifyString(obj);
  }
  function verifyObjectProperty(obj, propertyName, validator) {
    let value = Object.prototype.hasOwnProperty.call(obj, propertyName) ? obj[propertyName] : void 0;
    try {
      return validator(value);
    } catch (parseError) {
      throw new Error(`Error parsing ${JSON.stringify(propertyName)} property: ${parseError.message}`);
    }
  }
  function verifyEnumString(obj, enumType) {
    if (typeof obj === "string" && obj.match(/^[a-zA-Z]/) !== null) {
      obj = obj.toUpperCase();
      if (enumType.hasOwnProperty(obj)) {
        return enumType[obj];
      }
    }
    throw new Error(`Invalid enum value: ${JSON.stringify(obj)}.`);
  }
  function verifyStringArray(a) {
    if (!Array.isArray(a)) {
      throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);
    }
    for (let x of a) {
      if (typeof x !== "string") {
        throw new Error(`Expected string, received: ${JSON.stringify(x)}.`);
      }
    }
    return a;
  }

  // src/neuroglancer/util/memoize.ts
  var Memoize = class {
    constructor() {
      this.map = new Map();
    }
    get(key, getter) {
      let { map } = this;
      let obj = map.get(key);
      if (obj === void 0) {
        obj = getter();
        obj.registerDisposer(() => {
          map.delete(key);
        });
        map.set(key, obj);
      } else {
        obj.addRef();
      }
      return obj;
    }
  };
  var StringMemoize = class extends Memoize {
    get(x, getter) {
      if (typeof x !== "string") {
        x = stableStringify(x);
      }
      return super.get(x, getter);
    }
    getUncounted(x, getter) {
      return this.get(x, () => new RefCountedValue(getter())).value;
    }
  };

  // src/neuroglancer/util/pairing_heap.0.ts
  var Implementation = class {
    constructor(compare) {
      this.compare = compare;
    }
    meld(a, b) {
      if (b === null) {
        return a;
      }
      if (a === null) {
        return b;
      }
      let { compare } = this;
      if (compare(b, a)) {
        let temp = a;
        a = b;
        b = temp;
      }
      var aChild = a.child0;
      b.next0 = aChild;
      b.prev0 = a;
      if (aChild !== null) {
        aChild.prev0 = b;
      }
      a.child0 = b;
      return a;
    }
    combineChildren(node) {
      var cur = node.child0;
      if (cur === null) {
        return null;
      }
      let head = null;
      while (true) {
        let curNext = cur.next0;
        let next, m;
        if (curNext === null) {
          next = null;
          m = cur;
        } else {
          next = curNext.next0;
          m = this.meld(cur, curNext);
        }
        m.next0 = head;
        head = m;
        if (next === null) {
          break;
        }
        cur = next;
      }
      var root = head;
      head = head.next0;
      while (true) {
        if (head === null) {
          break;
        }
        let next = head.next0;
        root = this.meld(root, head);
        head = next;
      }
      root.prev0 = null;
      root.next0 = null;
      return root;
    }
    removeMin(root) {
      var newRoot = this.combineChildren(root);
      root.next0 = null;
      root.prev0 = null;
      root.child0 = null;
      return newRoot;
    }
    remove(root, node) {
      if (root === node) {
        return this.removeMin(root);
      }
      var prev = node.prev0;
      var next = node.next0;
      if (prev.child0 === node) {
        prev.child0 = next;
      } else {
        prev.next0 = next;
      }
      if (next !== null) {
        next.prev0 = prev;
      }
      let newRoot = this.meld(root, this.combineChildren(node));
      node.next0 = null;
      node.prev0 = null;
      node.child0 = null;
      return newRoot;
    }
    *entries(root) {
      if (root !== null) {
        let child = root.child0;
        yield root;
        while (child !== null) {
          let next = child.next0;
          yield* this.entries(child);
          child = next;
        }
      }
    }
    *removedEntries(root) {
      if (root !== null) {
        let child = root.child0;
        root.child0 = null;
        root.next0 = null;
        root.prev0 = null;
        yield root;
        while (child !== null) {
          let next = child.next0;
          child.child0 = null;
          child.next0 = null;
          child.prev0 = null;
          yield* this.entries(child);
          child = next;
        }
      }
    }
  };

  // src/neuroglancer/util/pairing_heap.1.ts
  var Implementation2 = class {
    constructor(compare) {
      this.compare = compare;
    }
    meld(a, b) {
      if (b === null) {
        return a;
      }
      if (a === null) {
        return b;
      }
      let { compare } = this;
      if (compare(b, a)) {
        let temp = a;
        a = b;
        b = temp;
      }
      var aChild = a.child1;
      b.next1 = aChild;
      b.prev1 = a;
      if (aChild !== null) {
        aChild.prev1 = b;
      }
      a.child1 = b;
      return a;
    }
    combineChildren(node) {
      var cur = node.child1;
      if (cur === null) {
        return null;
      }
      let head = null;
      while (true) {
        let curNext = cur.next1;
        let next, m;
        if (curNext === null) {
          next = null;
          m = cur;
        } else {
          next = curNext.next1;
          m = this.meld(cur, curNext);
        }
        m.next1 = head;
        head = m;
        if (next === null) {
          break;
        }
        cur = next;
      }
      var root = head;
      head = head.next1;
      while (true) {
        if (head === null) {
          break;
        }
        let next = head.next1;
        root = this.meld(root, head);
        head = next;
      }
      root.prev1 = null;
      root.next1 = null;
      return root;
    }
    removeMin(root) {
      var newRoot = this.combineChildren(root);
      root.next1 = null;
      root.prev1 = null;
      root.child1 = null;
      return newRoot;
    }
    remove(root, node) {
      if (root === node) {
        return this.removeMin(root);
      }
      var prev = node.prev1;
      var next = node.next1;
      if (prev.child1 === node) {
        prev.child1 = next;
      } else {
        prev.next1 = next;
      }
      if (next !== null) {
        next.prev1 = prev;
      }
      let newRoot = this.meld(root, this.combineChildren(node));
      node.next1 = null;
      node.prev1 = null;
      node.child1 = null;
      return newRoot;
    }
    *entries(root) {
      if (root !== null) {
        let child = root.child1;
        yield root;
        while (child !== null) {
          let next = child.next1;
          yield* this.entries(child);
          child = next;
        }
      }
    }
    *removedEntries(root) {
      if (root !== null) {
        let child = root.child1;
        root.child1 = null;
        root.next1 = null;
        root.prev1 = null;
        yield root;
        while (child !== null) {
          let next = child.next1;
          child.child1 = null;
          child.next1 = null;
          child.prev1 = null;
          yield* this.entries(child);
          child = next;
        }
      }
    }
  };

  // src/neuroglancer/util/signal.ts
  var Signal = class {
    constructor() {
      this.handlers = new Set();
      this.count = 0;
      const obj = this;
      this.dispatch = function() {
        ++obj.count;
        obj.handlers.forEach((handler) => {
          handler.apply(this, arguments);
        });
      };
    }
    add(handler) {
      this.handlers.add(handler);
      return () => {
        return this.remove(handler);
      };
    }
    remove(handler) {
      return this.handlers.delete(handler);
    }
    dispose() {
      this.handlers = void 0;
    }
  };
  var NullarySignal = class extends Signal {
  };

  // src/neuroglancer/chunk_manager/backend.ts
  var DEBUG_CHUNK_UPDATES = false;
  var nextMarkGeneration = 0;
  function getNextMarkGeneration() {
    return ++nextMarkGeneration;
  }
  var Chunk = class {
    constructor() {
      this.child0 = null;
      this.next0 = null;
      this.prev0 = null;
      this.child1 = null;
      this.next1 = null;
      this.prev1 = null;
      this.source = null;
      this.key = null;
      this.state_ = ChunkState.NEW;
      this.error = null;
      this.markGeneration = -1;
      this.priority = 0;
      this.newPriority = 0;
      this.priorityTier = ChunkPriorityTier.RECENT;
      this.newPriorityTier = ChunkPriorityTier.RECENT;
      this.systemMemoryBytes_ = 0;
      this.gpuMemoryBytes_ = 0;
      this.downloadSlots_ = 1;
      this.backendOnly = false;
      this.isComputational = false;
      this.newlyRequestedToFrontend = false;
      this.requestedToFrontend = false;
      this.downloadCancellationToken = void 0;
    }
    initialize(key) {
      this.key = key;
      this.priority = Number.NEGATIVE_INFINITY;
      this.priorityTier = ChunkPriorityTier.RECENT;
      this.newPriority = Number.NEGATIVE_INFINITY;
      this.newPriorityTier = ChunkPriorityTier.RECENT;
      this.error = null;
      this.state = ChunkState.NEW;
      this.requestedToFrontend = false;
      this.newlyRequestedToFrontend = false;
    }
    updatePriorityProperties() {
      this.priorityTier = this.newPriorityTier;
      this.priority = this.newPriority;
      this.newPriorityTier = ChunkPriorityTier.RECENT;
      this.newPriority = Number.NEGATIVE_INFINITY;
      this.requestedToFrontend = this.newlyRequestedToFrontend;
    }
    dispose() {
      this.source = null;
      this.error = null;
    }
    get chunkManager() {
      return this.source.chunkManager;
    }
    get queueManager() {
      return this.source.chunkManager.queueManager;
    }
    downloadFailed(error) {
      this.error = error;
      this.queueManager.updateChunkState(this, ChunkState.FAILED);
    }
    downloadSucceeded() {
      this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);
    }
    freeSystemMemory() {
    }
    serialize(msg, _transfers) {
      msg["id"] = this.key;
      msg["source"] = this.source.rpcId;
      msg["new"] = true;
    }
    toString() {
      return this.key;
    }
    set state(newState) {
      if (newState === this.state_) {
        return;
      }
      const oldState = this.state_;
      this.state_ = newState;
      this.source.chunkStateChanged(this, oldState);
    }
    get state() {
      return this.state_;
    }
    set systemMemoryBytes(bytes) {
      updateChunkStatistics(this, -1);
      this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);
      this.systemMemoryBytes_ = bytes;
      this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);
      updateChunkStatistics(this, 1);
      this.chunkManager.queueManager.scheduleUpdate();
    }
    get systemMemoryBytes() {
      return this.systemMemoryBytes_;
    }
    set gpuMemoryBytes(bytes) {
      updateChunkStatistics(this, -1);
      this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);
      this.gpuMemoryBytes_ = bytes;
      this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);
      updateChunkStatistics(this, 1);
      this.chunkManager.queueManager.scheduleUpdate();
    }
    get gpuMemoryBytes() {
      return this.gpuMemoryBytes_;
    }
    get downloadSlots() {
      return this.downloadSlots_;
    }
    set downloadSlots(count) {
      if (count === this.downloadSlots_)
        return;
      updateChunkStatistics(this, -1);
      this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);
      this.downloadSlots_ = count;
      this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);
      updateChunkStatistics(this, 1);
      this.chunkManager.queueManager.scheduleUpdate();
    }
    registerListener(listener) {
      if (!this.source) {
        return false;
      }
      return this.source.registerChunkListener(this.key, listener);
    }
    unregisterListener(listener) {
      if (!this.source) {
        return false;
      }
      return this.source.unregisterChunkListener(this.key, listener);
    }
    static priorityLess(a, b) {
      return a.priority < b.priority;
    }
    static priorityGreater(a, b) {
      return a.priority > b.priority;
    }
  };
  var numSourceQueueLevels = 2;
  var ChunkSourceBase = class extends SharedObject {
    constructor(chunkManager) {
      super();
      this.chunkManager = chunkManager;
      this.listeners_ = new Map();
      this.chunks = new Map();
      this.freeChunks = new Array();
      this.statistics = new Float64Array(numChunkStatistics);
      this.sourceQueueLevel = 0;
      chunkManager.queueManager.sources.add(this);
    }
    disposed() {
      this.chunkManager.queueManager.sources.delete(this);
      super.disposed();
    }
    getNewChunk_(chunkType) {
      let freeChunks = this.freeChunks;
      let freeChunksLength = freeChunks.length;
      if (freeChunksLength > 0) {
        let chunk2 = freeChunks[freeChunksLength - 1];
        freeChunks.length = freeChunksLength - 1;
        chunk2.source = this;
        return chunk2;
      }
      let chunk = new chunkType();
      chunk.source = this;
      return chunk;
    }
    addChunk(chunk) {
      let { chunks } = this;
      if (chunks.size === 0) {
        this.addRef();
      }
      chunks.set(chunk.key, chunk);
      updateChunkStatistics(chunk, 1);
    }
    removeChunk(chunk) {
      let { chunks, freeChunks } = this;
      chunks.delete(chunk.key);
      chunk.dispose();
      freeChunks[freeChunks.length] = chunk;
      if (chunks.size === 0) {
        this.dispose();
      }
    }
    registerChunkListener(key, listener) {
      if (!this.listeners_.has(key)) {
        this.listeners_.set(key, [listener]);
      } else {
        this.listeners_.get(key).push(listener);
      }
      return true;
    }
    unregisterChunkListener(key, listener) {
      if (!this.listeners_.has(key)) {
        return false;
      }
      const keyListeners = this.listeners_.get(key);
      const idx = keyListeners.indexOf(listener);
      if (idx < 0) {
        return false;
      }
      keyListeners.splice(idx, 1);
      if (keyListeners.length === 0) {
        this.listeners_.delete(key);
      }
      return true;
    }
    chunkStateChanged(chunk, oldState) {
      if (!chunk.key) {
        return;
      }
      if (!this.listeners_.has(chunk.key)) {
        return;
      }
      for (const listener of [...this.listeners_.get(chunk.key)]) {
        listener.stateChanged(chunk, oldState);
      }
    }
  };
  function updateChunkStatistics(chunk, sign) {
    const { statistics } = chunk.source;
    const { systemMemoryBytes, gpuMemoryBytes } = chunk;
    const index = getChunkStateStatisticIndex(chunk.state, chunk.priorityTier);
    statistics[index * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks] += sign;
    statistics[index * numChunkMemoryStatistics + ChunkMemoryStatistics.systemMemoryBytes] += sign * systemMemoryBytes;
    statistics[index * numChunkMemoryStatistics + ChunkMemoryStatistics.gpuMemoryBytes] += sign * gpuMemoryBytes;
  }
  var ChunkSource = class extends ChunkSourceBase {
    constructor(rpc2, options) {
      const chunkManager = rpc2.get(options["chunkManager"]);
      super(chunkManager);
      initializeSharedObjectCounterpart(this, rpc2, options);
    }
  };
  function startChunkDownload(chunk) {
    const downloadCancellationToken = chunk.downloadCancellationToken = new CancellationTokenSource();
    const startTime = Date.now();
    chunk.source.download(chunk, downloadCancellationToken).then(() => {
      if (chunk.downloadCancellationToken === downloadCancellationToken) {
        chunk.downloadCancellationToken = void 0;
        const endTime = Date.now();
        const { statistics } = chunk.source;
        statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalTime)] += endTime - startTime;
        ++statistics[getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalChunks)];
        chunk.downloadSucceeded();
      }
    }, (error) => {
      if (chunk.downloadCancellationToken === downloadCancellationToken) {
        chunk.downloadCancellationToken = void 0;
        chunk.downloadFailed(error);
        console.log(`Error retrieving chunk ${chunk}: ${error}`);
      }
    });
  }
  function cancelChunkDownload(chunk) {
    const token = chunk.downloadCancellationToken;
    chunk.downloadCancellationToken = void 0;
    token.cancel();
  }
  var ChunkPriorityQueue = class {
    constructor(heapOperations, linkedListOperations) {
      this.heapOperations = heapOperations;
      this.linkedListOperations = linkedListOperations;
      this.heapRoots = [null, null];
      this.recentHead = new Chunk();
      linkedListOperations.initializeHead(this.recentHead);
    }
    add(chunk) {
      let priorityTier = chunk.priorityTier;
      if (priorityTier === ChunkPriorityTier.RECENT) {
        this.linkedListOperations.insertAfter(this.recentHead, chunk);
      } else {
        let { heapRoots } = this;
        heapRoots[priorityTier] = this.heapOperations.meld(heapRoots[priorityTier], chunk);
      }
    }
    *candidates() {
      if (this.heapOperations.compare === Chunk.priorityLess) {
        let { linkedListOperations, recentHead } = this;
        while (true) {
          let chunk = linkedListOperations.back(recentHead);
          if (chunk == null) {
            break;
          } else {
            yield chunk;
          }
        }
        let { heapRoots } = this;
        for (let tier = ChunkPriorityTier.LAST_ORDERED_TIER; tier >= ChunkPriorityTier.FIRST_ORDERED_TIER; --tier) {
          while (true) {
            let root = heapRoots[tier];
            if (root == null) {
              break;
            } else {
              yield root;
            }
          }
        }
      } else {
        let heapRoots = this.heapRoots;
        for (let tier = ChunkPriorityTier.FIRST_ORDERED_TIER; tier <= ChunkPriorityTier.LAST_ORDERED_TIER; ++tier) {
          while (true) {
            let root = heapRoots[tier];
            if (root == null) {
              break;
            } else {
              yield root;
            }
          }
        }
        let { linkedListOperations, recentHead } = this;
        while (true) {
          let chunk = linkedListOperations.front(recentHead);
          if (chunk == null) {
            break;
          } else {
            yield chunk;
          }
        }
      }
    }
    delete(chunk) {
      let priorityTier = chunk.priorityTier;
      if (priorityTier === ChunkPriorityTier.RECENT) {
        this.linkedListOperations.pop(chunk);
      } else {
        let heapRoots = this.heapRoots;
        heapRoots[priorityTier] = this.heapOperations.remove(heapRoots[priorityTier], chunk);
      }
    }
  };
  function makeChunkPriorityQueue0(compare) {
    return new ChunkPriorityQueue(new Implementation(compare), linked_list_0_default);
  }
  function makeChunkPriorityQueue1(compare) {
    return new ChunkPriorityQueue(new Implementation2(compare), linked_list_1_default);
  }
  function tryToFreeCapacity(size, capacity, priorityTier, priority, evictionCandidates, evict) {
    while (capacity.availableItems < 1 || capacity.availableSize < size) {
      let evictionCandidate = evictionCandidates.next().value;
      if (evictionCandidate === void 0) {
        return false;
      } else {
        let evictionTier = evictionCandidate.priorityTier;
        if (evictionTier < priorityTier || evictionTier === priorityTier && evictionCandidate.priority >= priority) {
          return false;
        }
        evict(evictionCandidate);
      }
    }
    return true;
  }
  var AvailableCapacity = class extends RefCounted {
    constructor(itemLimit, sizeLimit) {
      super();
      this.itemLimit = itemLimit;
      this.sizeLimit = sizeLimit;
      this.currentSize = 0;
      this.currentItems = 0;
      this.capacityChanged = new NullarySignal();
      this.registerDisposer(itemLimit.changed.add(this.capacityChanged.dispatch));
      this.registerDisposer(sizeLimit.changed.add(this.capacityChanged.dispatch));
    }
    adjust(items, size) {
      this.currentItems -= items;
      this.currentSize -= size;
    }
    get availableSize() {
      return this.sizeLimit.value - this.currentSize;
    }
    get availableItems() {
      return this.itemLimit.value - this.currentItems;
    }
    toString() {
      return `bytes=${this.currentSize}/${this.sizeLimit.value},items=${this.currentItems}/${this.itemLimit.value}`;
    }
  };
  var ChunkQueueManager = class extends SharedObjectCounterpart {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.sources = new Set();
      this.queuedDownloadPromotionQueue = [
        makeChunkPriorityQueue1(Chunk.priorityGreater),
        makeChunkPriorityQueue1(Chunk.priorityGreater)
      ];
      this.queuedComputePromotionQueue = makeChunkPriorityQueue1(Chunk.priorityGreater);
      this.downloadEvictionQueue = [
        makeChunkPriorityQueue1(Chunk.priorityLess),
        makeChunkPriorityQueue1(Chunk.priorityLess)
      ];
      this.computeEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);
      this.systemMemoryEvictionQueue = makeChunkPriorityQueue0(Chunk.priorityLess);
      this.gpuMemoryPromotionQueue = makeChunkPriorityQueue1(Chunk.priorityGreater);
      this.gpuMemoryEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);
      this.updatePending = null;
      this.gpuMemoryChanged = new NullarySignal();
      this.numQueued = 0;
      this.numFailed = 0;
      this.gpuMemoryGeneration = 0;
      const getCapacity = (capacity) => {
        const result = this.registerDisposer(new AvailableCapacity(rpc2.get(capacity["itemLimit"]), rpc2.get(capacity["sizeLimit"])));
        result.capacityChanged.add(() => this.scheduleUpdate());
        return result;
      };
      this.gpuMemoryCapacity = getCapacity(options["gpuMemoryCapacity"]);
      this.systemMemoryCapacity = getCapacity(options["systemMemoryCapacity"]);
      this.enablePrefetch = rpc2.get(options["enablePrefetch"]);
      this.downloadCapacity = [
        getCapacity(options["downloadCapacity"]),
        getCapacity(options["downloadCapacity"])
      ];
      this.computeCapacity = getCapacity(options["computeCapacity"]);
    }
    scheduleUpdate() {
      if (this.updatePending === null) {
        this.updatePending = setTimeout(this.process.bind(this), 0);
      }
    }
    *chunkQueuesForChunk(chunk) {
      switch (chunk.state) {
        case ChunkState.QUEUED:
          if (chunk.isComputational) {
            yield this.queuedComputePromotionQueue;
          } else {
            yield this.queuedDownloadPromotionQueue[chunk.source.sourceQueueLevel];
          }
          break;
        case ChunkState.DOWNLOADING:
          if (chunk.isComputational) {
            yield this.computeEvictionQueue;
          } else {
            yield this.downloadEvictionQueue[chunk.source.sourceQueueLevel];
            yield this.systemMemoryEvictionQueue;
          }
          break;
        case ChunkState.SYSTEM_MEMORY_WORKER:
        case ChunkState.SYSTEM_MEMORY:
          yield this.systemMemoryEvictionQueue;
          if (chunk.priorityTier !== ChunkPriorityTier.RECENT && !chunk.backendOnly && chunk.requestedToFrontend) {
            yield this.gpuMemoryPromotionQueue;
          }
          break;
        case ChunkState.GPU_MEMORY:
          yield this.systemMemoryEvictionQueue;
          yield this.gpuMemoryEvictionQueue;
          break;
      }
    }
    adjustCapacitiesForChunk(chunk, add7) {
      let factor = add7 ? -1 : 1;
      switch (chunk.state) {
        case ChunkState.FAILED:
          this.numFailed -= factor;
          break;
        case ChunkState.QUEUED:
          this.numQueued -= factor;
          break;
        case ChunkState.DOWNLOADING:
          (chunk.isComputational ? this.computeCapacity : this.downloadCapacity[chunk.source.sourceQueueLevel]).adjust(factor * chunk.downloadSlots, factor * chunk.systemMemoryBytes);
          this.systemMemoryCapacity.adjust(factor, factor * chunk.systemMemoryBytes);
          break;
        case ChunkState.SYSTEM_MEMORY:
        case ChunkState.SYSTEM_MEMORY_WORKER:
          this.systemMemoryCapacity.adjust(factor, factor * chunk.systemMemoryBytes);
          break;
        case ChunkState.GPU_MEMORY:
          this.systemMemoryCapacity.adjust(factor, factor * chunk.systemMemoryBytes);
          this.gpuMemoryCapacity.adjust(factor, factor * chunk.gpuMemoryBytes);
          break;
      }
    }
    removeChunkFromQueues_(chunk) {
      updateChunkStatistics(chunk, -1);
      for (let queue of this.chunkQueuesForChunk(chunk)) {
        queue.delete(chunk);
      }
    }
    addChunkToQueues_(chunk) {
      if (chunk.state === ChunkState.QUEUED && chunk.priorityTier === ChunkPriorityTier.RECENT) {
        let { source } = chunk;
        source.removeChunk(chunk);
        this.adjustCapacitiesForChunk(chunk, false);
        return false;
      } else {
        updateChunkStatistics(chunk, 1);
        for (let queue of this.chunkQueuesForChunk(chunk)) {
          queue.add(chunk);
        }
        return true;
      }
    }
    performChunkPriorityUpdate(chunk) {
      if (chunk.priorityTier === chunk.newPriorityTier && chunk.priority === chunk.newPriority) {
        chunk.newPriorityTier = ChunkPriorityTier.RECENT;
        chunk.newPriority = Number.NEGATIVE_INFINITY;
        return;
      }
      if (DEBUG_CHUNK_UPDATES) {
        console.log(`${chunk}: changed priority ${chunk.priorityTier}:${chunk.priority} -> ${chunk.newPriorityTier}:${chunk.newPriority}`);
      }
      this.removeChunkFromQueues_(chunk);
      chunk.updatePriorityProperties();
      if (chunk.state === ChunkState.NEW) {
        chunk.state = ChunkState.QUEUED;
        this.adjustCapacitiesForChunk(chunk, true);
      }
      this.addChunkToQueues_(chunk);
    }
    updateChunkState(chunk, newState) {
      if (newState === chunk.state) {
        return;
      }
      if (DEBUG_CHUNK_UPDATES) {
        console.log(`${chunk}: changed state ${ChunkState[chunk.state]} -> ${ChunkState[newState]}`);
      }
      this.adjustCapacitiesForChunk(chunk, false);
      this.removeChunkFromQueues_(chunk);
      chunk.state = newState;
      this.adjustCapacitiesForChunk(chunk, true);
      this.addChunkToQueues_(chunk);
      this.scheduleUpdate();
    }
    processGPUPromotions_() {
      let queueManager = this;
      function evictFromGPUMemory(chunk) {
        queueManager.freeChunkGPUMemory(chunk);
        chunk.source.chunkManager.queueManager.updateChunkState(chunk, ChunkState.SYSTEM_MEMORY);
      }
      let promotionCandidates = this.gpuMemoryPromotionQueue.candidates();
      let evictionCandidates = this.gpuMemoryEvictionQueue.candidates();
      let capacity = this.gpuMemoryCapacity;
      while (true) {
        let promotionCandidate = promotionCandidates.next().value;
        if (promotionCandidate === void 0) {
          break;
        } else {
          let priorityTier = promotionCandidate.priorityTier;
          let priority = promotionCandidate.priority;
          if (!tryToFreeCapacity(promotionCandidate.gpuMemoryBytes, capacity, priorityTier, priority, evictionCandidates, evictFromGPUMemory)) {
            break;
          }
          this.copyChunkToGPU(promotionCandidate);
          this.updateChunkState(promotionCandidate, ChunkState.GPU_MEMORY);
        }
      }
    }
    freeChunkGPUMemory(chunk) {
      ++this.gpuMemoryGeneration;
      this.rpc.invoke("Chunk.update", { "id": chunk.key, "state": ChunkState.SYSTEM_MEMORY, "source": chunk.source.rpcId });
    }
    freeChunkSystemMemory(chunk) {
      if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER) {
        chunk.freeSystemMemory();
      } else {
        this.rpc.invoke("Chunk.update", { "id": chunk.key, "state": ChunkState.EXPIRED, "source": chunk.source.rpcId });
      }
    }
    retrieveChunkData(chunk) {
      return this.rpc.promiseInvoke("Chunk.retrieve", { key: chunk.key, source: chunk.source.rpcId });
    }
    copyChunkToGPU(chunk) {
      ++this.gpuMemoryGeneration;
      let rpc2 = this.rpc;
      if (chunk.state === ChunkState.SYSTEM_MEMORY) {
        rpc2.invoke("Chunk.update", { "id": chunk.key, "source": chunk.source.rpcId, "state": ChunkState.GPU_MEMORY });
      } else {
        let msg = {};
        let transfers = [];
        chunk.serialize(msg, transfers);
        msg["state"] = ChunkState.GPU_MEMORY;
        rpc2.invoke("Chunk.update", msg, transfers);
      }
    }
    processQueuePromotions_() {
      let queueManager = this;
      const evict = (chunk) => {
        switch (chunk.state) {
          case ChunkState.DOWNLOADING:
            cancelChunkDownload(chunk);
            break;
          case ChunkState.GPU_MEMORY:
            queueManager.freeChunkGPUMemory(chunk);
          case ChunkState.SYSTEM_MEMORY_WORKER:
          case ChunkState.SYSTEM_MEMORY:
            queueManager.freeChunkSystemMemory(chunk);
            break;
        }
        this.updateChunkState(chunk, ChunkState.QUEUED);
      };
      const promotionLambda = (promotionCandidates, evictionCandidates, capacity) => {
        let systemMemoryEvictionCandidates = this.systemMemoryEvictionQueue.candidates();
        let systemMemoryCapacity = this.systemMemoryCapacity;
        while (true) {
          let promotionCandidateResult = promotionCandidates.next();
          if (promotionCandidateResult.done) {
            return;
          }
          let promotionCandidate = promotionCandidateResult.value;
          const size = 0;
          let priorityTier = promotionCandidate.priorityTier;
          let priority = promotionCandidate.priority;
          if (!tryToFreeCapacity(size, capacity, priorityTier, priority, evictionCandidates, evict)) {
            return;
          }
          if (!tryToFreeCapacity(size, systemMemoryCapacity, priorityTier, priority, systemMemoryEvictionCandidates, evict)) {
            return;
          }
          this.updateChunkState(promotionCandidate, ChunkState.DOWNLOADING);
          startChunkDownload(promotionCandidate);
        }
      };
      for (let sourceQueueLevel = 0; sourceQueueLevel < numSourceQueueLevels; ++sourceQueueLevel) {
        promotionLambda(this.queuedDownloadPromotionQueue[sourceQueueLevel].candidates(), this.downloadEvictionQueue[sourceQueueLevel].candidates(), this.downloadCapacity[sourceQueueLevel]);
      }
      promotionLambda(this.queuedComputePromotionQueue.candidates(), this.computeEvictionQueue.candidates(), this.computeCapacity);
    }
    process() {
      if (!this.updatePending) {
        return;
      }
      this.updatePending = null;
      const gpuMemoryGeneration = this.gpuMemoryGeneration;
      this.processGPUPromotions_();
      this.processQueuePromotions_();
      this.logStatistics();
      if (this.gpuMemoryGeneration !== gpuMemoryGeneration) {
        this.gpuMemoryChanged.dispatch();
      }
    }
    logStatistics() {
      if (DEBUG_CHUNK_UPDATES) {
        console.log(`[Chunk status] QUEUED: ${this.numQueued}, FAILED: ${this.numFailed}, DOWNLOAD: ${this.downloadCapacity}, MEM: ${this.systemMemoryCapacity}, GPU: ${this.gpuMemoryCapacity}`);
      }
    }
    invalidateSourceCache(source) {
      for (const chunk of source.chunks.values()) {
        switch (chunk.state) {
          case ChunkState.DOWNLOADING:
            cancelChunkDownload(chunk);
            break;
          case ChunkState.SYSTEM_MEMORY_WORKER:
            chunk.freeSystemMemory();
            break;
        }
        this.updateChunkState(chunk, ChunkState.QUEUED);
      }
      this.rpc.invoke("Chunk.update", { "source": source.rpcId });
      this.scheduleUpdate();
    }
  };
  ChunkQueueManager = __decorateClass([
    registerSharedObject(CHUNK_QUEUE_MANAGER_RPC_ID)
  ], ChunkQueueManager);
  var ChunkRenderLayerBackend = class extends SharedObjectCounterpart {
    constructor() {
      super(...arguments);
      this.chunkManagerGeneration = -1;
      this.numVisibleChunksNeeded = 0;
      this.numVisibleChunksAvailable = 0;
      this.numPrefetchChunksNeeded = 0;
      this.numPrefetchChunksAvailable = 0;
    }
  };
  var LAYER_CHUNK_STATISTICS_INTERVAL = 200;
  var ChunkManager = class extends SharedObjectCounterpart {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.existingTierChunks = [];
      this.newTierChunks = [];
      this.updatePending = null;
      this.recomputeChunkPriorities = new NullarySignal();
      this.recomputeChunkPrioritiesLate = new NullarySignal();
      this.memoize = new StringMemoize();
      this.layers = [];
      this.sendLayerChunkStatistics = this.registerCancellable((0, import_throttle.default)(() => {
        this.rpc.invoke(CHUNK_LAYER_STATISTICS_RPC_ID, {
          id: this.rpcId,
          layers: this.layers.map((layer) => ({
            id: layer.rpcId,
            numVisibleChunksAvailable: layer.numVisibleChunksAvailable,
            numVisibleChunksNeeded: layer.numVisibleChunksNeeded,
            numPrefetchChunksAvailable: layer.numPrefetchChunksAvailable,
            numPrefetchChunksNeeded: layer.numPrefetchChunksNeeded
          }))
        });
      }, LAYER_CHUNK_STATISTICS_INTERVAL));
      this.queueManager = rpc2.get(options["chunkQueueManager"]).addRef();
      this.registerDisposer(this.queueManager.gpuMemoryChanged.add(this.registerCancellable((0, import_throttle.default)(() => this.scheduleUpdateChunkPriorities(), LAYER_CHUNK_STATISTICS_INTERVAL, { leading: false, trailing: true }))));
      for (let tier = ChunkPriorityTier.FIRST_TIER; tier <= ChunkPriorityTier.LAST_TIER; ++tier) {
        if (tier === ChunkPriorityTier.RECENT) {
          continue;
        }
        this.existingTierChunks[tier] = [];
      }
    }
    scheduleUpdateChunkPriorities() {
      if (this.updatePending === null) {
        this.updatePending = setTimeout(this.recomputeChunkPriorities_.bind(this), 0);
      }
    }
    registerLayer(layer) {
      const generation = this.recomputeChunkPriorities.count;
      if (layer.chunkManagerGeneration !== generation) {
        layer.chunkManagerGeneration = generation;
        this.layers.push(layer);
        layer.numVisibleChunksAvailable = 0;
        layer.numVisibleChunksNeeded = 0;
        layer.numPrefetchChunksAvailable = 0;
        layer.numPrefetchChunksNeeded = 0;
      }
    }
    recomputeChunkPriorities_() {
      this.updatePending = null;
      this.layers.length = 0;
      this.recomputeChunkPriorities.dispatch();
      this.recomputeChunkPrioritiesLate.dispatch();
      this.updateQueueState([ChunkPriorityTier.VISIBLE, ChunkPriorityTier.PREFETCH]);
      this.sendLayerChunkStatistics();
    }
    requestChunk(chunk, tier, priority, toFrontend = true) {
      if (!Number.isFinite(priority)) {
        debugger;
        return;
      }
      if (tier === ChunkPriorityTier.RECENT) {
        throw new Error("Not going to request a chunk with the RECENT tier");
      }
      chunk.newlyRequestedToFrontend = chunk.newlyRequestedToFrontend || toFrontend;
      if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {
        this.newTierChunks.push(chunk);
      }
      const newPriorityTier = chunk.newPriorityTier;
      if (tier < newPriorityTier || tier === newPriorityTier && priority > chunk.newPriority) {
        chunk.newPriorityTier = tier;
        chunk.newPriority = priority;
      }
    }
    updateQueueState(tiers) {
      let existingTierChunks = this.existingTierChunks;
      let queueManager = this.queueManager;
      for (let tier of tiers) {
        let chunks = existingTierChunks[tier];
        if (DEBUG_CHUNK_UPDATES) {
          console.log(`existingTierChunks[${ChunkPriorityTier[tier]}].length=${chunks.length}`);
        }
        for (let chunk of chunks) {
          if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {
            queueManager.performChunkPriorityUpdate(chunk);
          }
        }
        chunks.length = 0;
      }
      let newTierChunks = this.newTierChunks;
      for (let chunk of newTierChunks) {
        queueManager.performChunkPriorityUpdate(chunk);
        existingTierChunks[chunk.priorityTier].push(chunk);
      }
      if (DEBUG_CHUNK_UPDATES) {
        console.log(`updateQueueState: newTierChunks.length = ${newTierChunks.length}`);
      }
      newTierChunks.length = 0;
      this.queueManager.scheduleUpdate();
    }
  };
  ChunkManager = __decorateClass([
    registerSharedObject(CHUNK_MANAGER_RPC_ID)
  ], ChunkManager);
  function WithParameters(Base, parametersConstructor) {
    let C = class extends Base {
      constructor(...args) {
        super(...args);
        const options = args[1];
        this.parameters = options["parameters"];
      }
    };
    C = __decorateClass([
      registerSharedObjectOwner(parametersConstructor.RPC_ID)
    ], C);
    return C;
  }
  function withChunkManager(Base) {
    return class extends Base {
      constructor(...args) {
        super(...args);
        const rpc2 = args[0];
        const options = args[1];
        this.chunkManager = rpc2.get(options["chunkManager"]);
      }
    };
  }
  registerRPC(CHUNK_SOURCE_INVALIDATE_RPC_ID, function(x) {
    const source = this.get(x["id"]);
    source.chunkManager.queueManager.invalidateSourceCache(source);
  });
  registerPromiseRPC(REQUEST_CHUNK_STATISTICS_RPC_ID, function(x) {
    const queue = this.get(x.queue);
    const results = new Map();
    for (const source of queue.sources) {
      results.set(source.rpcId, source.statistics);
    }
    return Promise.resolve({ value: results });
  });

  // src/neuroglancer/render_layer_common.ts
  var RENDERED_VIEW_ADD_LAYER_RPC_ID = "rendered_view.addLayer";
  var RENDERED_VIEW_REMOVE_LAYER_RPC_ID = "rendered_view.removeLayer";
  var PROJECTION_PARAMETERS_RPC_ID = "SharedProjectionParameters";
  var PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID = "SharedProjectionParameters.changed";

  // src/neuroglancer/render_layer_backend.ts
  var RenderLayerBackendAttachment = class extends RefCounted {
    constructor(view) {
      super();
      this.view = view;
      this.state = void 0;
    }
  };
  var RenderLayerBackend = class extends ChunkRenderLayerBackend {
    constructor() {
      super(...arguments);
      this.attachments = new Map();
    }
    attach(attachment) {
      attachment;
    }
  };
  registerRPC(RENDERED_VIEW_ADD_LAYER_RPC_ID, function(x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = new RenderLayerBackendAttachment(view);
    layer.attachments.set(view, attachment);
    layer.attach(attachment);
  });
  registerRPC(RENDERED_VIEW_REMOVE_LAYER_RPC_ID, function(x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    layer.attachments.delete(view);
    attachment.dispose();
  });
  var SharedProjectionParametersBackend = class extends SharedObjectCounterpart {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.changed = new Signal();
      this.value = options.value;
      this.oldValue = Object.assign({}, this.value);
    }
  };
  SharedProjectionParametersBackend = __decorateClass([
    registerSharedObject(PROJECTION_PARAMETERS_RPC_ID)
  ], SharedProjectionParametersBackend);
  registerRPC(PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID, function(x) {
    const obj = this.get(x.id);
    const { value, oldValue } = obj;
    Object.assign(oldValue, value);
    Object.assign(value, x.value);
    obj.changed.dispatch(oldValue, value);
  });

  // src/neuroglancer/trackable_value.ts
  var import_debounce = __toModule(require_debounce());
  var WatchableValue = class {
    constructor(value_) {
      this.value_ = value_;
      this.changed = new NullarySignal();
    }
    get value() {
      return this.value_;
    }
    set value(newValue) {
      if (newValue !== this.value_) {
        this.value_ = newValue;
        this.changed.dispatch();
      }
    }
  };
  var WatchableSet = class {
    constructor(values) {
      this.changed = new Signal();
      if (values === void 0) {
        this.values = new Set();
      } else {
        this.values = new Set(values);
      }
    }
    add(x) {
      const { values } = this;
      if (!values.has(x)) {
        values.add(x);
        this.changed.dispatch(x, true);
      }
      return this;
    }
    delete(x) {
      const { values } = this;
      if (values.delete(x)) {
        this.changed.dispatch(x, false);
        return true;
      }
      return false;
    }
    has(x) {
      return this.values.has(x);
    }
    get size() {
      return this.values.size;
    }
    [Symbol.iterator]() {
      return this.values[Symbol.iterator]();
    }
    clear() {
      const { values } = this;
      if (values.size > 0) {
        values.clear();
        this.changed.dispatch(null, false);
      }
    }
  };
  function registerNested(f, ...watchables) {
    let values = watchables.map((w) => w.value);
    const count = watchables.length;
    let context = new RefCounted();
    let result = f(context, ...values);
    const handleChange = (0, import_debounce.default)(() => {
      let changed = false;
      for (let i = 0; i < count; ++i) {
        const watchable = watchables[i];
        const value = watchable.value;
        if (values[i] !== value) {
          values[i] = value;
          changed = true;
        }
      }
      if (!changed)
        return;
      context.dispose();
      context = new RefCounted();
      result = f(context, ...values);
    }, 0);
    const signalDisposers = watchables.map((w) => w.changed.add(handleChange));
    return {
      flush() {
        handleChange.flush();
      },
      dispose() {
        handleChange.cancel();
        invokeDisposers(signalDisposers);
        context.dispose();
      },
      get value() {
        handleChange.flush();
        return result;
      }
    };
  }

  // src/neuroglancer/util/vector.ts
  function add6(out, a, b) {
    const rank = out.length;
    for (let i = 0; i < rank; ++i) {
      out[i] = a[i] + b[i];
    }
    return out;
  }
  function multiply6(out, a, b) {
    const rank = out.length;
    for (let i = 0; i < rank; ++i) {
      out[i] = a[i] * b[i];
    }
    return out;
  }
  function prod(array) {
    let result = 1;
    for (let i = 0, length4 = array.length; i < length4; ++i) {
      result *= array[i];
    }
    return result;
  }
  function min3(out, a, b) {
    const rank = out.length;
    for (let i = 0; i < rank; ++i) {
      out[i] = Math.min(a[i], b[i]);
    }
    return out;
  }
  function max3(out, a, b) {
    const rank = out.length;
    for (let i = 0; i < rank; ++i) {
      out[i] = Math.max(a[i], b[i]);
    }
    return out;
  }
  var kEmptyFloat32Vec = new Float32Array(0);
  var kEmptyFloat64Vec = new Float64Array(0);
  var kFloat64Vec3Of1 = Float64Array.of(1, 1, 1);

  // src/neuroglancer/util/matrix.ts
  function identity4(a, lda, n) {
    for (let i = 0; i < n; ++i) {
      const start = lda * i;
      a.fill(0, start, start + n);
      a[start + i] = 1;
    }
    return a;
  }
  function createIdentity(c, rows, cols = rows) {
    return identity4(new c(rows * cols), rows, Math.min(rows, cols));
  }
  function copy6(b, ldb, a, lda, m, n) {
    for (let col = 0; col < n; ++col) {
      const aOff = col * lda;
      const bOff = col * ldb;
      for (let row = 0; row < m; ++row) {
        b[bOff + row] = a[aOff + row];
      }
    }
    return b;
  }
  var pivots;
  function inverseInplace(a, lda, n) {
    let determinant3 = 1;
    if (pivots === void 0 || pivots.length < n) {
      pivots = new Uint32Array(n);
    }
    for (let i = 0; i < n; ++i) {
      pivots[i] = i;
    }
    for (let k = 0; k < n; ++k) {
      const kColOff = lda * k;
      let pivotRow = k;
      {
        let bestPivot = Math.abs(a[kColOff + k]);
        for (let row = k + 1; row < n; ++row) {
          const mag = Math.abs(a[kColOff + row]);
          if (mag > bestPivot) {
            bestPivot = mag;
            pivotRow = row;
          }
        }
      }
      if (k !== pivotRow) {
        determinant3 *= -1;
        for (let col = 0; col < n; ++col) {
          const off = lda * col;
          const temp = a[off + k];
          a[off + k] = a[off + pivotRow];
          a[off + pivotRow] = temp;
        }
        {
          const tempPivot = pivots[k];
          pivots[k] = pivots[pivotRow];
          pivots[pivotRow] = tempPivot;
        }
      }
      const pivotValue = a[kColOff + k];
      const pivotInv = 1 / pivotValue;
      determinant3 *= pivotValue;
      for (let j = 0; j < n; ++j) {
        a[lda * j + k] *= pivotInv;
      }
      a[kColOff + k] = pivotInv;
      for (let row = 0; row < n; ++row) {
        if (row === k)
          continue;
        const factor = -a[lda * k + row];
        for (let j = 0; j < n; ++j) {
          const jColOff = lda * j;
          a[jColOff + row] += factor * a[jColOff + k];
        }
        a[lda * k + row] = factor * pivotInv;
      }
    }
    for (let col = 0; col < n; ++col) {
      let targetCol = pivots[col];
      while (targetCol !== col) {
        const colOff = lda * col;
        const targetColOff = lda * targetCol;
        for (let i = 0; i < n; ++i) {
          const off1 = colOff + i;
          const off2 = targetColOff + i;
          const temp2 = a[off1];
          a[off1] = a[off2];
          a[off2] = temp2;
        }
        const temp = pivots[col] = pivots[targetCol];
        pivots[targetCol] = targetCol;
        targetCol = temp;
      }
    }
    return determinant3;
  }
  function inverse3(b, ldb, a, lda, n) {
    copy6(b, ldb, a, lda, n, n);
    return inverseInplace(b, ldb, n);
  }

  // src/neuroglancer/util/si_units.ts
  var preferredSiPrefixes = [
    { prefix: "Y", exponent: 24, longPrefix: "yotta" },
    { prefix: "Z", exponent: 21, longPrefix: "zetta" },
    { prefix: "E", exponent: 18, longPrefix: "exa" },
    { prefix: "P", exponent: 15, longPrefix: "peta" },
    { prefix: "T", exponent: 12, longPrefix: "tera" },
    { prefix: "G", exponent: 9, longPrefix: "giga" },
    { prefix: "M", exponent: 6, longPrefix: "mega" },
    { prefix: "k", exponent: 3, longPrefix: "kilo" },
    { prefix: "", exponent: 0, longPrefix: "" },
    { prefix: "m", exponent: -3, longPrefix: "milli" },
    { prefix: "\xB5", exponent: -6, longPrefix: "micro" },
    { prefix: "n", exponent: -9, longPrefix: "nano" },
    { prefix: "p", exponent: -12, longPrefix: "pico" },
    { prefix: "f", exponent: -15, longPrefix: "femto" },
    { prefix: "a", exponent: -18, longPrefix: "atto" },
    { prefix: "z", exponent: -21, longPrefix: "zepto" },
    { prefix: "y", exponent: -24, longPrefix: "yocto" }
  ];
  var allSiPrefixes = [
    ...preferredSiPrefixes,
    { prefix: "h", exponent: 2, longPrefix: "hecto" },
    { prefix: "da", exponent: 1, longPrefix: "deca" },
    { prefix: "d", exponent: -1, longPrefix: "deci" },
    { prefix: "c", exponent: -2, longPrefix: "centi" }
  ];
  var siPrefixesWithAlternatives = [
    { prefix: "u", exponent: -6 },
    ...allSiPrefixes
  ];
  var supportedUnits = new Map();
  supportedUnits.set("", { unit: "", exponent: 0 });
  var exponentToPrefix = new Map();
  for (const { prefix, exponent } of siPrefixesWithAlternatives) {
    exponentToPrefix.set(exponent, prefix);
    for (const unit of ["m", "s", "Hz", "rad/s"]) {
      supportedUnits.set(`${prefix}${unit}`, { unit, exponent });
    }
  }

  // src/neuroglancer/coordinate_transform.ts
  function makeCoordinateSpace(space) {
    const { names, units, scales } = space;
    const {
      valid = true,
      rank = names.length,
      timestamps = names.map(() => Number.NEGATIVE_INFINITY),
      ids = names.map((_, i) => -i),
      boundingBoxes = []
    } = space;
    const { coordinateArrays = new Array(rank) } = space;
    const { bounds = computeCombinedBounds(boundingBoxes, rank) } = space;
    return {
      valid,
      rank,
      names,
      timestamps,
      ids,
      units,
      scales,
      boundingBoxes,
      bounds,
      coordinateArrays
    };
  }
  var emptyInvalidCoordinateSpace = makeCoordinateSpace({
    valid: false,
    names: [],
    units: [],
    scales: kEmptyFloat64Vec,
    boundingBoxes: []
  });
  var emptyValidCoordinateSpace = makeCoordinateSpace({
    valid: true,
    names: [],
    units: [],
    scales: kEmptyFloat64Vec,
    boundingBoxes: []
  });
  function computeCombinedLowerUpperBound(boundingBox, outputDimension, outputRank) {
    const {
      box: { lowerBounds: baseLowerBounds, upperBounds: baseUpperBounds },
      transform
    } = boundingBox;
    const inputRank = baseLowerBounds.length;
    const stride = outputRank;
    const offset = transform[stride * inputRank + outputDimension];
    let targetLower = offset, targetUpper = offset;
    let hasCoefficient = false;
    for (let inputDim = 0; inputDim < inputRank; ++inputDim) {
      let c = transform[stride * inputDim + outputDimension];
      if (c === 0)
        continue;
      const lower = c * baseLowerBounds[inputDim];
      const upper = c * baseUpperBounds[inputDim];
      targetLower += Math.min(lower, upper);
      targetUpper += Math.max(lower, upper);
      hasCoefficient = true;
    }
    if (!hasCoefficient)
      return void 0;
    return { lower: targetLower, upper: targetUpper };
  }
  function computeCombinedBounds(boundingBoxes, outputRank) {
    const lowerBounds = new Float64Array(outputRank);
    const upperBounds = new Float64Array(outputRank);
    lowerBounds.fill(Number.NEGATIVE_INFINITY);
    upperBounds.fill(Number.POSITIVE_INFINITY);
    for (const boundingBox of boundingBoxes) {
      for (let outputDim = 0; outputDim < outputRank; ++outputDim) {
        const result = computeCombinedLowerUpperBound(boundingBox, outputDim, outputRank);
        if (result === void 0)
          continue;
        const { lower: targetLower, upper: targetUpper } = result;
        lowerBounds[outputDim] = lowerBounds[outputDim] === Number.NEGATIVE_INFINITY ? targetLower : Math.min(lowerBounds[outputDim], targetLower);
        upperBounds[outputDim] = upperBounds[outputDim] === Number.POSITIVE_INFINITY ? targetUpper : Math.max(upperBounds[outputDim], targetUpper);
      }
    }
    return { lowerBounds, upperBounds };
  }

  // src/neuroglancer/render_coordinate_transform.ts
  var zeroRankChannelSpace = {
    channelCoordinateSpace: emptyValidCoordinateSpace,
    shape: new Uint32Array(0),
    numChannels: 1,
    coordinates: new Uint32Array(0)
  };
  function getChunkPositionFromCombinedGlobalLocalPositions(chunkPosition, globalPosition, localPosition, layerRank, combinedGlobalLocalToChunkTransform) {
    const globalRank = globalPosition.length;
    const localRank = localPosition.length;
    const rank = chunkPosition.length;
    let valid = true;
    for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {
      let off = chunkDim;
      let sum = 0;
      for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
        sum += combinedGlobalLocalToChunkTransform[off + globalDim * layerRank] * globalPosition[globalDim];
      }
      off += globalRank * layerRank;
      for (let localDim = 0; localDim < localRank; ++localDim) {
        sum += combinedGlobalLocalToChunkTransform[off + localDim * layerRank] * localPosition[localDim];
      }
      sum += combinedGlobalLocalToChunkTransform[off + localRank * layerRank];
      if (chunkDim < rank) {
        chunkPosition[chunkDim] = sum;
      } else {
        if (sum < 0 || sum >= 1) {
          valid = false;
        }
      }
    }
    return valid;
  }
  function get3dModelToDisplaySpaceMatrix(out, displayDimensionRenderInfo, transform) {
    out.fill(0);
    out[15] = 1;
    let fullRank = true;
    const { displayDimensionIndices } = displayDimensionRenderInfo;
    const { globalToRenderLayerDimensions, modelToRenderLayerTransform } = transform;
    const layerRank = transform.rank;
    for (let displayDim = 0; displayDim < 3; ++displayDim) {
      const globalDim = displayDimensionIndices[displayDim];
      if (globalDim === -1) {
        fullRank = false;
        continue;
      }
      const layerDim = globalToRenderLayerDimensions[globalDim];
      if (layerDim === -1) {
        fullRank = false;
        continue;
      }
      out[displayDim + 12] = modelToRenderLayerTransform[layerDim + layerRank * (layerRank + 1)];
      for (let modelDim = 0; modelDim < 3; ++modelDim) {
        out[displayDim + 4 * modelDim] = modelToRenderLayerTransform[layerDim + (layerRank + 1) * modelDim];
      }
    }
    if (!fullRank) {
      const { globalDimensionNames } = displayDimensionRenderInfo;
      const displayDimDesc = Array.from(displayDimensionIndices.filter((i) => i !== -1), (i) => globalDimensionNames[i]).join(",\xA0");
      throw new Error(`Transform from model dimensions (${transform.modelDimensionNames.join(",\xA0")}) to display dimensions (${displayDimDesc}) does not have full rank`);
    }
  }

  // src/neuroglancer/sliceview/chunk_layout.ts
  var ChunkLayout = class {
    constructor(size, transform, finiteRank) {
      this.size = vec3_exports.clone(size);
      this.transform = mat4_exports.clone(transform);
      this.finiteRank = finiteRank;
      const invTransform = mat4_exports.create();
      const det = inverse3(invTransform, 4, transform, 4, 4);
      if (det === 0) {
        throw new Error("Transform is singular");
      }
      this.invTransform = invTransform;
      this.detTransform = det;
    }
    toObject() {
      return { size: this.size, transform: this.transform, finiteRank: this.finiteRank };
    }
    static fromObject(msg) {
      return new ChunkLayout(msg.size, msg.transform, msg.finiteRank);
    }
    globalToLocalSpatial(out, globalSpatial) {
      return vec3_exports.transformMat4(out, globalSpatial, this.invTransform);
    }
    localSpatialVectorToGlobal(out, localVector) {
      return transformVectorByMat4(out, localVector, this.transform);
    }
    globalToLocalNormal(globalNormal, localNormal) {
      return transformVectorByMat4Transpose(globalNormal, localNormal, this.transform);
    }
  };

  // src/neuroglancer/util/data_type.ts
  var DataType;
  (function(DataType3) {
    DataType3[DataType3["UINT8"] = 0] = "UINT8";
    DataType3[DataType3["INT8"] = 1] = "INT8";
    DataType3[DataType3["UINT16"] = 2] = "UINT16";
    DataType3[DataType3["INT16"] = 3] = "INT16";
    DataType3[DataType3["UINT32"] = 4] = "UINT32";
    DataType3[DataType3["INT32"] = 5] = "INT32";
    DataType3[DataType3["UINT64"] = 6] = "UINT64";
    DataType3[DataType3["FLOAT32"] = 7] = "FLOAT32";
  })(DataType || (DataType = {}));
  var DATA_TYPE_SIGNED = {
    [0]: false,
    [1]: true,
    [2]: false,
    [3]: true,
    [4]: false,
    [5]: true,
    [6]: false,
    [7]: void 0
  };
  var DATA_TYPE_BYTES = {
    [0]: 1,
    [1]: 1,
    [2]: 2,
    [3]: 2,
    [4]: 4,
    [5]: 4,
    [6]: 8,
    [7]: 4
  };
  var DATA_TYPE_ARRAY_CONSTRUCTOR = {
    [0]: Uint8Array,
    [1]: Int8Array,
    [2]: Uint16Array,
    [3]: Int16Array,
    [4]: Uint32Array,
    [5]: Int32Array,
    [6]: Uint32Array,
    [7]: Float32Array
  };
  var DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT = {
    [0]: 1,
    [1]: 1,
    [2]: 1,
    [3]: 1,
    [4]: 1,
    [5]: 1,
    [6]: 2,
    [7]: 1
  };
  function makeDataTypeArrayView(dataType, buffer, byteOffset = 0, byteLength = buffer.byteLength) {
    const bytesPerElement = DATA_TYPE_BYTES[dataType];
    const javascriptElementsPerArrayElement = DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT[dataType];
    return new DATA_TYPE_ARRAY_CONSTRUCTOR[dataType](buffer, byteOffset, byteLength / bytesPerElement * javascriptElementsPerArrayElement);
  }

  // src/neuroglancer/sliceview/base.ts
  var DEBUG_VISIBLE_SOURCES = false;
  var DEBUG_CHUNK_VISIBILITY = false;
  var tempMat4 = mat4_exports.create();
  function estimateSliceAreaPerChunk(chunkLayout, viewMatrix) {
    let viewZProjection = 0;
    let chunkVolume = Math.abs(chunkLayout.detTransform);
    const { transform, size } = chunkLayout;
    for (let i = 0; i < 3; ++i) {
      let sum = 0;
      for (let j = 0; j < 3; ++j) {
        sum += viewMatrix[j * 4 + 2] * transform[4 * i + j];
      }
      const s = size[i];
      viewZProjection += Math.abs(sum) * s;
      chunkVolume *= s;
    }
    return chunkVolume / viewZProjection;
  }
  function updateFixedCurPositionInChunks(tsource, globalPosition, localPosition) {
    const { curPositionInChunks, fixedPositionWithinChunk } = tsource;
    const { nonDisplayLowerClipBound, nonDisplayUpperClipBound } = tsource;
    const { rank, chunkDataSize } = tsource.source.spec;
    if (!getChunkPositionFromCombinedGlobalLocalPositions(curPositionInChunks, globalPosition, localPosition, tsource.layerRank, tsource.fixedLayerToChunkTransform)) {
      return false;
    }
    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {
      const x = curPositionInChunks[chunkDim];
      if (x < nonDisplayLowerClipBound[chunkDim] || x >= nonDisplayUpperClipBound[chunkDim]) {
        if (DEBUG_VISIBLE_SOURCES) {
          console.log("excluding source", tsource, `because of chunkDim=${chunkDim}, sum=${x}`, nonDisplayLowerClipBound, nonDisplayUpperClipBound, tsource.fixedLayerToChunkTransform);
        }
        return false;
      }
      const chunkSize = chunkDataSize[chunkDim];
      const chunk = curPositionInChunks[chunkDim] = Math.floor(x / chunkSize);
      fixedPositionWithinChunk[chunkDim] = x - chunk * chunkSize;
    }
    return true;
  }
  function pickBestAlternativeSource(viewMatrix, alternatives) {
    let numAlternatives = alternatives.length;
    let bestAlternativeIndex = 0;
    if (DEBUG_VISIBLE_SOURCES) {
      console.log(alternatives);
    }
    if (numAlternatives > 1) {
      let bestSliceArea = 0;
      for (let alternativeIndex = 0; alternativeIndex < numAlternatives; ++alternativeIndex) {
        let alternative = alternatives[alternativeIndex];
        const { chunkLayout } = alternative;
        let sliceArea = estimateSliceAreaPerChunk(chunkLayout, viewMatrix);
        if (DEBUG_VISIBLE_SOURCES) {
          console.log(`chunksize = ${chunkLayout.size}, sliceArea = ${sliceArea}`);
        }
        if (sliceArea > bestSliceArea) {
          bestSliceArea = sliceArea;
          bestAlternativeIndex = alternativeIndex;
        }
      }
    }
    return bestAlternativeIndex;
  }
  var tempChunkLayout = new ChunkLayout(vec3_exports.create(), mat4_exports.create(), 0);
  function visibleSourcesInvalidated(oldValue, newValue) {
    if (oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo)
      return true;
    if (oldValue.pixelSize !== newValue.pixelSize)
      return true;
    const { viewMatrix: oldViewMatrix } = oldValue;
    const { viewMatrix: newViewMatrix } = newValue;
    for (let i = 0; i < 12; ++i) {
      if (oldViewMatrix[i] !== newViewMatrix[i])
        return true;
    }
    return false;
  }
  var SliceViewBase = class extends SharedObject {
    constructor(projectionParameters) {
      super();
      this.projectionParameters = projectionParameters;
      this.visibleLayers = new Map();
      this.visibleSourcesStale = true;
      this.registerDisposer(projectionParameters.changed.add((oldValue, newValue) => {
        if (visibleSourcesInvalidated(oldValue, newValue)) {
          this.invalidateVisibleSources();
        }
        this.invalidateVisibleChunks();
      }));
    }
    invalidateVisibleSources() {
      this.visibleSourcesStale = true;
    }
    invalidateVisibleChunks() {
    }
    updateVisibleSources() {
      if (!this.visibleSourcesStale) {
        return;
      }
      this.visibleSourcesStale = false;
      const curDisplayDimensionRenderInfo = this.projectionParameters.value.displayDimensionRenderInfo;
      const { visibleLayers } = this;
      for (const [renderLayer, { allSources, visibleSources, displayDimensionRenderInfo }] of visibleLayers) {
        visibleSources.length = 0;
        if (displayDimensionRenderInfo !== curDisplayDimensionRenderInfo || allSources.length === 0) {
          continue;
        }
        const preferredOrientationIndex = pickBestAlternativeSource(this.projectionParameters.value.viewMatrix, allSources.map((x) => x[0]));
        const sources = allSources[preferredOrientationIndex];
        for (const source of renderLayer.filterVisibleSources(this, sources)) {
          visibleSources.push(source);
        }
        visibleSources.reverse();
        if (DEBUG_VISIBLE_SOURCES) {
          console.log("visible sources chosen", visibleSources);
        }
      }
    }
  };
  var ChunkLayoutPreference;
  (function(ChunkLayoutPreference2) {
    ChunkLayoutPreference2[ChunkLayoutPreference2["ISOTROPIC"] = 0] = "ISOTROPIC";
    ChunkLayoutPreference2[ChunkLayoutPreference2["FLAT"] = 1] = "FLAT";
  })(ChunkLayoutPreference || (ChunkLayoutPreference = {}));
  function* filterVisibleSources(sliceView, renderLayer, sources) {
    const pixelSize = sliceView.projectionParameters.value.pixelSize * 1.1;
    const smallestVoxelSize = sources[0].effectiveVoxelSize;
    const renderScaleTarget = renderLayer.renderScaleTarget.value;
    const canImproveOnVoxelSize = (voxelSize) => {
      const targetSize = pixelSize * renderScaleTarget;
      for (let i = 0; i < 3; ++i) {
        const size = voxelSize[i];
        if (size > targetSize && size > 1.01 * smallestVoxelSize[i]) {
          return true;
        }
      }
      return false;
    };
    const improvesOnPrevVoxelSize = (voxelSize, prevVoxelSize2) => {
      const targetSize = pixelSize * renderScaleTarget;
      for (let i = 0; i < 3; ++i) {
        const size = voxelSize[i];
        const prevSize = prevVoxelSize2[i];
        if (Math.abs(targetSize - size) < Math.abs(targetSize - prevSize) && size < 1.01 * prevSize) {
          return true;
        }
      }
      return false;
    };
    let scaleIndex = sources.length - 1;
    let prevVoxelSize;
    while (true) {
      const transformedSource = sources[scaleIndex];
      if (prevVoxelSize !== void 0 && !improvesOnPrevVoxelSize(transformedSource.effectiveVoxelSize, prevVoxelSize)) {
        break;
      }
      yield transformedSource;
      if (scaleIndex === 0 || !canImproveOnVoxelSize(transformedSource.effectiveVoxelSize)) {
        break;
      }
      prevVoxelSize = transformedSource.effectiveVoxelSize;
      --scaleIndex;
    }
  }
  var SLICEVIEW_RPC_ID = "SliceView";
  var SLICEVIEW_RENDERLAYER_RPC_ID = "sliceview/RenderLayer";
  var SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID = "SliceView.addVisibleLayer";
  var SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID = "SliceView.removeVisibleLayer";
  var tempVisibleVolumetricChunkLower = new Float32Array(3);
  var tempVisibleVolumetricChunkUpper = new Float32Array(3);
  var tempVisibleVolumetricModelViewProjection = mat4_exports.create();
  var tempVisibleVolumetricClippingPlanes = new Float32Array(24);
  function forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, predicate) {
    const lower = tempVisibleVolumetricChunkLower;
    const upper = tempVisibleVolumetricChunkUpper;
    const { lowerChunkDisplayBound, upperChunkDisplayBound } = transformedSource;
    for (let i = 0; i < 3; ++i) {
      lower[i] = Math.max(lower[i], lowerChunkDisplayBound[i]);
      upper[i] = Math.min(upper[i], upperChunkDisplayBound[i]);
    }
    const { curPositionInChunks, chunkDisplayDimensionIndices } = transformedSource;
    function recurse() {
      if (!predicate(lower[0], lower[1], lower[2], upper[0], upper[1], upper[2], clippingPlanes)) {
        return;
      }
      let splitDim = 0;
      let splitSize = Math.max(0, upper[0] - lower[0]);
      let volume = splitSize;
      for (let i = 1; i < 3; ++i) {
        const size = Math.max(0, upper[i] - lower[i]);
        volume *= size;
        if (size > splitSize) {
          splitSize = size;
          splitDim = i;
        }
      }
      if (volume === 0)
        return;
      if (volume === 1) {
        curPositionInChunks[chunkDisplayDimensionIndices[0]] = lower[0];
        curPositionInChunks[chunkDisplayDimensionIndices[1]] = lower[1];
        curPositionInChunks[chunkDisplayDimensionIndices[2]] = lower[2];
        callback(lower, clippingPlanes);
        return;
      }
      const prevLower = lower[splitDim];
      const prevUpper = upper[splitDim];
      const splitPoint = Math.floor(0.5 * (prevLower + prevUpper));
      upper[splitDim] = splitPoint;
      recurse();
      upper[splitDim] = prevUpper;
      lower[splitDim] = splitPoint;
      recurse();
      lower[splitDim] = prevLower;
    }
    recurse();
  }
  function forEachVisibleVolumetricChunk(projectionParameters, localPosition, transformedSource, callback) {
    if (!updateFixedCurPositionInChunks(transformedSource, projectionParameters.globalPosition, localPosition)) {
      return;
    }
    const { size: chunkSize } = transformedSource.chunkLayout;
    const modelViewProjection = mat4_exports.multiply(tempVisibleVolumetricModelViewProjection, projectionParameters.viewProjectionMat, transformedSource.chunkLayout.transform);
    for (let i = 0; i < 3; ++i) {
      const s = chunkSize[i];
      for (let j = 0; j < 4; ++j) {
        modelViewProjection[4 * i + j] *= s;
      }
    }
    const clippingPlanes = tempVisibleVolumetricClippingPlanes;
    getFrustrumPlanes(clippingPlanes, modelViewProjection);
    const lower = tempVisibleVolumetricChunkLower;
    const upper = tempVisibleVolumetricChunkUpper;
    lower.fill(Number.NEGATIVE_INFINITY);
    upper.fill(Number.POSITIVE_INFINITY);
    forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, isAABBVisible);
  }
  function forEachPlaneIntersectingVolumetricChunk(projectionParameters, localPosition, transformedSource, chunkLayout, callback) {
    if (!updateFixedCurPositionInChunks(transformedSource, projectionParameters.globalPosition, localPosition)) {
      return;
    }
    const { size: chunkSize } = chunkLayout;
    const modelViewProjection = mat4_exports.multiply(tempVisibleVolumetricModelViewProjection, projectionParameters.viewProjectionMat, chunkLayout.transform);
    for (let i = 0; i < 3; ++i) {
      const s = chunkSize[i];
      for (let j = 0; j < 4; ++j) {
        modelViewProjection[4 * i + j] *= s;
      }
    }
    const invModelViewProjection = tempMat4;
    mat4_exports.invert(invModelViewProjection, modelViewProjection);
    const lower = tempVisibleVolumetricChunkLower;
    const upper = tempVisibleVolumetricChunkUpper;
    const epsilon = 1e-3;
    for (let i = 0; i < 3; ++i) {
      const c = invModelViewProjection[12 + i] + epsilon / chunkSize[i];
      const xCoeff = Math.abs(invModelViewProjection[i]);
      const yCoeff = Math.abs(invModelViewProjection[4 + i]);
      lower[i] = Math.floor(c - xCoeff - yCoeff);
      upper[i] = Math.floor(c + xCoeff + yCoeff + 1);
    }
    const clippingPlanes = tempVisibleVolumetricClippingPlanes;
    for (let i = 0; i < 3; ++i) {
      const xCoeff = modelViewProjection[4 * i];
      const yCoeff = modelViewProjection[4 * i + 1];
      const zCoeff = modelViewProjection[4 * i + 2];
      clippingPlanes[i] = xCoeff;
      clippingPlanes[4 + i] = -xCoeff;
      clippingPlanes[8 + i] = +yCoeff;
      clippingPlanes[12 + i] = -yCoeff;
      clippingPlanes[16 + i] = +zCoeff;
      clippingPlanes[20 + i] = -zCoeff;
    }
    {
      const i = 3;
      const xCoeff = modelViewProjection[4 * i];
      const yCoeff = modelViewProjection[4 * i + 1];
      const zCoeff = modelViewProjection[4 * i + 2];
      clippingPlanes[i] = 1 + xCoeff;
      clippingPlanes[4 + i] = 1 - xCoeff;
      clippingPlanes[8 + i] = 1 + yCoeff;
      clippingPlanes[12 + i] = 1 - yCoeff;
      clippingPlanes[16 + i] = zCoeff;
      clippingPlanes[20 + i] = -zCoeff;
    }
    if (DEBUG_CHUNK_VISIBILITY) {
      console.log("clippingPlanes", clippingPlanes);
      console.log("modelViewProjection", modelViewProjection.join(","));
      console.log(`lower=${lower.join(",")}, upper=${upper.join(",")}`);
    }
    forEachVolumetricChunkWithinFrustrum(clippingPlanes, transformedSource, callback, isAABBIntersectingPlane);
  }
  function getNormalizedChunkLayout(projectionParameters, chunkLayout) {
    const { finiteRank } = chunkLayout;
    if (finiteRank === 3)
      return chunkLayout;
    tempChunkLayout.finiteRank = finiteRank;
    vec3_exports.copy(tempChunkLayout.size, chunkLayout.size);
    const transform = mat4_exports.copy(tempChunkLayout.transform, chunkLayout.transform);
    const invTransform = mat4_exports.copy(tempChunkLayout.invTransform, chunkLayout.invTransform);
    tempChunkLayout.detTransform = chunkLayout.detTransform;
    const { invViewMatrix, width, height } = projectionParameters;
    const depth = getViewFrustrumDepthRange(projectionParameters.projectionMat);
    for (let chunkRenderDim = finiteRank; chunkRenderDim < 3; ++chunkRenderDim) {
      const offset = invViewMatrix[12 + chunkRenderDim];
      let lower = offset, upper = offset;
      const xc = Math.abs(invViewMatrix[chunkRenderDim] * width);
      lower -= xc;
      upper += xc;
      const yc = Math.abs(invViewMatrix[chunkRenderDim + 4] * height);
      lower -= yc;
      upper += yc;
      const zc = Math.abs(invViewMatrix[chunkRenderDim + 8] * depth);
      lower -= zc;
      upper += zc;
      const scaleFactor = Math.max(1, upper - lower);
      transform[12 + chunkRenderDim] = lower;
      transform[5 * chunkRenderDim] = scaleFactor;
    }
    mat4_exports.invert(invTransform, transform);
    return tempChunkLayout;
  }

  // src/neuroglancer/util/erf.ts
  function erf(x) {
    const a1 = 0.254829592;
    const a2 = -0.284496736;
    const a3 = 1.421413741;
    const a4 = -1.453152027;
    const a5 = 1.061405429;
    const p = 0.3275911;
    const t = 1 / (1 + p * Math.abs(x));
    const y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
    return Math.sign(x) * y;
  }

  // src/neuroglancer/util/velocity_estimation.ts
  var VELOCITY_HALF_LIFE_MS = 50;
  var MODEL_HALF_LIFE_MS = 1e3;
  var VelocityEstimator = class {
    constructor(velocityHalfLifeMilliseconds = VELOCITY_HALF_LIFE_MS, modelHalfLifeMilliseconds = MODEL_HALF_LIFE_MS) {
      this.velocityHalfLifeMilliseconds = velocityHalfLifeMilliseconds;
      this.modelHalfLifeMilliseconds = modelHalfLifeMilliseconds;
      this.lastTime = Number.NEGATIVE_INFINITY;
      this.rank = 0;
      this.numSamples = 0;
      this.prevPosition = new Float32Array();
      this.velocity = new Float32Array();
      this.mean = new Float32Array();
      this.variance = new Float32Array();
    }
    reset(rank) {
      this.lastTime = Number.NEGATIVE_INFINITY;
      this.rank = rank;
      this.numSamples = 0;
      this.velocity = new Float32Array(rank);
      this.prevPosition = new Float32Array(rank);
      this.mean = new Float32Array(rank);
      this.variance = new Float32Array(rank);
    }
    addSample(position, time = Date.now()) {
      const rank = position.length;
      if (rank !== this.rank) {
        this.reset(rank);
      }
      const numSamples = this.numSamples;
      ++this.numSamples;
      if (this.numSamples === 0) {
        this.prevPosition.set(position);
        this.lastTime = time;
        return;
      }
      const deltaT = time - this.lastTime;
      this.lastTime = time;
      const velocityAlpha = 1 - Math.pow(2, -(deltaT / this.velocityHalfLifeMilliseconds));
      const modelAlpha = 1 - Math.pow(2, -(deltaT / this.modelHalfLifeMilliseconds));
      const { velocity, prevPosition, mean, variance } = this;
      for (let i = 0; i < rank; ++i) {
        const curVelocitySample = (position[i] - prevPosition[i]) / Math.max(deltaT, 1);
        prevPosition[i] = position[i];
        const prevVelocity = velocity[i];
        const newVelocity = velocity[i] = prevVelocity + velocityAlpha * (curVelocitySample - prevVelocity);
        if (numSamples === 1) {
          mean[i] = newVelocity;
        } else {
          const meanPrev = mean[i];
          const varPrev = variance[i];
          const delta = newVelocity - meanPrev;
          mean[i] = meanPrev + modelAlpha * delta;
          variance[i] = (1 - modelAlpha) * (varPrev + modelAlpha * delta * delta);
        }
      }
    }
  };

  // src/neuroglancer/shared_watchable_value.ts
  var CHANGED_RPC_METHOD_ID = "SharedWatchableValue.changed";
  var SharedWatchableValue = class extends SharedObjectCounterpart {
    constructor(rpc2, options = {}) {
      super(rpc2, options);
      this.updatingValue_ = false;
      if (rpc2 !== void 0) {
        this.base = new WatchableValue(options["value"]);
        this.setupChangedHandler();
      }
    }
    initializeCounterpart(rpc2, options = {}) {
      options["value"] = this.value;
      super.initializeCounterpart(rpc2, options);
    }
    setupChangedHandler() {
      this.registerDisposer(this.base.changed.add(() => {
        if (this.updatingValue_) {
          this.updatingValue_ = false;
        } else {
          const { rpc: rpc2 } = this;
          if (rpc2 !== null) {
            rpc2.invoke(CHANGED_RPC_METHOD_ID, { "id": this.rpcId, "value": this.value });
          }
        }
      }));
    }
    static makeFromExisting(rpc2, base) {
      let obj = new SharedWatchableValue();
      obj.base = base;
      obj.setupChangedHandler();
      obj.initializeCounterpart(rpc2);
      return obj;
    }
    static make(rpc2, value) {
      return SharedWatchableValue.makeFromExisting(rpc2, new WatchableValue(value));
    }
    get value() {
      return this.base.value;
    }
    set value(value) {
      this.base.value = value;
    }
    get changed() {
      return this.base.changed;
    }
  };
  SharedWatchableValue = __decorateClass([
    registerSharedObject("SharedWatchableValue")
  ], SharedWatchableValue);
  registerRPC(CHANGED_RPC_METHOD_ID, function(x) {
    const obj = this.get(x["id"]);
    obj.updatingValue_ = true;
    obj.base.value = x["value"];
    obj.updatingValue_ = false;
  });

  // src/neuroglancer/visibility_priority/backend.ts
  function withSharedVisibility(Base) {
    return class extends Base {
      constructor(...args) {
        super(...args);
        const rpc2 = args[0];
        const options = args[1];
        this.visibility = rpc2.get(options["visibility"]);
        this.registerDisposer(this.visibility.changed.add(() => this.chunkManager.scheduleUpdateChunkPriorities()));
      }
    };
  }
  function getPriorityTier(visibility) {
    return visibility === Number.POSITIVE_INFINITY ? ChunkPriorityTier.VISIBLE : ChunkPriorityTier.PREFETCH;
  }
  function getBasePriority(visibility) {
    return visibility === Number.POSITIVE_INFINITY ? 0 : visibility * PREFETCH_PRIORITY_MULTIPLIER;
  }

  // src/neuroglancer/sliceview/backend.ts
  var BASE_PRIORITY = -1e12;
  var SCALE_PRIORITY_MULTIPLIER = 1e9;
  var tempChunkPosition = vec3_exports.create();
  var tempCenter = vec3_exports.create();
  var tempChunkSize = vec3_exports.create();
  var SliceViewCounterpartBase = class extends SliceViewBase {
    constructor(rpc2, options) {
      super(rpc2.get(options.projectionParameters));
      this.initializeSharedObject(rpc2, options["id"]);
    }
  };
  function disposeTransformedSources(allSources) {
    for (const scales of allSources) {
      for (const tsource of scales) {
        tsource.source.dispose();
      }
    }
  }
  var SliceViewIntermediateBase = withSharedVisibility(withChunkManager(SliceViewCounterpartBase));
  var SliceViewBackend = class extends SliceViewIntermediateBase {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.velocityEstimator = new VelocityEstimator();
      this.handleLayerChanged = () => {
        this.chunkManager.scheduleUpdateChunkPriorities();
      };
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
        this.updateVisibleChunks();
      }));
      this.registerDisposer(this.projectionParameters.changed.add(() => {
        this.velocityEstimator.addSample(this.projectionParameters.value.globalPosition);
      }));
    }
    invalidateVisibleChunks() {
      super.invalidateVisibleChunks();
      this.chunkManager.scheduleUpdateChunkPriorities();
    }
    updateVisibleChunks() {
      const projectionParameters = this.projectionParameters.value;
      let chunkManager = this.chunkManager;
      const visibility = this.visibility.value;
      if (visibility === Number.NEGATIVE_INFINITY) {
        return;
      }
      this.updateVisibleSources();
      const { centerDataPosition } = projectionParameters;
      const priorityTier = getPriorityTier(visibility);
      let basePriority = getBasePriority(visibility);
      basePriority += BASE_PRIORITY;
      const localCenter = tempCenter;
      const chunkSize = tempChunkSize;
      const curVisibleChunks = [];
      this.velocityEstimator.addSample(this.projectionParameters.value.globalPosition);
      for (const [layer, visibleLayerSources] of this.visibleLayers) {
        chunkManager.registerLayer(layer);
        const { visibleSources } = visibleLayerSources;
        for (let i = 0, numVisibleSources = visibleSources.length; i < numVisibleSources; ++i) {
          const tsource = visibleSources[i];
          const prefetchOffsets = chunkManager.queueManager.enablePrefetch.value ? getPrefetchChunkOffsets(this.velocityEstimator, tsource) : [];
          const { chunkLayout } = tsource;
          chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);
          const { size, finiteRank } = chunkLayout;
          vec3_exports.copy(chunkSize, size);
          for (let i2 = finiteRank; i2 < 3; ++i2) {
            chunkSize[i2] = 0;
            localCenter[i2] = 0;
          }
          const priorityIndex = i;
          const sourceBasePriority = basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;
          curVisibleChunks.length = 0;
          const curMarkGeneration = getNextMarkGeneration();
          forEachPlaneIntersectingVolumetricChunk(projectionParameters, tsource.renderLayer.localPosition.value, tsource, getNormalizedChunkLayout(projectionParameters, tsource.chunkLayout), (positionInChunks) => {
            vec3_exports.multiply(tempChunkPosition, positionInChunks, chunkSize);
            let priority = -vec3_exports.distance(localCenter, tempChunkPosition);
            const { curPositionInChunks } = tsource;
            let chunk = tsource.source.getChunk(curPositionInChunks);
            chunkManager.requestChunk(chunk, priorityTier, sourceBasePriority + priority);
            ++layer.numVisibleChunksNeeded;
            if (chunk.state === ChunkState.GPU_MEMORY) {
              ++layer.numVisibleChunksAvailable;
            }
            curVisibleChunks.push(chunk);
            chunk.markGeneration = curMarkGeneration;
          });
          if (prefetchOffsets.length !== 0) {
            const { curPositionInChunks } = tsource;
            for (const visibleChunk of curVisibleChunks) {
              curPositionInChunks.set(visibleChunk.chunkGridPosition);
              for (let j = 0, length4 = prefetchOffsets.length; j < length4; ) {
                const chunkDim = prefetchOffsets[j];
                const minChunk = prefetchOffsets[j + 2];
                const maxChunk = prefetchOffsets[j + 3];
                const newPriority = prefetchOffsets[j + 4];
                const jumpOffset = prefetchOffsets[j + 5];
                const oldIndex = curPositionInChunks[chunkDim];
                const newIndex = oldIndex + prefetchOffsets[j + 1];
                if (newIndex < minChunk || newIndex > maxChunk) {
                  j = jumpOffset;
                  continue;
                }
                curPositionInChunks[chunkDim] = newIndex;
                const chunk = tsource.source.getChunk(curPositionInChunks);
                curPositionInChunks[chunkDim] = oldIndex;
                if (chunk.markGeneration === curMarkGeneration) {
                  j = jumpOffset;
                  continue;
                }
                if (!Number.isFinite(newPriority)) {
                  debugger;
                }
                chunkManager.requestChunk(chunk, ChunkPriorityTier.PREFETCH, sourceBasePriority + newPriority);
                ++layer.numPrefetchChunksNeeded;
                if (chunk.state === ChunkState.GPU_MEMORY) {
                  ++layer.numPrefetchChunksAvailable;
                }
                j += PREFETCH_ENTRY_SIZE;
              }
            }
          }
        }
      }
    }
    removeVisibleLayer(layer) {
      const { visibleLayers } = this;
      const layerInfo = visibleLayers.get(layer);
      visibleLayers.delete(layer);
      disposeTransformedSources(layerInfo.allSources);
      layer.renderScaleTarget.changed.remove(this.invalidateVisibleSources);
      layer.localPosition.changed.remove(this.handleLayerChanged);
      this.invalidateVisibleSources();
    }
    addVisibleLayer(layer, allSources) {
      const { displayDimensionRenderInfo } = this.projectionParameters.value;
      let layerInfo = this.visibleLayers.get(layer);
      if (layerInfo === void 0) {
        layerInfo = {
          allSources,
          visibleSources: [],
          displayDimensionRenderInfo
        };
        this.visibleLayers.set(layer, layerInfo);
        layer.renderScaleTarget.changed.add(() => this.invalidateVisibleSources());
        layer.localPosition.changed.add(this.handleLayerChanged);
      } else {
        disposeTransformedSources(layerInfo.allSources);
        layerInfo.allSources = allSources;
        layerInfo.visibleSources.length = 0;
        layerInfo.displayDimensionRenderInfo = displayDimensionRenderInfo;
      }
      this.invalidateVisibleSources();
    }
    disposed() {
      for (let layer of this.visibleLayers.keys()) {
        this.removeVisibleLayer(layer);
      }
      super.disposed();
    }
    invalidateVisibleSources() {
      super.invalidateVisibleSources();
      this.chunkManager.scheduleUpdateChunkPriorities();
    }
  };
  SliceViewBackend = __decorateClass([
    registerSharedObject(SLICEVIEW_RPC_ID)
  ], SliceViewBackend);
  function deserializeTransformedSources(rpc2, serializedSources, layer) {
    const sources = serializedSources.map((scales) => scales.map((serializedSource) => {
      const source = rpc2.getRef(serializedSource.source);
      const chunkLayout = serializedSource.chunkLayout;
      const { rank } = source.spec;
      const tsource = {
        renderLayer: layer,
        source,
        chunkLayout: ChunkLayout.fromObject(chunkLayout),
        layerRank: serializedSource.layerRank,
        nonDisplayLowerClipBound: serializedSource.nonDisplayLowerClipBound,
        nonDisplayUpperClipBound: serializedSource.nonDisplayUpperClipBound,
        lowerClipBound: serializedSource.lowerClipBound,
        upperClipBound: serializedSource.upperClipBound,
        lowerClipDisplayBound: serializedSource.lowerClipDisplayBound,
        upperClipDisplayBound: serializedSource.upperClipDisplayBound,
        lowerChunkDisplayBound: serializedSource.lowerChunkDisplayBound,
        upperChunkDisplayBound: serializedSource.upperChunkDisplayBound,
        effectiveVoxelSize: serializedSource.effectiveVoxelSize,
        chunkDisplayDimensionIndices: serializedSource.chunkDisplayDimensionIndices,
        fixedLayerToChunkTransform: serializedSource.fixedLayerToChunkTransform,
        combinedGlobalLocalToChunkTransform: serializedSource.combinedGlobalLocalToChunkTransform,
        curPositionInChunks: new Float32Array(rank),
        fixedPositionWithinChunk: new Uint32Array(rank)
      };
      return tsource;
    }));
    return sources;
  }
  registerRPC(SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, function(x) {
    const obj = this.get(x["id"]);
    const layer = this.get(x["layerId"]);
    const sources = deserializeTransformedSources(this, x.sources, layer);
    obj.addVisibleLayer(layer, sources);
  });
  registerRPC(SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, function(x) {
    let obj = this.get(x["id"]);
    let layer = this.get(x["layerId"]);
    obj.removeVisibleLayer(layer);
  });
  var SliceViewChunk = class extends Chunk {
    constructor() {
      super();
      this.source = null;
    }
    initializeVolumeChunk(key, chunkGridPosition) {
      super.initialize(key);
      this.chunkGridPosition = Float32Array.from(chunkGridPosition);
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      msg["chunkGridPosition"] = this.chunkGridPosition;
    }
    downloadSucceeded() {
      super.downloadSucceeded();
    }
    freeSystemMemory() {
    }
    toString() {
      return this.source.toString() + ":" + vec3Key(this.chunkGridPosition);
    }
  };
  var SliceViewChunkSourceBackend = class extends ChunkSource {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.spec = options.spec;
    }
    getChunk(chunkGridPosition) {
      const key = chunkGridPosition.join();
      let chunk = this.chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(this.chunkConstructor);
        chunk.initializeVolumeChunk(key, chunkGridPosition);
        this.addChunk(chunk);
      }
      return chunk;
    }
  };
  var SliceViewRenderLayerBackend = class extends SharedObjectCounterpart {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.renderScaleTarget = rpc2.get(options.renderScaleTarget);
      this.localPosition = rpc2.get(options.localPosition);
      this.numVisibleChunksNeeded = 0;
      this.numVisibleChunksAvailable = 0;
      this.numPrefetchChunksAvailable = 0;
      this.numPrefetchChunksNeeded = 0;
      this.chunkManagerGeneration = -1;
    }
    filterVisibleSources(sliceView, sources) {
      return filterVisibleSources(sliceView, this, sources);
    }
  };
  SliceViewRenderLayerBackend = __decorateClass([
    registerSharedObject(SLICEVIEW_RENDERLAYER_RPC_ID)
  ], SliceViewRenderLayerBackend);
  var PREFETCH_MS = 2e3;
  var MAX_PREFETCH_VELOCITY = 0.1;
  var MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS = 32;
  var PREFETCH_PROBABILITY_CUTOFF = 0.05;
  var PREFETCH_ENTRY_SIZE = 6;
  function getPrefetchChunkOffsets(velocityEstimator, tsource) {
    const offsets = [];
    const globalRank = velocityEstimator.rank;
    const { combinedGlobalLocalToChunkTransform, layerRank } = tsource;
    const { rank: chunkRank, chunkDataSize } = tsource.source.spec;
    const { mean: meanVec, variance: varianceVec } = velocityEstimator;
    for (let chunkDim = 0; chunkDim < chunkRank; ++chunkDim) {
      const isDisplayDimension = tsource.chunkDisplayDimensionIndices.includes(chunkDim);
      let mean = 0;
      let variance = 0;
      for (let globalDim = 0; globalDim < globalRank; ++globalDim) {
        const meanValue = meanVec[globalDim];
        const varianceValue = varianceVec[globalDim];
        const coeff = combinedGlobalLocalToChunkTransform[globalDim * layerRank + chunkDim];
        mean += coeff * meanValue;
        variance += coeff * coeff * varianceValue;
      }
      if (mean > MAX_PREFETCH_VELOCITY) {
        continue;
      }
      const chunkSize = chunkDataSize[chunkDim];
      const initialFraction = isDisplayDimension ? 0 : tsource.fixedPositionWithinChunk[chunkDim] / chunkSize;
      const adjustedMean = mean / chunkSize * PREFETCH_MS;
      let adjustedStddevTimesSqrt2 = Math.sqrt(2 * variance) / chunkSize * PREFETCH_MS;
      if (Math.abs(adjustedMean) < 1e-3 && adjustedStddevTimesSqrt2 < 1e-3) {
        continue;
      }
      adjustedStddevTimesSqrt2 = Math.max(1e-6, adjustedStddevTimesSqrt2);
      const cdf = (x) => 0.5 * (1 + erf((x - adjustedMean) / adjustedStddevTimesSqrt2));
      const curChunk = tsource.curPositionInChunks[chunkDim];
      const minChunk = Math.floor(tsource.lowerClipBound[chunkDim] / chunkSize);
      const maxChunk = Math.ceil(tsource.upperClipBound[chunkDim] / chunkSize) - 1;
      let groupStart = offsets.length;
      for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {
        if (!isDisplayDimension && curChunk + i > maxChunk)
          break;
        const probability = 1 - cdf(i - initialFraction);
        if (probability < PREFETCH_PROBABILITY_CUTOFF)
          break;
        offsets.push(chunkDim, i, minChunk, maxChunk, probability, 0);
      }
      let newGroupStart = offsets.length;
      for (let i = groupStart, end = offsets.length; i < end; i += PREFETCH_ENTRY_SIZE) {
        offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;
      }
      groupStart = newGroupStart;
      for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {
        if (!isDisplayDimension && curChunk - i < minChunk)
          break;
        const probability = cdf(-i + 1 - initialFraction);
        if (probability < PREFETCH_PROBABILITY_CUTOFF)
          break;
        offsets.push(chunkDim, -i, minChunk, maxChunk, probability, 0);
      }
      newGroupStart = offsets.length;
      for (let i = groupStart, end = offsets.length; i < end; i += PREFETCH_ENTRY_SIZE) {
        offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;
      }
    }
    return offsets;
  }

  // src/neuroglancer/perspective_view/base.ts
  var PERSPECTIVE_VIEW_RPC_ID = "perspective_view/PerspectiveView";

  // src/neuroglancer/perspective_view/backend.ts
  var PerspectiveViewBackend = class extends SharedObjectCounterpart {
    constructor(...args) {
      super(...args);
      const rpc2 = args[0];
      const options = args[1];
      this.visibility = rpc2.get(options.visibility);
      this.projectionParameters = rpc2.get(options.projectionParameters);
    }
  };
  PerspectiveViewBackend = __decorateClass([
    registerSharedObject(PERSPECTIVE_VIEW_RPC_ID)
  ], PerspectiveViewBackend);
  var PerspectiveViewRenderLayerBackend = class extends RenderLayerBackend {
  };

  // src/neuroglancer/volume_rendering/base.ts
  var VOLUME_RENDERING_RENDER_LAYER_RPC_ID = "volume_rendering/VolumeRenderingRenderLayer";
  var VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID = "volume_rendering/VolumeRenderingRenderLayer/update";
  var volumeRenderingDepthSamples = 64;
  var tempMat3 = mat3_exports.create();
  function forEachVisibleVolumeRenderingChunk(projectionParameters, localPosition, renderScaleTarget, transformedSources, beginScale, callback) {
    renderScaleTarget;
    if (transformedSources.length === 0)
      return;
    const { viewMatrix, projectionMat, displayDimensionRenderInfo } = projectionParameters;
    const { voxelPhysicalScales } = displayDimensionRenderInfo;
    const canonicalToPhysicalScale = prod3(voxelPhysicalScales);
    const targetViewSpacing = getViewFrustrumDepthRange(projectionMat) / volumeRenderingDepthSamples;
    const targetViewVolume = targetViewSpacing ** 3;
    const viewDet = mat3_exports.determinant(mat3FromMat4(tempMat3, viewMatrix));
    const getViewVolume = (scaleIndex) => {
      const tsource2 = transformedSources[scaleIndex];
      return Math.abs(tsource2.chunkLayout.detTransform * viewDet);
    };
    let bestScaleIndex = transformedSources.length - 1;
    let bestViewVolume = getViewVolume(bestScaleIndex);
    for (let scaleIndex = bestScaleIndex - 1; scaleIndex >= 0; --scaleIndex) {
      const viewVolume = getViewVolume(scaleIndex);
      if (Math.abs(viewVolume - targetViewVolume) < Math.abs(bestViewVolume - targetViewVolume)) {
        bestViewVolume = viewVolume;
        bestScaleIndex = scaleIndex;
      } else {
        break;
      }
    }
    const physicalSpacing = Math.pow(bestViewVolume * canonicalToPhysicalScale / viewDet, 1 / 3);
    const pixelSpacing = Math.pow(bestViewVolume, 1 / 3) * projectionParameters.width / (2 * projectionMat[0]);
    let firstChunk = true;
    const tsource = transformedSources[bestScaleIndex];
    forEachVisibleVolumetricChunk(projectionParameters, localPosition, tsource, (positionInChunks, clippingPlanes) => {
      if (firstChunk) {
        beginScale(tsource, bestScaleIndex, physicalSpacing, pixelSpacing, clippingPlanes);
        firstChunk = false;
      }
      callback(tsource, bestScaleIndex, positionInChunks);
    });
  }

  // src/neuroglancer/volume_rendering/backend.ts
  var tempChunkPosition2 = vec3_exports.create();
  var tempCenter2 = vec3_exports.create();
  var tempChunkSize2 = vec3_exports.create();
  var tempCenterDataPosition = vec3_exports.create();
  var VolumeRenderingRenderLayerBackend = class extends withChunkManager(RenderLayerBackend) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.renderScaleTarget = rpc2.get(options.renderScaleTarget);
      this.localPosition = rpc2.get(options.localPosition);
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      this.registerDisposer(this.localPosition.changed.add(scheduleUpdateChunkPriorities));
      this.registerDisposer(this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    attach(attachment) {
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      const { view } = attachment;
      attachment.registerDisposer(scheduleUpdateChunkPriorities);
      attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
      attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
      attachment.state = {
        displayDimensionRenderInfo: view.projectionParameters.value.displayDimensionRenderInfo,
        transformedSources: []
      };
    }
    recomputeChunkPriorities() {
      for (const attachment of this.attachments.values()) {
        const { view } = attachment;
        const visibility = view.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
          continue;
        }
        const { transformedSources, displayDimensionRenderInfo } = attachment.state;
        if (transformedSources.length === 0 || displayDimensionRenderInfo !== view.projectionParameters.value.displayDimensionRenderInfo) {
          continue;
        }
        const projectionParameters = view.projectionParameters.value;
        const priorityTier = getPriorityTier(visibility);
        let basePriority = getBasePriority(visibility);
        basePriority += BASE_PRIORITY;
        const localCenter = tempCenter2;
        const chunkSize = tempChunkSize2;
        const centerDataPosition = tempCenterDataPosition;
        const { globalPosition, displayDimensionRenderInfo: { displayDimensionIndices } } = projectionParameters;
        for (let displayDim = 0; displayDim < 3; ++displayDim) {
          const globalDim = displayDimensionIndices[displayDim];
          centerDataPosition[displayDim] = globalDim === -1 ? 0 : globalPosition[globalDim];
        }
        let sourceBasePriority;
        const { chunkManager } = this;
        chunkManager.registerLayer(this);
        forEachVisibleVolumeRenderingChunk(projectionParameters, this.localPosition.value, this.renderScaleTarget.value, transformedSources[0], (tsource, scaleIndex) => {
          const { chunkLayout } = tsource;
          for (let i = 0; i < 3; ++i) {
          }
          chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);
          const { size, finiteRank } = chunkLayout;
          vec3_exports.copy(chunkSize, size);
          for (let i = finiteRank; i < 3; ++i) {
            chunkSize[i] = 0;
            localCenter[i] = 0;
          }
          const priorityIndex = transformedSources[0].length - 1 - scaleIndex;
          sourceBasePriority = basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;
        }, (tsource, _, positionInChunks) => {
          vec3_exports.multiply(tempChunkPosition2, positionInChunks, chunkSize);
          const priority = -vec3_exports.distance(localCenter, tempChunkPosition2);
          const chunk = tsource.source.getChunk(tsource.curPositionInChunks);
          ++this.numVisibleChunksNeeded;
          chunkManager.requestChunk(chunk, priorityTier, sourceBasePriority + priority);
          if (chunk.state === ChunkState.GPU_MEMORY) {
            ++this.numVisibleChunksAvailable;
          }
        });
      }
    }
  };
  VolumeRenderingRenderLayerBackend = __decorateClass([
    registerSharedObject(VOLUME_RENDERING_RENDER_LAYER_RPC_ID)
  ], VolumeRenderingRenderLayerBackend);
  registerRPC(VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function(x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    attachment.state.transformedSources = deserializeTransformedSources(this, x.sources, layer);
    attachment.state.displayDimensionRenderInfo = attachment.view.projectionParameters.value.displayDimensionRenderInfo;
    layer.chunkManager.scheduleUpdateChunkPriorities();
  });

  // src/neuroglancer/util/float32_to_string.ts
  var tempArray = new Float32Array(1);
  function float32ToString(x) {
    tempArray[0] = x;
    x = tempArray[0];
    for (let digits = 1; digits < 21; ++digits) {
      let result = x.toPrecision(digits);
      tempArray[0] = parseFloat(result);
      if (tempArray[0] === x) {
        return result;
      }
    }
    return x.toString();
  }

  // src/neuroglancer/util/hex.ts
  function hexEncodeByte(x) {
    return ("0" + x.toString(16)).slice(-2);
  }

  // src/neuroglancer/util/color.ts
  function parseColorSerialization(x) {
    const rgbaPattern = /^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;
    {
      const m = x.match(rgbaPattern);
      if (m !== null) {
        return [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4])];
      }
    }
    const hexPattern = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;
    {
      const m = x.match(hexPattern);
      if (m !== null) {
        return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1];
      }
    }
    throw new Error(`Invalid serialized color: ${JSON.stringify(x)}.`);
  }
  function parseRGBAColorSpecification(x) {
    try {
      if (typeof x !== "string") {
        throw new Error(`Expected string, but received ${JSON.stringify(x)}.`);
      }
      const context = document.createElement("canvas").getContext("2d");
      context.fillStyle = x;
      const result = parseColorSerialization(context.fillStyle);
      return vec4_exports.fromValues(result[0] / 255, result[1] / 255, result[2] / 255, result[3]);
    } catch (parseError) {
      throw new Error(`Failed to parse color specification: ${parseError.message}`);
    }
  }
  function parseRGBColorSpecification(x) {
    const result = parseRGBAColorSpecification(x);
    return result.subarray(0, 3);
  }
  function packColor(x) {
    const size = x[3] === void 0 ? 3 : 4;
    let result = 0;
    for (let i = 0; i < size; i++) {
      result = (result << 8 >>> 0) + Math.min(255, Math.max(0, Math.round(x[size - 1 - i] * 255)));
    }
    return result;
  }
  function unpackRGB(value) {
    return vec3_exports.fromValues((value >>> 0 & 255) / 255, (value >>> 8 & 255) / 255, (value >>> 16 & 255) / 255);
  }
  function unpackRGBA(value) {
    return vec4_exports.fromValues((value >>> 0 & 255) / 255, (value >>> 8 & 255) / 255, (value >>> 16 & 255) / 255, (value >>> 24 & 255) / 255);
  }
  function serializeColor(x) {
    if (x[3] === void 0 || x[3] === 1) {
      let result = "#";
      for (let i = 0; i < 3; ++i) {
        result += hexEncodeByte(Math.min(255, Math.max(0, Math.round(x[i] * 255))));
      }
      return result;
    } else {
      let result = "rgba(";
      for (let i = 0; i < 3; ++i) {
        if (i !== 0) {
          result += ", ";
        }
        result += Math.min(255, Math.max(0, Math.round(x[i] * 255)));
      }
      result += `, ${float32ToString(x[3])})`;
      return result;
    }
  }

  // src/neuroglancer/util/endian.ts
  var Endianness;
  (function(Endianness4) {
    Endianness4[Endianness4["LITTLE"] = 0] = "LITTLE";
    Endianness4[Endianness4["BIG"] = 1] = "BIG";
  })(Endianness || (Endianness = {}));
  function determineEndianness() {
    const a = Uint16Array.of(4386);
    const b = new Uint8Array(a.buffer);
    return b[0] === 17 ? 1 : 0;
  }
  var ENDIANNESS = determineEndianness();
  function swapEndian16(array) {
    let view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    for (let i = 0, length4 = view.length; i < length4; i += 2) {
      let temp = view[i];
      view[i] = view[i + 1];
      view[i + 1] = temp;
    }
  }
  function swapEndian32(array) {
    let view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    for (let i = 0, length4 = view.length; i < length4; i += 4) {
      let temp = view[i];
      view[i] = view[i + 3];
      view[i + 3] = temp;
      temp = view[i + 1];
      view[i + 1] = view[i + 2];
      view[i + 2] = temp;
    }
  }
  function swapEndian64(array) {
    let view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    for (let i = 0, length4 = view.length; i < length4; i += 8) {
      let temp = view[i];
      view[i] = view[i + 7];
      view[i + 7] = temp;
      temp = view[i + 1];
      view[i + 1] = view[i + 6];
      view[i + 6] = temp;
      temp = view[i + 2];
      view[i + 2] = view[i + 5];
      view[i + 5] = temp;
      temp = view[i + 3];
      view[i + 3] = view[i + 4];
      view[i + 4] = temp;
    }
  }
  function convertEndian16(array, source, target = ENDIANNESS) {
    if (source !== target) {
      swapEndian16(array);
    }
  }
  function convertEndian32(array, source, target = ENDIANNESS) {
    if (source !== target) {
      swapEndian32(array);
    }
  }
  function convertEndian(array, source, elementBytes, target = ENDIANNESS) {
    if (source === target || elementBytes === 1)
      return;
    switch (elementBytes) {
      case 2:
        swapEndian16(array);
        break;
      case 4:
        swapEndian32(array);
        break;
      case 8:
        swapEndian64(array);
        break;
    }
  }

  // src/neuroglancer/util/float.ts
  var denormMin = 2 ** -1074;
  var float64Buf = new Float64Array(1);
  var uint32Buf = new Uint32Array(float64Buf.buffer);

  // src/neuroglancer/util/uint64.ts
  var randomTempBuffer = new Uint32Array(2);
  var trueBase = 4294967296;
  var stringConversionData = [];
  for (let base = 2; base <= 36; ++base) {
    let lowDigits = Math.floor(32 / Math.log2(base));
    let lowBase = Math.pow(base, lowDigits);
    let patternString = `^[0-${String.fromCharCode("0".charCodeAt(0) + Math.min(9, base - 1))}`;
    if (base > 10) {
      patternString += `a-${String.fromCharCode("a".charCodeAt(0) + base - 11)}`;
      patternString += `A-${String.fromCharCode("A".charCodeAt(0) + base - 11)}`;
    }
    let maxDigits = Math.ceil(64 / Math.log2(base));
    patternString += `]{1,${maxDigits}}$`;
    let pattern = new RegExp(patternString);
    stringConversionData[base] = { lowDigits, lowBase, pattern };
  }
  function uint32MultiplyHigh(a, b) {
    a >>>= 0;
    b >>>= 0;
    const a00 = a & 65535, a16 = a >>> 16;
    const b00 = b & 65535, b16 = b >>> 16;
    let c00 = a00 * b00;
    let c16 = (c00 >>> 16) + a16 * b00;
    let c32 = c16 >>> 16;
    c16 = (c16 & 65535) + a00 * b16;
    c32 += c16 >>> 16;
    let c48 = c32 >>> 16;
    c32 = (c32 & 65535) + a16 * b16;
    c48 += c32 >>> 16;
    return ((c48 & 65535) << 16 | c32 & 65535) >>> 0;
  }
  var _Uint64 = class {
    constructor(low = 0, high = 0) {
      this.low = low;
      this.high = high;
    }
    clone() {
      return new _Uint64(this.low, this.high);
    }
    assign(x) {
      this.low = x.low;
      this.high = x.high;
    }
    toString(base = 10) {
      let vLow = this.low, vHigh = this.high;
      if (vHigh === 0) {
        return vLow.toString(base);
      }
      vHigh *= trueBase;
      let { lowBase, lowDigits } = stringConversionData[base];
      let vHighExtra = vHigh % lowBase;
      vHigh = Math.floor(vHigh / lowBase);
      vLow += vHighExtra;
      vHigh += Math.floor(vLow / lowBase);
      vLow = vLow % lowBase;
      let vLowStr = vLow.toString(base);
      return vHigh.toString(base) + "0".repeat(lowDigits - vLowStr.length) + vLowStr;
    }
    static less(a, b) {
      return a.high < b.high || a.high === b.high && a.low < b.low;
    }
    static compare(a, b) {
      return a.high - b.high || a.low - b.low;
    }
    static equal(a, b) {
      return a.low === b.low && a.high === b.high;
    }
    static min(a, b) {
      return _Uint64.less(a, b) ? a : b;
    }
    static max(a, b) {
      return _Uint64.less(a, b) ? b : a;
    }
    static random() {
      crypto.getRandomValues(randomTempBuffer);
      return new _Uint64(randomTempBuffer[0], randomTempBuffer[1]);
    }
    tryParseString(s, base = 10) {
      const { lowDigits, lowBase, pattern } = stringConversionData[base];
      if (!pattern.test(s)) {
        return false;
      }
      if (s.length <= lowDigits) {
        this.low = parseInt(s, base);
        this.high = 0;
        return true;
      }
      const splitPoint = s.length - lowDigits;
      const lowPrime = parseInt(s.substr(splitPoint), base);
      const highPrime = parseInt(s.substr(0, splitPoint), base);
      let high, low;
      if (lowBase === trueBase) {
        high = highPrime;
        low = lowPrime;
      } else {
        const highRemainder = Math.imul(highPrime, lowBase) >>> 0;
        high = uint32MultiplyHigh(highPrime, lowBase) + (Math.imul(Math.floor(highPrime / trueBase), lowBase) >>> 0);
        low = lowPrime + highRemainder;
        if (low >= trueBase) {
          ++high;
          low -= trueBase;
        }
      }
      if (low >>> 0 !== low || high >>> 0 !== high) {
        return false;
      }
      this.low = low;
      this.high = high;
      return true;
    }
    parseString(s, base = 10) {
      if (!this.tryParseString(s, base)) {
        throw new Error(`Failed to parse string as uint64 value: ${JSON.stringify(s)}.`);
      }
      return this;
    }
    static parseString(s, base = 10) {
      let x = new _Uint64();
      return x.parseString(s, base);
    }
    valid() {
      let { low, high } = this;
      return low >>> 0 === low && high >>> 0 === high;
    }
    toJSON() {
      return this.toString();
    }
    static lshift(out, input, bits) {
      const { low, high } = input;
      if (bits === 0) {
        out.low = low;
        out.high = high;
      } else if (bits < 32) {
        out.low = low << bits;
        out.high = high << bits | low >>> 32 - bits;
      } else {
        out.low = 0;
        out.high = low << bits - 32;
      }
      return out;
    }
    static rshift(out, input, bits) {
      const { low, high } = input;
      if (bits === 0) {
        out.low = low;
        out.high = high;
      } else if (bits < 32) {
        out.low = low >>> bits | high << 32 - bits;
        out.high = high >>> bits;
      } else {
        out.low = high >>> bits - 32;
        out.high = 0;
      }
      return out;
    }
    static or(out, a, b) {
      out.low = a.low | b.low;
      out.high = a.high | b.high;
      return out;
    }
    static xor(out, a, b) {
      out.low = a.low ^ b.low;
      out.high = a.high ^ b.high;
      return out;
    }
    static and(out, a, b) {
      out.low = a.low & b.low;
      out.high = a.high & b.high;
      return out;
    }
    static add(out, a, b) {
      let lowSum = a.low + b.low;
      let highSum = a.high + b.high;
      const low = lowSum >>> 0;
      if (low !== lowSum)
        highSum += 1;
      out.low = low;
      out.high = highSum >>> 0;
      return out;
    }
    static addUint32(out, a, b) {
      let lowSum = a.low + b;
      let highSum = a.high;
      const low = lowSum >>> 0;
      if (low !== lowSum)
        highSum += 1;
      out.low = low;
      out.high = highSum >>> 0;
      return out;
    }
    static decrement(out, input) {
      let { low, high } = input;
      if (low === 0) {
        high -= 1;
      }
      out.low = low - 1 >>> 0;
      out.high = high >>> 0;
      return out;
    }
    static increment(out, input) {
      let { low, high } = input;
      if (low === 4294967295)
        high += 1;
      out.low = low + 1 >>> 0;
      out.high = high >>> 0;
      return out;
    }
    static subtract(out, a, b) {
      let lowSum = a.low - b.low;
      let highSum = a.high - b.high;
      const low = lowSum >>> 0;
      if (low !== lowSum)
        highSum -= 1;
      out.low = low;
      out.high = highSum >>> 0;
      return out;
    }
    static absDifference(out, a, b) {
      return _Uint64.less(a, b) ? _Uint64.subtract(out, b, a) : _Uint64.subtract(out, a, b);
    }
    static multiplyUint32(out, a, b) {
      const { low, high } = a;
      out.low = Math.imul(low, b) >>> 0;
      out.high = Math.imul(high, b) + uint32MultiplyHigh(low, b) >>> 0;
      return out;
    }
    static lowMask(out, bits) {
      if (bits === 0) {
        out.high = out.low = 0;
      } else if (bits <= 32) {
        out.high = 0;
        out.low = 4294967295 >>> 32 - bits;
      } else {
        out.high = 4294967295 >>> bits - 32;
        out.low = 4294967295;
      }
      return out;
    }
    toNumber() {
      return this.low + this.high * 4294967296;
    }
    setFromNumber(value) {
      value = Math.round(value);
      if (value < 0) {
        this.low = this.high = 0;
      } else if (value >= 18446744073709552e3) {
        this.low = this.high = 4294967295;
      } else {
        this.low = value % 4294967296;
        this.high = Math.floor(value / 4294967296);
      }
    }
    static fromNumber(value) {
      const x = new _Uint64();
      x.setFromNumber(value);
      return x;
    }
  };
  var Uint64 = _Uint64;
  Uint64.ZERO = new _Uint64(0, 0);
  Uint64.ONE = new _Uint64(1, 0);

  // src/neuroglancer/util/lerp.ts
  var defaultDataTypeRange = {
    [DataType.UINT8]: [0, 255],
    [DataType.INT8]: [-128, 127],
    [DataType.UINT16]: [0, 65535],
    [DataType.INT16]: [-32768, 32767],
    [DataType.UINT32]: [0, 4294967295],
    [DataType.INT32]: [-2147483648, 2147483647],
    [DataType.UINT64]: [Uint64.ZERO, new Uint64(4294967295, 4294967295)],
    [DataType.FLOAT32]: [0, 1]
  };
  var tempUint64 = new Uint64();
  var temp2Uint64 = new Uint64();

  // src/neuroglancer/util/random.ts
  function getRandomHexString(numBits = 128) {
    const numValues = Math.ceil(numBits / 32);
    const data = new Uint32Array(numValues);
    crypto.getRandomValues(data);
    let s = "";
    for (let i = 0; i < numValues; ++i) {
      s += ("00000000" + data[i].toString(16)).slice(-8);
    }
    return s;
  }
  function getRandomValues(array) {
    let byteArray = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    const blockSize = 65536;
    for (let i = 0, length4 = byteArray.length; i < length4; i += blockSize) {
      crypto.getRandomValues(byteArray.subarray(i, Math.min(length4, i + blockSize)));
    }
    return array;
  }

  // src/neuroglancer/annotation/index.ts
  var AnnotationReference = class extends RefCounted {
    constructor(id) {
      super();
      this.id = id;
      this.changed = new NullarySignal();
    }
  };
  var AnnotationType;
  (function(AnnotationType2) {
    AnnotationType2[AnnotationType2["POINT"] = 0] = "POINT";
    AnnotationType2[AnnotationType2["LINE"] = 1] = "LINE";
    AnnotationType2[AnnotationType2["AXIS_ALIGNED_BOUNDING_BOX"] = 2] = "AXIS_ALIGNED_BOUNDING_BOX";
    AnnotationType2[AnnotationType2["ELLIPSOID"] = 3] = "ELLIPSOID";
    AnnotationType2[AnnotationType2["SPHERE"] = 4] = "SPHERE";
    AnnotationType2[AnnotationType2["CONE"] = 5] = "CONE";
  })(AnnotationType || (AnnotationType = {}));
  var annotationTypes = [
    0,
    1,
    2,
    3,
    4,
    5
  ];
  var propertyTypeDataType = {
    "float32": DataType.FLOAT32,
    "uint32": DataType.UINT32,
    "int32": DataType.INT32,
    "uint16": DataType.UINT16,
    "int16": DataType.INT16,
    "uint8": DataType.UINT8,
    "int8": DataType.INT8,
    "rgb": void 0,
    "rgba": void 0
  };
  var annotationPropertyTypeHandlers = {
    "rgb": {
      serializedBytes() {
        return 3;
      },
      alignment() {
        return 1;
      },
      serializeCode(property, offset) {
        return `dv.setUint16(${offset}, ${property}, true);dv.setUint8(${offset} + 2, ${property} >>> 16);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getUint16(${offset}, true) | (dv.getUint8(${offset} + 2) << 16);`;
      },
      deserializeJson(obj) {
        return packColor(parseRGBColorSpecification(obj));
      },
      serializeJson(value) {
        return serializeColor(unpackRGB(value));
      }
    },
    "rgba": {
      serializedBytes() {
        return 4;
      },
      alignment() {
        return 1;
      },
      serializeCode(property, offset) {
        return `dv.setUint32(${offset}, ${property}, true);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getUint32(${offset}, true);`;
      },
      deserializeJson(obj) {
        return packColor(parseRGBAColorSpecification(obj));
      },
      serializeJson(value) {
        return serializeColor(unpackRGBA(value));
      }
    },
    "float32": {
      serializedBytes() {
        return 4;
      },
      alignment() {
        return 4;
      },
      serializeCode(property, offset) {
        return `dv.setFloat32(${offset}, ${property}, isLittleEndian);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getFloat32(${offset}, isLittleEndian);`;
      },
      deserializeJson(obj) {
        return verifyFloat(obj);
      },
      serializeJson(value) {
        return value;
      }
    },
    "uint32": {
      serializedBytes() {
        return 4;
      },
      alignment() {
        return 4;
      },
      serializeCode(property, offset) {
        return `dv.setUint32(${offset}, ${property}, isLittleEndian);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getUint32(${offset}, isLittleEndian);`;
      },
      deserializeJson(obj) {
        return verifyInt(obj);
      },
      serializeJson(value) {
        return value;
      }
    },
    "int32": {
      serializedBytes() {
        return 4;
      },
      alignment() {
        return 4;
      },
      serializeCode(property, offset) {
        return `dv.setInt32(${offset}, ${property}, isLittleEndian);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getInt32(${offset}, isLittleEndian);`;
      },
      deserializeJson(obj) {
        return verifyInt(obj);
      },
      serializeJson(value) {
        return value;
      }
    },
    "uint16": {
      serializedBytes() {
        return 2;
      },
      alignment() {
        return 2;
      },
      serializeCode(property, offset) {
        return `dv.setUint16(${offset}, ${property}, isLittleEndian);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getUint16(${offset}, isLittleEndian);`;
      },
      deserializeJson(obj) {
        return verifyInt(obj);
      },
      serializeJson(value) {
        return value;
      }
    },
    "int16": {
      serializedBytes() {
        return 2;
      },
      alignment() {
        return 2;
      },
      serializeCode(property, offset) {
        return `dv.setInt16(${offset}, ${property}, isLittleEndian);`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getInt16(${offset}, isLittleEndian);`;
      },
      deserializeJson(obj) {
        return verifyInt(obj);
      },
      serializeJson(value) {
        return value;
      }
    },
    "uint8": {
      serializedBytes() {
        return 1;
      },
      alignment() {
        return 1;
      },
      serializeCode(property, offset) {
        return `dv.setUint8(${offset}, ${property});`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getUint8(${offset});`;
      },
      deserializeJson(obj) {
        return verifyInt(obj);
      },
      serializeJson(value) {
        return value;
      }
    },
    "int8": {
      serializedBytes() {
        return 2;
      },
      alignment() {
        return 1;
      },
      serializeCode(property, offset) {
        return `dv.setInt8(${offset}, ${property});`;
      },
      deserializeCode(property, offset) {
        return `${property} = dv.getInt8(${offset});`;
      },
      deserializeJson(obj) {
        return verifyInt(obj);
      },
      serializeJson(value) {
        return value;
      }
    }
  };
  var MAX_BUFFER_STRIDE = 255;
  function getPropertyOffsets(rank, firstGroupInitialOffset, propertySpecs) {
    let serializedBytes = 0;
    const numProperties = propertySpecs.length;
    const permutation = new Array(numProperties);
    const propertyGroupBytes = [];
    for (let i = 0; i < numProperties; ++i) {
      permutation[i] = i;
    }
    const getAlignment = (i) => annotationPropertyTypeHandlers[propertySpecs[i].type].alignment(rank);
    permutation.sort((i, j) => getAlignment(j) - getAlignment(i));
    let propertyGroupIndex = 0;
    const offsets = new Array(numProperties);
    let propertyGroupOffset = firstGroupInitialOffset;
    const nextPropertyGroup = () => {
      propertyGroupOffset += (4 - propertyGroupOffset % 4) % 4;
      serializedBytes += propertyGroupOffset;
      propertyGroupBytes[propertyGroupIndex] = propertyGroupOffset;
      propertyGroupOffset = 0;
      ++propertyGroupIndex;
    };
    for (let outputIndex = 0; outputIndex < numProperties; ++outputIndex) {
      const propertyIndex = permutation[outputIndex];
      const spec = propertySpecs[propertyIndex];
      const handler = annotationPropertyTypeHandlers[spec.type];
      const numBytes = handler.serializedBytes(rank);
      const alignment = handler.alignment(rank);
      const alignmentOffset = (alignment - propertyGroupOffset % alignment) % alignment;
      const newStartOffset = propertyGroupOffset + alignmentOffset;
      const newEndOffset = newStartOffset + numBytes;
      const newAlignedEndOffset = newEndOffset + (4 - newEndOffset % 4) % 4;
      if (newAlignedEndOffset <= MAX_BUFFER_STRIDE) {
        propertyGroupOffset += alignmentOffset;
      } else {
        nextPropertyGroup();
      }
      offsets[propertyIndex] = { offset: propertyGroupOffset, group: propertyGroupIndex };
      propertyGroupOffset += numBytes;
    }
    nextPropertyGroup();
    return { serializedBytes, offsets, propertyGroupBytes };
  }
  var AnnotationPropertySerializer = class {
    constructor(rank, firstGroupInitialOffset, propertySpecs) {
      this.rank = rank;
      this.firstGroupInitialOffset = firstGroupInitialOffset;
      this.propertySpecs = propertySpecs;
      if (propertySpecs.length === 0) {
        this.serializedBytes = firstGroupInitialOffset;
        this.serialize = this.deserialize = () => {
        };
        this.propertyGroupBytes = [firstGroupInitialOffset];
        return;
      }
      const { serializedBytes, offsets, propertyGroupBytes } = getPropertyOffsets(rank, firstGroupInitialOffset, propertySpecs);
      this.propertyGroupBytes = propertyGroupBytes;
      let groupOffsetCode = "let groupOffset0 = offset;";
      for (let groupIndex = 1; groupIndex < propertyGroupBytes.length; ++groupIndex) {
        groupOffsetCode += `let groupOffset${groupIndex} = groupOffset${groupIndex - 1} + ${propertyGroupBytes[groupIndex - 1]}*annotationCount;`;
      }
      for (let groupIndex = 0; groupIndex < propertyGroupBytes.length; ++groupIndex) {
        groupOffsetCode += `groupOffset${groupIndex} += ${propertyGroupBytes[groupIndex]}*annotationIndex;`;
      }
      let serializeCode = groupOffsetCode;
      let deserializeCode = groupOffsetCode;
      const numProperties = propertySpecs.length;
      for (let propertyIndex = 0; propertyIndex < numProperties; ++propertyIndex) {
        const { group, offset } = offsets[propertyIndex];
        const spec = propertySpecs[propertyIndex];
        const handler = annotationPropertyTypeHandlers[spec.type];
        const propId = `properties[${propertyIndex}]`;
        const offsetExpr = `groupOffset${group} + ${offset}`;
        serializeCode += handler.serializeCode(propId, offsetExpr, rank);
        deserializeCode += handler.deserializeCode(propId, offsetExpr, rank);
      }
      this.serializedBytes = serializedBytes;
      this.serialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", serializeCode);
      this.deserialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", deserializeCode);
    }
  };
  function makeAnnotationPropertySerializers(rank, propertySpecs) {
    const serializers = [];
    for (const annotationType of annotationTypes) {
      const handler = annotationTypeHandlers[annotationType];
      serializers[annotationType] = new AnnotationPropertySerializer(rank, handler.serializedBytes(rank), propertySpecs);
    }
    return serializers;
  }
  function serializeFloatVector(buffer, offset, isLittleEndian, rank, vec) {
    for (let i = 0; i < rank; ++i) {
      buffer.setFloat32(offset, vec[i], isLittleEndian);
      offset += 4;
    }
    return offset;
  }
  function serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, vecA, vecB) {
    offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);
    offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);
    return offset;
  }
  function deserializeFloatVector(buffer, offset, isLittleEndian, rank, vec) {
    for (let i = 0; i < rank; ++i) {
      vec[i] = buffer.getFloat32(offset, isLittleEndian);
      offset += 4;
    }
    return offset;
  }
  function deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, vecA, vecB) {
    offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);
    offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);
    return offset;
  }
  var annotationTypeHandlers = {
    [1]: {
      icon: "\uA579",
      description: "Line",
      toJSON(annotation) {
        return {
          pointA: Array.from(annotation.pointA),
          pointB: Array.from(annotation.pointB)
        };
      },
      restoreState(annotation, obj, rank) {
        annotation.pointA = verifyObjectProperty(obj, "pointA", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        annotation.pointB = verifyObjectProperty(obj, "pointB", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      },
      serializedBytes(rank) {
        return 2 * 4 * rank;
      },
      serialize(buffer, offset, isLittleEndian, rank, annotation) {
        serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
      },
      deserialize: (buffer, offset, isLittleEndian, rank, id) => {
        const pointA = new Float32Array(rank);
        const pointB = new Float32Array(rank);
        deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
        return { type: 1, pointA, pointB, id, properties: [] };
      },
      visitGeometry(annotation, callback) {
        callback(annotation.pointA, false);
        callback(annotation.pointB, false);
      }
    },
    [0]: {
      icon: "\u26AC",
      description: "Point",
      toJSON: (annotation) => {
        return {
          point: Array.from(annotation.point)
        };
      },
      restoreState: (annotation, obj, rank) => {
        annotation.point = verifyObjectProperty(obj, "point", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      },
      serializedBytes: (rank) => rank * 4,
      serialize: (buffer, offset, isLittleEndian, rank, annotation) => {
        serializeFloatVector(buffer, offset, isLittleEndian, rank, annotation.point);
      },
      deserialize: (buffer, offset, isLittleEndian, rank, id) => {
        const point = new Float32Array(rank);
        deserializeFloatVector(buffer, offset, isLittleEndian, rank, point);
        return { type: 0, point, id, properties: [] };
      },
      visitGeometry(annotation, callback) {
        callback(annotation.point, false);
      }
    },
    [2]: {
      icon: "\u2751",
      description: "Bounding Box",
      toJSON: (annotation) => {
        return {
          pointA: Array.from(annotation.pointA),
          pointB: Array.from(annotation.pointB)
        };
      },
      restoreState: (annotation, obj, rank) => {
        annotation.pointA = verifyObjectProperty(obj, "pointA", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        annotation.pointB = verifyObjectProperty(obj, "pointB", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      },
      serializedBytes: (rank) => 2 * 4 * rank,
      serialize(buffer, offset, isLittleEndian, rank, annotation) {
        serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.pointA, annotation.pointB);
      },
      deserialize: (buffer, offset, isLittleEndian, rank, id) => {
        const pointA = new Float32Array(rank);
        const pointB = new Float32Array(rank);
        deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, pointA, pointB);
        return { type: 2, pointA, pointB, id, properties: [] };
      },
      visitGeometry(annotation, callback) {
        callback(annotation.pointA, false);
        callback(annotation.pointB, false);
      }
    },
    [3]: {
      icon: "\u25CE",
      description: "Ellipsoid",
      toJSON: (annotation) => {
        return {
          center: Array.from(annotation.center),
          radii: Array.from(annotation.radii)
        };
      },
      restoreState: (annotation, obj, rank) => {
        annotation.center = verifyObjectProperty(obj, "center", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        annotation.radii = verifyObjectProperty(obj, "radii", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteNonNegativeFloat));
      },
      serializedBytes: (rank) => 2 * 4 * rank,
      serialize(buffer, offset, isLittleEndian, rank, annotation) {
        serializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, annotation.center, annotation.radii);
      },
      deserialize: (buffer, offset, isLittleEndian, rank, id) => {
        const center = new Float32Array(rank);
        const radii = new Float32Array(rank);
        deserializeTwoFloatVectors(buffer, offset, isLittleEndian, rank, center, radii);
        return { type: 3, center, radii, id, properties: [] };
      },
      visitGeometry(annotation, callback) {
        callback(annotation.center, false);
        callback(annotation.radii, true);
      }
    },
    [4]: {
      icon: "\u25CF",
      description: "Sphere",
      toJSON: (annotation) => {
        return {
          center: Array.from(annotation.center)
        };
      },
      restoreState: (annotation, obj, rank) => {
        annotation.center = verifyObjectProperty(obj, "center", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
      },
      serializedBytes: (rank) => rank * 4,
      serialize: (buffer, offset, isLittleEndian, rank, annotation) => {
        serializeFloatVector(buffer, offset, isLittleEndian, rank, annotation.center);
      },
      deserialize: (buffer, offset, isLittleEndian, rank, id) => {
        const center = new Float32Array(rank);
        deserializeFloatVector(buffer, offset, isLittleEndian, rank, center);
        return { type: 4, center, id, properties: [] };
      },
      visitGeometry(annotation, callback) {
        callback(annotation.center, false);
      }
    },
    [5]: {
      icon: "\u25B3",
      description: "Cone",
      toJSON: (annotation) => {
        return {
          base: Array.from(annotation.base),
          baseRadius: annotation.baseRadius,
          axis: Array.from(annotation.axis),
          axisRadius: annotation.axisRadius
        };
      },
      restoreState: (annotation, obj, rank) => {
        annotation.base = verifyObjectProperty(obj, "base", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        annotation.baseRadius = verifyObjectProperty(obj, "baseRadius", verifyFiniteNonNegativeFloat);
        annotation.axis = verifyObjectProperty(obj, "axis", (x) => parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat));
        annotation.axisRadius = verifyObjectProperty(obj, "axisRadius", verifyFiniteNonNegativeFloat);
      },
      serializedBytes: (rank) => 2 * 4 * (rank + 1),
      serialize(buffer, offset, isLittleEndian, rank, annotation) {
        offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, annotation.base);
        buffer.setFloat32(offset, annotation.baseRadius, isLittleEndian);
        offset = serializeFloatVector(buffer, offset + 4, isLittleEndian, rank, annotation.axis);
        buffer.setFloat32(offset, annotation.axisRadius, isLittleEndian);
      },
      deserialize: (buffer, offset, isLittleEndian, rank, id) => {
        const base = new Float32Array(rank);
        const axis = new Float32Array(rank);
        offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, base);
        const baseRadius = buffer.getFloat32(offset, isLittleEndian);
        offset = deserializeFloatVector(buffer, offset + 4, isLittleEndian, rank, axis);
        const axisRadius = buffer.getFloat32(offset, isLittleEndian);
        return { type: 5, base, baseRadius, axis, axisRadius, id, properties: [] };
      },
      visitGeometry(annotation, callback) {
        annotation.baseRadius = 1;
        annotation.axisRadius = 2;
        callback(annotation.base, false);
        callback(annotation.axis, false);
      }
    }
  };
  function annotationToJson(annotation, schema) {
    const result = annotationTypeHandlers[annotation.type].toJSON(annotation, schema.rank);
    result.type = AnnotationType[annotation.type].toLowerCase();
    result.id = annotation.id;
    result.description = annotation.description || void 0;
    const { relatedSegments } = annotation;
    if (relatedSegments !== void 0 && relatedSegments.some((x) => x.length !== 0)) {
      result.segments = relatedSegments.map((segments) => segments.map((x) => x.toString()));
    }
    if (schema.properties.length !== 0) {
      const propertySpecs = schema.properties;
      result.props = annotation.properties.map((prop, i) => annotationPropertyTypeHandlers[propertySpecs[i].type].serializeJson(prop));
    }
    return result;
  }
  function restoreAnnotation(obj, schema, allowMissingId = false) {
    verifyObject(obj);
    const type = verifyObjectProperty(obj, "type", (x) => verifyEnumString(x, AnnotationType));
    const id = verifyObjectProperty(obj, "id", allowMissingId ? verifyOptionalString : verifyString) || makeAnnotationId();
    const relatedSegments = verifyObjectProperty(obj, "segments", (relObj) => {
      if (relObj === void 0) {
        return schema.relationships.map(() => []);
      }
      const a = expectArray(relObj);
      if (a.length === 0) {
        return schema.relationships.map(() => []);
      }
      if (schema.relationships.length === 1 && !Array.isArray(a[0])) {
        return [parseArray(a, (x) => Uint64.parseString(x))];
      }
      return parseArray(expectArray(relObj, schema.relationships.length), (segments) => parseArray(segments, (y) => Uint64.parseString(y)));
    });
    const properties = verifyObjectProperty(obj, "props", (propsObj) => {
      const propSpecs = schema.properties;
      if (propsObj === void 0)
        return propSpecs.map((x) => x.default);
      return parseArray(expectArray(propsObj, schema.properties.length), (x, i) => annotationPropertyTypeHandlers[propSpecs[i].type].deserializeJson(x));
    });
    const result = {
      id,
      description: verifyObjectProperty(obj, "description", verifyOptionalString),
      relatedSegments,
      properties,
      type
    };
    annotationTypeHandlers[type].restoreState(result, obj, schema.rank);
    return result;
  }
  var AnnotationSource = class extends RefCounted {
    constructor(rank, relationships = [], properties = []) {
      super();
      this.relationships = relationships;
      this.properties = properties;
      this.annotationMap = new Map();
      this.changed = new NullarySignal();
      this.readonly = false;
      this.childAdded = new Signal();
      this.childUpdated = new Signal();
      this.childDeleted = new Signal();
      this.pending = new Set();
      this.references = new Map();
      this.rank_ = rank;
      this.annotationPropertySerializers = makeAnnotationPropertySerializers(rank, properties);
    }
    get rank() {
      return this.rank_;
    }
    hasNonSerializedProperties() {
      return true;
    }
    add(annotation, commit = true) {
      this.ensureUpdated();
      if (!annotation.id) {
        annotation.id = makeAnnotationId();
      } else if (this.annotationMap.has(annotation.id)) {
        throw new Error(`Annotation id already exists: ${JSON.stringify(annotation.id)}.`);
      }
      this.annotationMap.set(annotation.id, annotation);
      this.changed.dispatch();
      this.childAdded.dispatch(annotation);
      if (!commit) {
        this.pending.add(annotation.id);
      }
      return this.getReference(annotation.id);
    }
    commit(reference) {
      this.ensureUpdated();
      const id = reference.id;
      this.pending.delete(id);
      this.changed.dispatch();
    }
    update(reference, annotation) {
      this.ensureUpdated();
      if (reference.value === null) {
        throw new Error(`Annotation already deleted.`);
      }
      reference.value = annotation;
      this.annotationMap.set(annotation.id, annotation);
      reference.changed.dispatch();
      this.changed.dispatch();
      this.childUpdated.dispatch(annotation);
    }
    [Symbol.iterator]() {
      this.ensureUpdated();
      return this.annotationMap.values();
    }
    get(id) {
      this.ensureUpdated();
      return this.annotationMap.get(id);
    }
    delete(reference) {
      if (reference.value === null) {
        return;
      }
      reference.value = null;
      this.annotationMap.delete(reference.id);
      this.pending.delete(reference.id);
      reference.changed.dispatch();
      this.changed.dispatch();
      this.childDeleted.dispatch(reference.id);
    }
    getReference(id) {
      let existing = this.references.get(id);
      if (existing !== void 0) {
        return existing.addRef();
      }
      existing = new AnnotationReference(id);
      existing.value = this.annotationMap.get(id) || null;
      this.references.set(id, existing);
      existing.registerDisposer(() => {
        this.references.delete(id);
      });
      return existing;
    }
    ensureUpdated() {
    }
    toJSON() {
      this.ensureUpdated();
      const result = [];
      const { pending } = this;
      for (const annotation of this) {
        if (pending.has(annotation.id)) {
          continue;
        }
        result.push(annotationToJson(annotation, this));
      }
      return result;
    }
    clear() {
      this.annotationMap.clear();
      this.pending.clear();
      this.changed.dispatch();
    }
    restoreState(obj) {
      this.ensureUpdated();
      const { annotationMap } = this;
      annotationMap.clear();
      this.pending.clear();
      if (obj !== void 0) {
        parseArray(obj, (x) => {
          const annotation = restoreAnnotation(x, this);
          annotationMap.set(annotation.id, annotation);
        });
      }
      for (const reference of this.references.values()) {
        const { id } = reference;
        const value = annotationMap.get(id);
        reference.value = value || null;
        reference.changed.dispatch();
      }
      this.changed.dispatch();
    }
    reset() {
      this.clear();
    }
  };
  function makeAnnotationId() {
    return getRandomHexString(160);
  }
  function serializeAnnotations(allAnnotations, propertySerializers) {
    let totalBytes = 0;
    const typeToOffset = [];
    for (const annotationType of annotationTypes) {
      const propertySerializer = propertySerializers[annotationType];
      const serializedPropertiesBytes = propertySerializer.serializedBytes;
      typeToOffset[annotationType] = totalBytes;
      const annotations = allAnnotations[annotationType];
      const count = annotations.length;
      totalBytes += serializedPropertiesBytes * count;
    }
    const typeToIds = [];
    const typeToIdMaps = [];
    const data = new ArrayBuffer(totalBytes);
    const dataView = new DataView(data);
    const isLittleEndian = ENDIANNESS === Endianness.LITTLE;
    for (const annotationType of annotationTypes) {
      const propertySerializer = propertySerializers[annotationType];
      const { rank } = propertySerializer;
      const serializeProperties = propertySerializer.serialize;
      const annotations = allAnnotations[annotationType];
      typeToIds[annotationType] = annotations.map((x) => x.id);
      typeToIdMaps[annotationType] = new Map(annotations.map((x, i) => [x.id, i]));
      const handler = annotationTypeHandlers[annotationType];
      const serialize = handler.serialize;
      const offset = typeToOffset[annotationType];
      const geometryDataStride = propertySerializer.propertyGroupBytes[0];
      for (let i = 0, count = annotations.length; i < count; ++i) {
        const annotation = annotations[i];
        serialize(dataView, offset + i * geometryDataStride, isLittleEndian, rank, annotation);
        serializeProperties(dataView, offset, i, count, isLittleEndian, annotation.properties);
      }
    }
    return { data: new Uint8Array(data), typeToIds, typeToOffset, typeToIdMaps };
  }
  var AnnotationSerializer = class {
    constructor(propertySerializers) {
      this.propertySerializers = propertySerializers;
      this.annotations = [[], [], [], [], [], []];
    }
    add(annotation) {
      this.annotations[annotation.type].push(annotation);
    }
    serialize() {
      return serializeAnnotations(this.annotations, this.propertySerializers);
    }
  };
  function fixAnnotationAfterStructuredCloning(obj) {
    if (obj == null) {
      return obj;
    }
    const { relatedSegments } = obj;
    if (relatedSegments !== void 0) {
      for (let i = 0, numRelationships = relatedSegments.length; i < numRelationships; ++i) {
        const segments = relatedSegments[i];
        if (segments === void 0)
          continue;
        relatedSegments[i] = segments.map((x) => new Uint64(x.low, x.high));
      }
    }
    return obj;
  }

  // src/neuroglancer/annotation/base.ts
  var ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID = "annotation.MetadataChunkSource";
  var ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID = "annotation.SubsetGeometryChunkSource";
  var ANNOTATION_REFERENCE_ADD_RPC_ID = "annotation.reference.add";
  var ANNOTATION_REFERENCE_DELETE_RPC_ID = "annotation.reference.delete";
  var ANNOTATION_COMMIT_UPDATE_RPC_ID = "annotation.commit";
  var ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID = "annotation.commit";
  var ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID = "annotation/SpatiallyIndexedRenderLayer";
  var ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID = "annotation/PerspectiveRenderLayer:updateSources";
  var ANNOTATION_RENDER_LAYER_RPC_ID = "annotation/RenderLayer";
  var ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID = "annotation/RenderLayer.updateSegmentation";
  var tempMat32 = mat3_exports.create();
  function forEachVisibleAnnotationChunk(projectionParameters, localPosition, renderScaleTarget, transformedSources, beginScale, callback) {
    const { displayDimensionRenderInfo, viewMatrix, projectionMat, width, height } = projectionParameters;
    const { voxelPhysicalScales } = displayDimensionRenderInfo;
    const viewDet = Math.abs(mat3_exports.determinant(mat3FromMat4(tempMat32, viewMatrix)));
    const canonicalToPhysicalScale = prod3(voxelPhysicalScales);
    const viewFrustrumVolume = getViewFrustrumVolume(projectionMat) / viewDet * canonicalToPhysicalScale;
    if (transformedSources.length === 0)
      return;
    const baseSource = transformedSources[0];
    let sourceVolume = Math.abs(baseSource.chunkLayout.detTransform) * canonicalToPhysicalScale;
    const { lowerClipDisplayBound, upperClipDisplayBound } = baseSource;
    for (let i = 0; i < 3; ++i) {
      sourceVolume *= upperClipDisplayBound[i] - lowerClipDisplayBound[i];
    }
    const effectiveVolume = Math.min(sourceVolume, viewFrustrumVolume);
    const viewportArea = width * height;
    const targetNumAnnotations = viewportArea / renderScaleTarget ** 2;
    const physicalDensityTarget = targetNumAnnotations / effectiveVolume;
    let totalPhysicalDensity = 0;
    for (let scaleIndex = transformedSources.length - 1; scaleIndex >= 0 && totalPhysicalDensity < physicalDensityTarget; --scaleIndex) {
      const transformedSource = transformedSources[scaleIndex];
      const spec = transformedSource.source.spec;
      const { chunkLayout } = transformedSource;
      const physicalVolume = prod3(chunkLayout.size) * Math.abs(chunkLayout.detTransform) * canonicalToPhysicalScale;
      const { limit, rank } = spec;
      const { nonDisplayLowerClipBound, nonDisplayUpperClipBound } = transformedSource;
      let sliceFraction = 1;
      for (let i = 0; i < rank; ++i) {
        const b = nonDisplayUpperClipBound[i] - nonDisplayLowerClipBound[i];
        if (Number.isFinite(b))
          sliceFraction /= b;
      }
      const physicalDensity = limit * sliceFraction / physicalVolume;
      let firstChunk = true;
      const newTotalPhysicalDensity = totalPhysicalDensity + physicalDensity;
      const totalPhysicalSpacing = Math.pow(1 / newTotalPhysicalDensity, 1 / 3);
      const totalPixelSpacing = Math.sqrt(viewportArea / (newTotalPhysicalDensity * effectiveVolume));
      const desiredCount = (physicalDensityTarget - totalPhysicalDensity) * physicalVolume / sliceFraction;
      const drawFraction = Math.min(1, desiredCount / spec.limit);
      forEachVisibleVolumetricChunk(projectionParameters, localPosition, transformedSource, () => {
        if (firstChunk) {
          beginScale(transformedSource, scaleIndex);
          firstChunk = false;
        }
        callback(transformedSource, scaleIndex, drawFraction, totalPhysicalSpacing, totalPixelSpacing);
      });
      totalPhysicalDensity = newTotalPhysicalDensity;
    }
  }

  // src/neuroglancer/util/trackable.ts
  var jsonCache = new WeakMap();

  // src/neuroglancer/navigation_state.ts
  var NavigationLinkType;
  (function(NavigationLinkType2) {
    NavigationLinkType2[NavigationLinkType2["LINKED"] = 0] = "LINKED";
    NavigationLinkType2[NavigationLinkType2["RELATIVE"] = 1] = "RELATIVE";
    NavigationLinkType2[NavigationLinkType2["UNLINKED"] = 2] = "UNLINKED";
  })(NavigationLinkType || (NavigationLinkType = {}));
  var NavigationSimpleLinkType;
  (function(NavigationSimpleLinkType2) {
    NavigationSimpleLinkType2[NavigationSimpleLinkType2["LINKED"] = 0] = "LINKED";
    NavigationSimpleLinkType2[NavigationSimpleLinkType2["UNLINKED"] = 2] = "UNLINKED";
  })(NavigationSimpleLinkType || (NavigationSimpleLinkType = {}));
  var tempVec32 = vec3_exports.create();
  var tempQuat = quat_exports.create();
  function displayDimensionRenderInfosEqual(a, b) {
    return arraysEqual(a.globalDimensionNames, b.globalDimensionNames) && arraysEqual(a.displayDimensionIndices, b.displayDimensionIndices) && arraysEqual(a.canonicalVoxelFactors, b.canonicalVoxelFactors) && arraysEqual(a.voxelPhysicalScales, b.voxelPhysicalScales) && a.canonicalVoxelPhysicalSize === b.canonicalVoxelPhysicalSize && arraysEqual(a.displayDimensionUnits, b.displayDimensionUnits) && arraysEqual(a.displayDimensionScales, b.displayDimensionScales);
  }

  // src/neuroglancer/visibility_priority/frontend.ts
  var WatchableVisibilityPriority = class extends WatchableValue {
    constructor(value = Number.NEGATIVE_INFINITY) {
      super(value);
    }
    get visible() {
      return this.value === Number.POSITIVE_INFINITY;
    }
    get ignored() {
      return this.value === Number.NEGATIVE_INFINITY;
    }
  };
  WatchableVisibilityPriority.VISIBLE = Number.POSITIVE_INFINITY;
  WatchableVisibilityPriority.IGNORED = Number.NEGATIVE_INFINITY;

  // src/neuroglancer/segmentation_graph/source.ts
  var VisibleSegmentEquivalencePolicy;
  (function(VisibleSegmentEquivalencePolicy2) {
    VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["MIN_REPRESENTATIVE"] = 0] = "MIN_REPRESENTATIVE";
    VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["MAX_REPRESENTATIVE"] = 1] = "MAX_REPRESENTATIVE";
    VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["REPRESENTATIVE_EXCLUDED"] = 2] = "REPRESENTATIVE_EXCLUDED";
    VisibleSegmentEquivalencePolicy2[VisibleSegmentEquivalencePolicy2["NONREPRESENTATIVE_EXCLUDED"] = 4] = "NONREPRESENTATIVE_EXCLUDED";
  })(VisibleSegmentEquivalencePolicy || (VisibleSegmentEquivalencePolicy = {}));
  var UNKNOWN_NEW_SEGMENT_ID = new Uint64(4294967295, 4294967295);

  // src/neuroglancer/util/disjoint_sets.ts
  var rankSymbol = Symbol("disjoint_sets:rank");
  var parentSymbol = Symbol("disjoint_sets:parent");
  var nextSymbol = Symbol("disjoint_sets:next");
  var prevSymbol = Symbol("disjoint_sets:prev");
  function findRepresentative(v) {
    let old = v;
    let ancestor = v[parentSymbol];
    while (ancestor !== v) {
      v = ancestor;
      ancestor = v[parentSymbol];
    }
    v = old[parentSymbol];
    while (ancestor !== v) {
      old[parentSymbol] = ancestor;
      old = v;
      v = old[parentSymbol];
    }
    return ancestor;
  }
  function linkUnequalSetRepresentatives(i, j) {
    let iRank = i[rankSymbol];
    let jRank = j[rankSymbol];
    if (iRank > jRank) {
      j[parentSymbol] = i;
      return i;
    }
    i[parentSymbol] = j;
    if (iRank === jRank) {
      j[rankSymbol] = jRank + 1;
    }
    return j;
  }
  function spliceCircularLists(i, j) {
    let iPrev = i[prevSymbol];
    let jPrev = j[prevSymbol];
    j[prevSymbol] = iPrev;
    iPrev[nextSymbol] = j;
    i[prevSymbol] = jPrev;
    jPrev[nextSymbol] = i;
  }
  function* setElementIterator(i) {
    let j = i;
    do {
      yield j;
      j = j[nextSymbol];
    } while (j !== i);
  }
  function initializeElement(v) {
    v[parentSymbol] = v;
    v[rankSymbol] = 0;
    v[nextSymbol] = v[prevSymbol] = v;
  }
  var minSymbol = Symbol("disjoint_sets:min");
  function isRootElement(v) {
    return v[parentSymbol] === v;
  }
  var DisjointUint64Sets = class {
    constructor() {
      this.map = new Map();
      this.visibleSegmentEquivalencePolicy = new WatchableValue(VisibleSegmentEquivalencePolicy.MIN_REPRESENTATIVE);
      this.generation = 0;
    }
    has(x) {
      let key = x.toString();
      let element = this.map.get(key);
      return element !== void 0;
    }
    get(x) {
      let key = x.toString();
      let element = this.map.get(key);
      if (element === void 0) {
        return x;
      }
      return findRepresentative(element)[minSymbol];
    }
    isMinElement(x) {
      let y = this.get(x);
      return y === x || Uint64.equal(y, x);
    }
    makeSet(x) {
      let key = x.toString();
      let { map } = this;
      let element = map.get(key);
      if (element === void 0) {
        element = x.clone();
        initializeElement(element);
        element[minSymbol] = element;
        map.set(key, element);
        return element;
      }
      return findRepresentative(element);
    }
    link(a, b) {
      a = this.makeSet(a);
      b = this.makeSet(b);
      if (a === b) {
        return false;
      }
      this.generation++;
      let newNode = linkUnequalSetRepresentatives(a, b);
      spliceCircularLists(a, b);
      let aMin = a[minSymbol];
      let bMin = b[minSymbol];
      const isMax = (this.visibleSegmentEquivalencePolicy.value & VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE) !== 0;
      newNode[minSymbol] = Uint64.less(aMin, bMin) === isMax ? bMin : aMin;
      return true;
    }
    linkAll(ids) {
      for (let i = 1, length4 = ids.length; i < length4; ++i) {
        this.link(ids[0], ids[i]);
      }
    }
    deleteSet(x) {
      const { map } = this;
      let changed = false;
      for (const y of this.setElements(x)) {
        map.delete(y.toString());
        changed = true;
      }
      if (changed) {
        ++this.generation;
      }
      return changed;
    }
    *setElements(a) {
      let key = a.toString();
      let element = this.map.get(key);
      if (element === void 0) {
        yield a;
      } else {
        yield* setElementIterator(element);
      }
    }
    clear() {
      let { map } = this;
      if (map.size === 0) {
        return false;
      }
      ++this.generation;
      map.clear();
      return true;
    }
    get size() {
      return this.map.size;
    }
    *mappings(temp = new Array(2)) {
      for (let element of this.map.values()) {
        temp[0] = element;
        temp[1] = findRepresentative(element)[minSymbol];
        yield temp;
      }
    }
    *roots() {
      for (let element of this.map.values()) {
        if (isRootElement(element)) {
          yield element;
        }
      }
    }
    [Symbol.iterator]() {
      return this.mappings();
    }
    toJSON() {
      let sets = new Array();
      for (let element of this.map.values()) {
        if (isRootElement(element)) {
          let members = new Array();
          for (let member of setElementIterator(element)) {
            members.push(member);
          }
          members.sort(Uint64.compare);
          sets.push(members);
        }
      }
      sets.sort((a, b) => Uint64.compare(a[0], b[0]));
      return sets.map((set6) => set6.map((element) => element.toString()));
    }
  };

  // src/neuroglancer/shared_disjoint_sets.ts
  var RPC_TYPE_ID = "DisjointUint64Sets";
  var ADD_METHOD_ID = "DisjointUint64Sets.add";
  var CLEAR_METHOD_ID = "DisjointUint64Sets.clear";
  var HIGH_BIT_REPRESENTATIVE_CHANGED_ID = "DisjointUint64Sets.highBitRepresentativeChanged";
  var DELETE_SET_METHOD_ID = "DisjointUint64Sets.deleteSet";
  var SharedDisjointUint64Sets = class extends SharedObjectCounterpart {
    constructor() {
      super(...arguments);
      this.disjointSets = new DisjointUint64Sets();
      this.changed = new NullarySignal();
    }
    get value() {
      return this;
    }
    static makeWithCounterpart(rpc2, highBitRepresentative) {
      let obj = new this();
      obj.disjointSets.visibleSegmentEquivalencePolicy = highBitRepresentative;
      obj.registerDisposer(highBitRepresentative.changed.add(() => {
        updateHighBitRepresentative(obj);
      }));
      obj.initializeCounterpart(rpc2);
      if (highBitRepresentative.value) {
        updateHighBitRepresentative(obj);
      }
      return obj;
    }
    disposed() {
      this.disjointSets = void 0;
      this.changed = void 0;
      super.disposed();
    }
    link(a, b) {
      if (this.disjointSets.link(a, b)) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke(ADD_METHOD_ID, { "id": this.rpcId, "al": a.low, "ah": a.high, "bl": b.low, "bh": b.high });
        }
        this.changed.dispatch();
        return true;
      }
      return false;
    }
    linkAll(ids) {
      for (let i = 1, length4 = ids.length; i < length4; ++i) {
        this.link(ids[0], ids[i]);
      }
    }
    has(x) {
      return this.disjointSets.has(x);
    }
    get(x) {
      return this.disjointSets.get(x);
    }
    clear() {
      if (this.disjointSets.clear()) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke(CLEAR_METHOD_ID, { "id": this.rpcId });
        }
        this.changed.dispatch();
      }
    }
    setElements(a) {
      return this.disjointSets.setElements(a);
    }
    deleteSet(x) {
      if (this.disjointSets.deleteSet(x)) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke(DELETE_SET_METHOD_ID, { "id": this.rpcId, "l": x.low, "h": x.high });
        }
        this.changed.dispatch();
      }
    }
    get size() {
      return this.disjointSets.size;
    }
    toJSON() {
      return this.disjointSets.toJSON();
    }
    restoreState(obj) {
      if (obj !== void 0) {
        let ids = [new Uint64(), new Uint64()];
        parseArray(obj, (z) => {
          parseArray(z, (s, index) => {
            ids[index % 2].parseString(String(s), 10);
            if (index !== 0) {
              this.link(ids[0], ids[1]);
            }
          });
        });
      }
    }
    assignFrom(other) {
      this.clear();
      if (other instanceof SharedDisjointUint64Sets) {
        other = other.disjointSets;
      }
      for (const [a, b] of other) {
        this.link(a, b);
      }
    }
  };
  SharedDisjointUint64Sets = __decorateClass([
    registerSharedObject(RPC_TYPE_ID)
  ], SharedDisjointUint64Sets);
  var tempA = new Uint64();
  var tempB = new Uint64();
  registerRPC(ADD_METHOD_ID, function(x) {
    let obj = this.get(x["id"]);
    tempA.low = x["al"];
    tempA.high = x["ah"];
    tempB.low = x["bl"];
    tempB.high = x["bh"];
    if (obj.disjointSets.link(tempA, tempB)) {
      obj.changed.dispatch();
    }
  });
  registerRPC(CLEAR_METHOD_ID, function(x) {
    let obj = this.get(x["id"]);
    if (obj.disjointSets.clear()) {
      obj.changed.dispatch();
    }
  });
  function updateHighBitRepresentative(obj) {
    obj.rpc.invoke(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, { "id": obj.rpcId, "value": obj.disjointSets.visibleSegmentEquivalencePolicy.value });
  }
  registerRPC(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, function(x) {
    let obj = this.get(x["id"]);
    obj.disjointSets.visibleSegmentEquivalencePolicy.value = x["value"];
  });
  registerRPC(DELETE_SET_METHOD_ID, function(x) {
    let obj = this.get(x["id"]);
    tempA.low = x["l"];
    tempA.high = x["h"];
    if (obj.disjointSets.deleteSet(tempA)) {
      obj.changed.dispatch();
    }
  });

  // src/neuroglancer/gpu_hash/hash_function.ts
  var k1 = 3432918353;
  var k2 = 461845907;
  function hashCombine(state, value) {
    value >>>= 0;
    state >>>= 0;
    value = Math.imul(value, k1) >>> 0;
    value = (value << 15 | value >>> 17) >>> 0;
    value = Math.imul(value, k2) >>> 0;
    state = (state ^ value) >>> 0;
    state = (state << 13 | state >>> 19) >>> 0;
    state = state * 5 + 3864292196 >>> 0;
    return state;
  }

  // src/neuroglancer/gpu_hash/hash_table.ts
  var NUM_ALTERNATIVES = 3;
  var DEFAULT_LOAD_FACTOR = 0.8;
  var DEBUG2 = false;
  var pendingLow = 0;
  var pendingHigh = 0;
  var backupPendingLow = 0;
  var backupPendingHigh = 0;
  var HashTableBase = class {
    constructor(hashSeeds = HashTableBase.generateHashSeeds(NUM_ALTERNATIVES)) {
      this.hashSeeds = hashSeeds;
      this.loadFactor = DEFAULT_LOAD_FACTOR;
      this.size = 0;
      this.emptyLow = 4294967295;
      this.emptyHigh = 4294967295;
      this.maxRehashAttempts = 5;
      this.maxAttempts = 5;
      this.generation = 0;
      this.mungedEmptyKey = -1;
      let initialSize = 8;
      while (initialSize < 2 * hashSeeds.length) {
        initialSize *= 2;
      }
      this.allocate(initialSize);
    }
    updateHashFunctions(numHashes) {
      this.hashSeeds = HashTableBase.generateHashSeeds(numHashes);
      this.mungedEmptyKey = -1;
    }
    tableWithMungedEmptyKey(callback) {
      const numHashes = this.hashSeeds.length;
      const emptySlots = new Array(numHashes);
      for (let i = 0; i < numHashes; ++i) {
        emptySlots[i] = this.getHash(i, this.emptyLow, this.emptyHigh);
      }
      let { mungedEmptyKey } = this;
      if (mungedEmptyKey === -1) {
        chooseMungedEmptyKey:
          while (true) {
            mungedEmptyKey = Math.random() * 16777216 >>> 0;
            for (let i = 0; i < numHashes; ++i) {
              let h = this.getHash(i, mungedEmptyKey, mungedEmptyKey);
              for (let j = 0; j < numHashes; ++j) {
                if (emptySlots[j] === h) {
                  continue chooseMungedEmptyKey;
                }
              }
            }
            this.mungedEmptyKey = mungedEmptyKey;
            break;
          }
      }
      let { table, emptyLow, emptyHigh } = this;
      for (let i = 0; i < numHashes; ++i) {
        let h = emptySlots[i];
        if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
          table[h] = mungedEmptyKey;
          table[h + 1] = mungedEmptyKey;
        }
      }
      try {
        callback(table);
      } finally {
        for (let i = 0; i < numHashes; ++i) {
          let h = emptySlots[i];
          if (table[h] === mungedEmptyKey && table[h + 1] === mungedEmptyKey) {
            table[h] = emptyLow;
            table[h + 1] = emptyHigh;
          }
        }
      }
    }
    static generateHashSeeds(numAlternatives = NUM_ALTERNATIVES) {
      return getRandomValues(new Uint32Array(numAlternatives));
    }
    getHash(hashIndex, low, high) {
      let hash = this.hashSeeds[hashIndex];
      hash = hashCombine(hash, low);
      hash = hashCombine(hash, high);
      return this.entryStride * (hash & this.tableSize - 1);
    }
    *keys() {
      let { emptyLow, emptyHigh, entryStride } = this;
      let { table } = this;
      for (let i = 0, length4 = table.length; i < length4; i += entryStride) {
        let low = table[i], high = table[i + 1];
        if (low !== emptyLow || high !== emptyHigh) {
          yield new Uint64(low, high);
        }
      }
    }
    *unsafeKeys(temp = new Uint64()) {
      let { emptyLow, emptyHigh, entryStride } = this;
      let { table } = this;
      for (let i = 0, length4 = table.length; i < length4; i += entryStride) {
        let low = table[i], high = table[i + 1];
        if (low !== emptyLow || high !== emptyHigh) {
          temp.low = low;
          temp.high = high;
          yield temp;
        }
      }
    }
    indexOfPair(low, high) {
      let { table, emptyLow, emptyHigh } = this;
      if (low === emptyLow && high === emptyHigh) {
        return -1;
      }
      for (let i = 0, numHashes = this.hashSeeds.length; i < numHashes; ++i) {
        let h = this.getHash(i, low, high);
        if (table[h] === low && table[h + 1] === high) {
          return h;
        }
      }
      return -1;
    }
    indexOf(x) {
      return this.indexOfPair(x.low, x.high);
    }
    chooseAnotherEmptyKey() {
      let { emptyLow, emptyHigh, table, entryStride } = this;
      let newLow, newHigh;
      while (true) {
        newLow = Math.random() * 4294967296 >>> 0;
        newHigh = Math.random() * 4294967296 >>> 0;
        if (newLow === emptyLow && newHigh === emptyHigh) {
          continue;
        }
        if (this.hasPair(newLow, newHigh)) {
          continue;
        }
        break;
      }
      this.emptyLow = newLow;
      this.emptyHigh = newHigh;
      for (let h = 0, length4 = table.length; h < length4; h += entryStride) {
        if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
          table[h] = newLow;
          table[h + 1] = newHigh;
        }
      }
    }
    has(x) {
      return this.indexOf(x) !== -1;
    }
    hasPair(low, high) {
      return this.indexOfPair(low, high) !== -1;
    }
    delete(x) {
      let index = this.indexOf(x);
      if (index !== -1) {
        let { table } = this;
        table[index] = this.emptyLow;
        table[index + 1] = this.emptyHigh;
        ++this.generation;
        this.size--;
        return true;
      }
      return false;
    }
    clearTable() {
      let { table, entryStride, emptyLow, emptyHigh } = this;
      let length4 = table.length;
      for (let h = 0; h < length4; h += entryStride) {
        table[h] = emptyLow;
        table[h + 1] = emptyHigh;
      }
    }
    clear() {
      if (this.size === 0) {
        return false;
      }
      this.size = 0;
      ++this.generation;
      this.clearTable();
      return true;
    }
    reserve(x) {
      if (x > this.capacity) {
        this.backupPending();
        this.grow(x);
        this.restorePending();
        return true;
      }
      return false;
    }
    swapPending(table, offset) {
      let tempLow = pendingLow, tempHigh = pendingHigh;
      this.storePending(table, offset);
      table[offset] = tempLow;
      table[offset + 1] = tempHigh;
    }
    storePending(table, offset) {
      pendingLow = table[offset];
      pendingHigh = table[offset + 1];
    }
    backupPending() {
      backupPendingLow = pendingLow;
      backupPendingHigh = pendingHigh;
    }
    restorePending() {
      pendingLow = backupPendingLow;
      pendingHigh = backupPendingHigh;
    }
    tryToInsert() {
      if (DEBUG2) {
        console.log(`tryToInsert: ${pendingLow}, ${pendingHigh}`);
      }
      let attempt = 0;
      let { emptyLow, emptyHigh, maxAttempts: maxAttempts2, table } = this;
      let numHashes = this.hashSeeds.length;
      let tableIndex = Math.floor(Math.random() * numHashes);
      while (true) {
        let h = this.getHash(tableIndex, pendingLow, pendingHigh);
        this.swapPending(table, h);
        if (pendingLow === emptyLow && pendingHigh === emptyHigh) {
          return true;
        }
        if (++attempt === maxAttempts2) {
          break;
        }
        tableIndex = (tableIndex + Math.floor(Math.random() * (numHashes - 1)) + 1) % numHashes;
      }
      return false;
    }
    allocate(tableSize) {
      this.tableSize = tableSize;
      let { entryStride } = this;
      this.table = new Uint32Array(tableSize * entryStride);
      this.maxAttempts = tableSize;
      this.clearTable();
      this.capacity = tableSize * this.loadFactor;
      this.mungedEmptyKey = -1;
    }
    rehash(oldTable, tableSize) {
      if (DEBUG2) {
        console.log("rehash begin");
      }
      this.allocate(tableSize);
      this.updateHashFunctions(this.hashSeeds.length);
      let { emptyLow, emptyHigh, entryStride } = this;
      for (let h = 0, length4 = oldTable.length; h < length4; h += entryStride) {
        let low = oldTable[h], high = oldTable[h + 1];
        if (low !== emptyLow || high !== emptyHigh) {
          this.storePending(oldTable, h);
          if (!this.tryToInsert()) {
            if (DEBUG2) {
              console.log("rehash failed");
            }
            return false;
          }
        }
      }
      if (DEBUG2) {
        console.log("rehash end");
      }
      return true;
    }
    grow(desiredTableSize) {
      if (DEBUG2) {
        console.log(`grow: ${desiredTableSize}`);
      }
      let oldTable = this.table;
      let { tableSize } = this;
      while (tableSize < desiredTableSize) {
        tableSize *= 2;
      }
      while (true) {
        for (let rehashAttempt = 0; rehashAttempt < this.maxRehashAttempts; ++rehashAttempt) {
          if (this.rehash(oldTable, tableSize)) {
            if (DEBUG2) {
              console.log(`grow end`);
            }
            return;
          }
        }
        tableSize *= 2;
      }
    }
    insertInternal() {
      ++this.generation;
      if (pendingLow === this.emptyLow && pendingHigh === this.emptyHigh) {
        this.chooseAnotherEmptyKey();
      }
      if (++this.size > this.capacity) {
        this.backupPending();
        this.grow(this.tableSize * 2);
        this.restorePending();
      }
      while (!this.tryToInsert()) {
        this.backupPending();
        this.grow(this.tableSize);
        this.restorePending();
      }
    }
  };
  var HashSetUint64 = class extends HashTableBase {
    add(x) {
      let { low, high } = x;
      if (this.hasPair(low, high)) {
        return false;
      }
      if (DEBUG2) {
        console.log(`add: ${low},${high}`);
      }
      pendingLow = low;
      pendingHigh = high;
      this.insertInternal();
      return true;
    }
    [Symbol.iterator]() {
      return this.unsafeKeys();
    }
  };
  HashSetUint64.prototype.entryStride = 2;
  var pendingValueLow = 0;
  var pendingValueHigh = 0;
  var backupPendingValueLow = 0;
  var backupPendingValueHigh = 0;
  var HashMapUint64 = class extends HashTableBase {
    set(key, value) {
      let { low, high } = key;
      if (this.hasPair(low, high)) {
        return false;
      }
      if (DEBUG2) {
        console.log(`add: ${low},${high} -> ${value.low},${value.high}`);
      }
      pendingLow = low;
      pendingHigh = high;
      pendingValueLow = value.low;
      pendingValueHigh = value.high;
      this.insertInternal();
      return true;
    }
    get(key, value) {
      let h = this.indexOf(key);
      if (h === -1) {
        return false;
      }
      let { table } = this;
      value.low = table[h + 2];
      value.high = table[h + 3];
      return true;
    }
    getValue(key) {
      let h = this.indexOf(key);
      if (h === -1) {
        return null;
      }
      let value = new Uint64();
      let { table } = this;
      value.low = table[h + 2];
      value.high = table[h + 3];
      return value;
    }
    swapPending(table, offset) {
      let tempLow = pendingValueLow, tempHigh = pendingValueHigh;
      super.swapPending(table, offset);
      table[offset + 2] = tempLow;
      table[offset + 3] = tempHigh;
    }
    storePending(table, offset) {
      super.storePending(table, offset);
      pendingValueLow = table[offset + 2];
      pendingValueHigh = table[offset + 3];
    }
    backupPending() {
      super.backupPending();
      backupPendingValueLow = pendingValueLow;
      backupPendingValueHigh = pendingValueHigh;
    }
    restorePending() {
      super.restorePending();
      pendingValueLow = backupPendingValueLow;
      pendingValueHigh = backupPendingValueHigh;
    }
    [Symbol.iterator]() {
      return this.unsafeEntries();
    }
    *entries() {
      let { emptyLow, emptyHigh, entryStride } = this;
      let { table } = this;
      for (let i = 0, length4 = table.length; i < length4; i += entryStride) {
        let low = table[i], high = table[i + 1];
        if (low !== emptyLow || high !== emptyHigh) {
          let key = new Uint64(low, high);
          let value = new Uint64(table[i + 2], table[i + 3]);
          yield [key, value];
        }
      }
    }
    *unsafeEntries(temp = [new Uint64(), new Uint64()]) {
      let { emptyLow, emptyHigh, entryStride } = this;
      let { table } = this;
      let [key, value] = temp;
      for (let i = 0, length4 = table.length; i < length4; i += entryStride) {
        let low = table[i], high = table[i + 1];
        if (low !== emptyLow || high !== emptyHigh) {
          key.low = low;
          key.high = high;
          value.low = table[i + 2];
          value.high = table[i + 3];
          yield temp;
        }
      }
    }
  };
  HashMapUint64.prototype.entryStride = 4;

  // src/neuroglancer/uint64_set.ts
  var Uint64Set = class extends SharedObjectCounterpart {
    constructor() {
      super(...arguments);
      this.hashTable = new HashSetUint64();
      this.changed = new Signal();
    }
    get value() {
      return this;
    }
    static makeWithCounterpart(rpc2) {
      let obj = new Uint64Set();
      obj.initializeCounterpart(rpc2);
      return obj;
    }
    set(x, value) {
      if (!value) {
        this.delete(x);
      } else {
        this.add(x);
      }
    }
    reserve_(x) {
      return this.hashTable.reserve(x);
    }
    reserve(x) {
      if (this.reserve_(x)) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Set.reserve", { "id": this.rpcId, "value": x });
        }
      }
    }
    add_(x) {
      let changed = false;
      for (const v of x) {
        changed = this.hashTable.add(v) || changed;
      }
      return changed;
    }
    add(x) {
      const tmp = Array().concat(x);
      if (this.add_(tmp)) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Set.add", { "id": this.rpcId, "value": tmp });
        }
        this.changed.dispatch(x, true);
      }
    }
    has(x) {
      return this.hashTable.has(x);
    }
    [Symbol.iterator]() {
      return this.hashTable.keys();
    }
    unsafeKeys() {
      return this.hashTable.unsafeKeys();
    }
    delete_(x) {
      let changed = false;
      for (const v of x) {
        changed = this.hashTable.delete(v) || changed;
      }
      return changed;
    }
    delete(x) {
      const tmp = Array().concat(x);
      if (this.delete_(Array().concat(x))) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Set.delete", { "id": this.rpcId, "value": tmp });
        }
        this.changed.dispatch(x, false);
      }
    }
    get size() {
      return this.hashTable.size;
    }
    clear() {
      if (this.hashTable.clear()) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Set.clear", { "id": this.rpcId });
        }
        this.changed.dispatch(null, false);
      }
    }
    toJSON() {
      let result = new Array();
      for (let id of this.unsafeKeys()) {
        result.push(id.toString());
      }
      result.sort();
      return result;
    }
    assignFrom(other) {
      this.clear();
      for (const key of other.unsafeKeys()) {
        this.add(key);
      }
    }
  };
  Uint64Set = __decorateClass([
    registerSharedObject("Uint64Set")
  ], Uint64Set);
  registerRPC("Uint64Set.reserve", function(x) {
    let obj = this.get(x["id"]);
    if (obj.reserve_(x["value"])) {
      obj.changed.dispatch();
    }
  });
  registerRPC("Uint64Set.add", function(x) {
    let obj = this.get(x["id"]);
    if (obj.add_(x["value"])) {
      obj.changed.dispatch();
    }
  });
  registerRPC("Uint64Set.delete", function(x) {
    let obj = this.get(x["id"]);
    if (obj.delete_(x["value"])) {
      obj.changed.dispatch();
    }
  });
  registerRPC("Uint64Set.clear", function(x) {
    let obj = this.get(x["id"]);
    if (obj.hashTable.clear()) {
      obj.changed.dispatch();
    }
  });

  // src/neuroglancer/uint64_map.ts
  var Uint64Map = class extends SharedObjectCounterpart {
    constructor() {
      super(...arguments);
      this.hashTable = new HashMapUint64();
      this.changed = new Signal();
    }
    get value() {
      return this;
    }
    static makeWithCounterpart(rpc2) {
      let obj = new Uint64Map();
      obj.initializeCounterpart(rpc2);
      return obj;
    }
    set_(key, value) {
      return this.hashTable.set(key, value);
    }
    set(key, value) {
      if (this.set_(key, value)) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Map.set", { "id": this.rpcId, "key": key, "value": value });
        }
        this.changed.dispatch(key, true);
      }
    }
    has(key) {
      return this.hashTable.has(key);
    }
    get(key, value) {
      return this.hashTable.get(key, value);
    }
    getValue(key) {
      return this.hashTable.getValue(key);
    }
    [Symbol.iterator]() {
      return this.hashTable.entries();
    }
    unsafeEntries() {
      return this.hashTable.unsafeEntries();
    }
    delete_(key) {
      return this.hashTable.delete(key);
    }
    delete(key) {
      if (this.delete_(key)) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Map.delete", { "id": this.rpcId, "key": key });
        }
        this.changed.dispatch(key, false);
      }
    }
    get size() {
      return this.hashTable.size;
    }
    assignFrom(other) {
      this.clear();
      for (const [key, value] of other.unsafeEntries()) {
        this.set(key, value);
      }
    }
    clear() {
      if (this.hashTable.clear()) {
        let { rpc: rpc2 } = this;
        if (rpc2) {
          rpc2.invoke("Uint64Map.clear", { "id": this.rpcId });
        }
        this.changed.dispatch(null, false);
      }
    }
    toJSON() {
      let result = {};
      for (let [key, value] of this.hashTable.unsafeEntries()) {
        result[key.toString()] = value.toString();
      }
      return result;
    }
  };
  Uint64Map = __decorateClass([
    registerSharedObject("Uint64Map")
  ], Uint64Map);
  registerRPC("Uint64Map.set", function(x) {
    let obj = this.get(x["id"]);
    if (obj.set_(x["key"], x["value"])) {
      obj.changed.dispatch();
    }
  });
  registerRPC("Uint64Map.delete", function(x) {
    let obj = this.get(x["id"]);
    if (obj.delete_(x["key"])) {
      obj.changed.dispatch();
    }
  });
  registerRPC("Uint64Map.clear", function(x) {
    let obj = this.get(x["id"]);
    if (obj.hashTable.clear()) {
      obj.changed.dispatch();
    }
  });

  // src/neuroglancer/segmentation_display_state/base.ts
  var VISIBLE_SEGMENTS_STATE_PROPERTIES = [
    "visibleSegments",
    "segmentEquivalences",
    "temporaryVisibleSegments",
    "temporarySegmentEquivalences",
    "useTemporaryVisibleSegments",
    "useTemporarySegmentEquivalences"
  ];
  function onVisibleSegmentsStateChanged(context, state, callback) {
    context.registerDisposer(state.visibleSegments.changed.add(callback));
    context.registerDisposer(state.segmentEquivalences.changed.add(callback));
  }
  function onTemporaryVisibleSegmentsStateChanged(context, state, callback) {
    context.registerDisposer(state.temporaryVisibleSegments.changed.add(callback));
    context.registerDisposer(state.temporarySegmentEquivalences.changed.add(callback));
    context.registerDisposer(state.useTemporaryVisibleSegments.changed.add(callback));
    context.registerDisposer(state.useTemporarySegmentEquivalences.changed.add(callback));
  }
  function getObjectKey(objectId) {
    return `${objectId.low},${objectId.high}`;
  }
  function isHighBitSegment(segmentId) {
    return segmentId.high >>> 31 ? true : false;
  }
  function getVisibleSegments(state) {
    return state.useTemporaryVisibleSegments.value ? state.temporaryVisibleSegments : state.visibleSegments;
  }
  function getSegmentEquivalences(state) {
    return state.useTemporarySegmentEquivalences.value ? state.temporarySegmentEquivalences : state.segmentEquivalences;
  }
  function forEachVisibleSegment(state, callback) {
    const visibleSegments = getVisibleSegments(state);
    const segmentEquivalences = getSegmentEquivalences(state);
    const equivalencePolicy = segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy.value;
    for (let rootObjectId of visibleSegments.unsafeKeys()) {
      if (equivalencePolicy & VisibleSegmentEquivalencePolicy.NONREPRESENTATIVE_EXCLUDED) {
        const rootObjectId2 = segmentEquivalences.get(rootObjectId);
        callback(rootObjectId, rootObjectId2);
      } else {
        if (!segmentEquivalences.disjointSets.isMinElement(rootObjectId)) {
          continue;
        }
        for (let objectId of segmentEquivalences.setElements(rootObjectId)) {
          if (equivalencePolicy & VisibleSegmentEquivalencePolicy.REPRESENTATIVE_EXCLUDED && equivalencePolicy & VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE && isHighBitSegment(objectId)) {
            continue;
          }
          callback(objectId, rootObjectId);
        }
      }
    }
  }

  // src/neuroglancer/segmentation_display_state/backend.ts
  function receiveVisibleSegmentsState(rpc2, options, target = {}) {
    for (const property of VISIBLE_SEGMENTS_STATE_PROPERTIES) {
      target[property] = rpc2.get(options[property]);
    }
    return target;
  }
  var withSegmentationLayerBackendState = (Base) => class SegmentationLayerState extends Base {
    constructor(...args) {
      const [rpc2, options] = args;
      super(rpc2, options);
      receiveVisibleSegmentsState(rpc2, options, this);
      this.transform = rpc2.get(options["transform"]);
      this.renderScaleTarget = rpc2.get(options["renderScaleTarget"]);
      const scheduleUpdateChunkPriorities = () => {
        this.chunkManager.scheduleUpdateChunkPriorities();
      };
      onTemporaryVisibleSegmentsStateChanged(this, this, scheduleUpdateChunkPriorities);
      onVisibleSegmentsStateChanged(this, this, scheduleUpdateChunkPriorities);
      this.registerDisposer(this.transform.changed.add(scheduleUpdateChunkPriorities));
      this.registerDisposer(this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities));
    }
  };
  var IndexedSegmentPropertySourceBackend = class extends ChunkSource {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.properties = options.properties;
    }
  };

  // src/neuroglancer/annotation/backend.ts
  var ANNOTATION_METADATA_CHUNK_PRIORITY = 200;
  var ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY = 60;
  var AnnotationMetadataChunk = class extends Chunk {
    freeSystemMemory() {
      this.annotation = void 0;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      msg.annotation = this.annotation;
    }
    downloadSucceeded() {
      this.systemMemoryBytes = this.gpuMemoryBytes = 0;
      super.downloadSucceeded();
    }
  };
  var AnnotationGeometryData = class {
    serialize(msg, transfers) {
      msg.data = this.data;
      msg.typeToOffset = this.typeToOffset;
      msg.typeToIds = this.typeToIds;
      msg.typeToIdMaps = this.typeToIdMaps;
      transfers.push(this.data.buffer);
    }
    get numBytes() {
      return this.data.byteLength;
    }
  };
  function GeometryChunkMixin(Base) {
    class C extends Base {
      serialize(msg, transfers) {
        super.serialize(msg, transfers);
        const { data } = this;
        if (data !== void 0) {
          data.serialize(msg, transfers);
          this.data = void 0;
        }
      }
      downloadSucceeded() {
        const { data } = this;
        this.systemMemoryBytes = this.gpuMemoryBytes = data === void 0 ? 0 : data.numBytes;
        super.downloadSucceeded();
      }
      freeSystemMemory() {
        this.data = void 0;
      }
    }
    return C;
  }
  var AnnotationGeometryChunk = class extends GeometryChunkMixin(SliceViewChunk) {
  };
  var AnnotationSubsetGeometryChunk = class extends GeometryChunkMixin(Chunk) {
  };
  var AnnotationMetadataChunkSource = class extends ChunkSource {
    constructor() {
      super(...arguments);
      this.parent = void 0;
    }
    getChunk(id) {
      const { chunks } = this;
      let chunk = chunks.get(id);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(AnnotationMetadataChunk);
        chunk.initialize(id);
        this.addChunk(chunk);
      }
      return chunk;
    }
    download(chunk, cancellationToken) {
      return this.parent.downloadMetadata(chunk, cancellationToken);
    }
  };
  AnnotationMetadataChunkSource = __decorateClass([
    registerSharedObject(ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID)
  ], AnnotationMetadataChunkSource);
  var AnnotationGeometryChunkSourceBackend = class extends SliceViewChunkSourceBackend {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.parent = rpc2.get(options.parent);
    }
  };
  AnnotationGeometryChunkSourceBackend.prototype.chunkConstructor = AnnotationGeometryChunk;
  var AnnotationSubsetGeometryChunkSource = class extends ChunkSource {
    constructor() {
      super(...arguments);
      this.parent = void 0;
    }
    getChunk(objectId) {
      const key = getObjectKey(objectId);
      const { chunks } = this;
      let chunk = chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(AnnotationSubsetGeometryChunk);
        chunk.initialize(key);
        chunk.objectId = objectId.clone();
        this.addChunk(chunk);
      }
      return chunk;
    }
    download(chunk, cancellationToken) {
      return this.parent.downloadSegmentFilteredGeometry(chunk, this.relationshipIndex, cancellationToken);
    }
  };
  AnnotationSubsetGeometryChunkSource = __decorateClass([
    registerSharedObject(ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID)
  ], AnnotationSubsetGeometryChunkSource);
  var AnnotationSource2 = class extends SharedObjectCounterpart {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.references = new Set();
      const chunkManager = this.chunkManager = rpc2.get(options.chunkManager);
      const metadataChunkSource = this.metadataChunkSource = this.registerDisposer(rpc2.getRef(options.metadataChunkSource));
      this.segmentFilteredSources = options.segmentFilteredSource.map((x, i) => {
        const source = this.registerDisposer(rpc2.getRef(x));
        source.parent = this;
        source.relationshipIndex = i;
        return source;
      });
      metadataChunkSource.parent = this;
      this.registerDisposer(chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    recomputeChunkPriorities() {
      const { chunkManager, metadataChunkSource } = this;
      for (const id of this.references) {
        chunkManager.requestChunk(metadataChunkSource.getChunk(id), ChunkPriorityTier.VISIBLE, ANNOTATION_METADATA_CHUNK_PRIORITY);
      }
    }
    add(annotation) {
      annotation;
      throw new Error("Not implemented");
    }
    delete(id) {
      id;
      throw new Error("Not implemented");
    }
    update(id, newAnnotation) {
      id;
      newAnnotation;
      throw new Error("Not implemented");
    }
  };
  registerRPC(ANNOTATION_REFERENCE_ADD_RPC_ID, function(x) {
    const obj = this.get(x.id);
    obj.references.add(x.annotation);
    obj.chunkManager.scheduleUpdateChunkPriorities();
  });
  registerRPC(ANNOTATION_REFERENCE_DELETE_RPC_ID, function(x) {
    const obj = this.get(x.id);
    obj.references.delete(x.annotation);
    obj.chunkManager.scheduleUpdateChunkPriorities();
  });
  registerRPC(ANNOTATION_COMMIT_UPDATE_RPC_ID, function(x) {
    const obj = this.get(x.id);
    const annotationId = x.annotationId;
    const newAnnotation = fixAnnotationAfterStructuredCloning(x.newAnnotation);
    let promise;
    if (annotationId === void 0) {
      promise = obj.add(newAnnotation).then((id) => ({ ...newAnnotation, id }));
    } else if (newAnnotation === null) {
      promise = obj.delete(annotationId).then(() => null);
    } else {
      promise = obj.update(annotationId, newAnnotation).then(() => newAnnotation);
    }
    promise.then((result) => {
      if (!obj.wasDisposed) {
        this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {
          id: obj.rpcId,
          annotationId: annotationId || newAnnotation.id,
          newAnnotation: result
        });
      }
    }, (error) => {
      if (!obj.wasDisposed) {
        this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {
          id: obj.rpcId,
          annotationId: annotationId || newAnnotation && newAnnotation.id,
          error: error.message
        });
      }
    });
  });
  var AnnotationSpatiallyIndexedRenderLayerBackend = class extends withChunkManager(RenderLayerBackend) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.renderScaleTarget = rpc2.get(options.renderScaleTarget);
      this.localPosition = rpc2.get(options.localPosition);
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      this.registerDisposer(this.localPosition.changed.add(scheduleUpdateChunkPriorities));
      this.registerDisposer(this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    attach(attachment) {
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      const { view } = attachment;
      attachment.registerDisposer(scheduleUpdateChunkPriorities);
      attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
      attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
      attachment.state = {
        displayDimensionRenderInfo: view.projectionParameters.value.displayDimensionRenderInfo,
        transformedSources: []
      };
    }
    recomputeChunkPriorities() {
      this.chunkManager.registerLayer(this);
      for (const attachment of this.attachments.values()) {
        const { view } = attachment;
        const visibility = view.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
          continue;
        }
        const attachmentState = attachment.state;
        const { transformedSources, displayDimensionRenderInfo } = attachmentState;
        if (transformedSources.length === 0)
          continue;
        const viewDisplayDimensionRenderInfo = view.projectionParameters.value.displayDimensionRenderInfo;
        if (displayDimensionRenderInfo !== viewDisplayDimensionRenderInfo) {
          if (!displayDimensionRenderInfosEqual(displayDimensionRenderInfo, viewDisplayDimensionRenderInfo)) {
            continue;
          }
          attachmentState.displayDimensionRenderInfo = viewDisplayDimensionRenderInfo;
        }
        const priorityTier = getPriorityTier(visibility);
        const basePriority = getBasePriority(visibility);
        const projectionParameters = view.projectionParameters.value;
        const { chunkManager } = this;
        forEachVisibleAnnotationChunk(projectionParameters, this.localPosition.value, this.renderScaleTarget.value, transformedSources[0], () => {
        }, (tsource, scaleIndex) => {
          const chunk = tsource.source.getChunk(tsource.curPositionInChunks);
          ++this.numVisibleChunksNeeded;
          if (chunk.state === ChunkState.GPU_MEMORY) {
            ++this.numVisibleChunksAvailable;
          }
          let priority = 0;
          chunkManager.requestChunk(chunk, priorityTier, basePriority + priority + SCALE_PRIORITY_MULTIPLIER * scaleIndex);
        });
      }
    }
  };
  AnnotationSpatiallyIndexedRenderLayerBackend = __decorateClass([
    registerSharedObject(ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID)
  ], AnnotationSpatiallyIndexedRenderLayerBackend);
  registerRPC(ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function(x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    attachment.state.transformedSources = deserializeTransformedSources(this, x.sources, layer);
    attachment.state.displayDimensionRenderInfo = x.displayDimensionRenderInfo;
    layer.chunkManager.scheduleUpdateChunkPriorities();
  });
  var AnnotationLayerSharedObjectCounterpart = class extends withSharedVisibility(withChunkManager(ChunkRenderLayerBackend)) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.source = rpc2.get(options.source);
      this.segmentationStates = new WatchableValue(this.getSegmentationState(options.segmentationStates));
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      this.registerDisposer(registerNested((context, states) => {
        if (states === void 0)
          return;
        for (const state of states) {
          if (state == null)
            continue;
          onVisibleSegmentsStateChanged(context, state, scheduleUpdateChunkPriorities);
          onTemporaryVisibleSegmentsStateChanged(context, state, scheduleUpdateChunkPriorities);
        }
        scheduleUpdateChunkPriorities();
      }, this.segmentationStates));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => this.recomputeChunkPriorities()));
    }
    recomputeChunkPriorities() {
      const visibility = this.visibility.value;
      if (visibility === Number.NEGATIVE_INFINITY) {
        return;
      }
      const { segmentationStates: { value: states }, source: { segmentFilteredSources } } = this;
      if (states === void 0)
        return;
      const { chunkManager } = this;
      chunkManager.registerLayer(this);
      const numRelationships = states.length;
      for (let i = 0; i < numRelationships; ++i) {
        const state = states[i];
        if (state == null) {
          continue;
        }
        const priorityTier = getPriorityTier(visibility);
        const basePriority = getBasePriority(visibility);
        const source = segmentFilteredSources[i];
        forEachVisibleSegment(state, (objectId) => {
          const chunk = source.getChunk(objectId);
          ++this.numVisibleChunksNeeded;
          if (chunk.state === ChunkState.GPU_MEMORY) {
            ++this.numVisibleChunksAvailable;
          }
          chunkManager.requestChunk(chunk, priorityTier, basePriority + ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY);
        });
      }
    }
    getSegmentationState(msg) {
      if (msg === void 0)
        return void 0;
      return msg.map((x) => {
        if (x == null) {
          return x;
        }
        return receiveVisibleSegmentsState(this.rpc, x);
      });
    }
  };
  AnnotationLayerSharedObjectCounterpart = __decorateClass([
    registerSharedObject(ANNOTATION_RENDER_LAYER_RPC_ID)
  ], AnnotationLayerSharedObjectCounterpart);
  registerRPC(ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, function(x) {
    const obj = this.get(x.id);
    obj.segmentationStates.value = obj.getSegmentationState(x.segmentationStates);
  });

  // src/neuroglancer/credentials_provider/index.ts
  function makeCachedCredentialsGetter(getUncached) {
    let cachedCredentials;
    let pendingCredentials;
    let pendingCancellationToken;
    return (invalidCredentials, cancellationToken) => {
      if (pendingCredentials !== void 0 && (cachedCredentials === void 0 || invalidCredentials === void 0 || cachedCredentials.generation !== invalidCredentials.generation)) {
        if (cachedCredentials === void 0) {
          pendingCancellationToken.addConsumer(cancellationToken);
        }
        return pendingCredentials;
      }
      cachedCredentials = void 0;
      pendingCancellationToken = new MultipleConsumerCancellationTokenSource();
      pendingCredentials = getUncached(invalidCredentials, pendingCancellationToken).then((credentials) => {
        cachedCredentials = credentials;
        pendingCancellationToken = void 0;
        return credentials;
      }, (reason) => {
        if (pendingCancellationToken.isCanceled) {
          pendingCancellationToken = void 0;
          pendingCredentials = void 0;
        }
        throw reason;
      });
      return pendingCredentials;
    };
  }

  // src/neuroglancer/credentials_provider/shared_common.ts
  var CREDENTIALS_PROVIDER_RPC_ID = "CredentialsProvider";
  var CREDENTIALS_PROVIDER_GET_RPC_ID = "CredentialsProvider.get";

  // src/neuroglancer/credentials_provider/shared_counterpart.ts
  var SharedCredentialsProviderCounterpart = class extends SharedObjectCounterpart {
    constructor() {
      super(...arguments);
      this.get = makeCachedCredentialsGetter((invalidCredentials, cancellationToken) => this.rpc.promiseInvoke(CREDENTIALS_PROVIDER_GET_RPC_ID, { providerId: this.rpcId, invalidCredentials }, cancellationToken));
    }
  };
  SharedCredentialsProviderCounterpart = __decorateClass([
    registerSharedObject(CREDENTIALS_PROVIDER_RPC_ID)
  ], SharedCredentialsProviderCounterpart);
  function WithSharedCredentialsProviderCounterpart() {
    return function(Base) {
      return class extends Base {
        constructor(...args) {
          super(...args);
          const options = args[1];
          this.credentialsProvider = this.rpc.getOptionalRef(options["credentialsProvider"]);
        }
      };
    };
  }

  // src/neuroglancer/util/http_request.ts
  var HttpError = class extends Error {
    constructor(url, status, statusText, response) {
      let message = `Fetching ${JSON.stringify(url)} resulted in HTTP error ${status}`;
      if (statusText) {
        message += `: ${statusText}`;
      }
      message += ".";
      super(message);
      this.name = "HttpError";
      this.message = message;
      this.url = url;
      this.status = status;
      this.statusText = statusText;
      if (response) {
        this.response = response;
      }
    }
    static fromResponse(response) {
      return new HttpError(response.url, response.status, response.statusText, response);
    }
    static fromRequestError(input, error) {
      if (error instanceof TypeError) {
        let url;
        if (typeof input === "string") {
          url = input;
        } else {
          url = input.url;
        }
        return new HttpError(url, 0, "Network or CORS error");
      }
      return error;
    }
  };
  var maxAttempts = 32;
  var minDelayMilliseconds = 500;
  var maxDelayMilliseconds = 1e4;
  function pickDelay(attemptNumber) {
    return Math.min(2 ** attemptNumber * minDelayMilliseconds, maxDelayMilliseconds / 2) * (1 + Math.random());
  }
  async function fetchOk(input, init) {
    var _a;
    for (let requestAttempt = 0; ; ) {
      if ((_a = init == null ? void 0 : init.signal) == null ? void 0 : _a.aborted) {
        throw CANCELED;
      }
      let response;
      try {
        response = await fetch(input, init);
      } catch (error) {
        throw HttpError.fromRequestError(input, error);
      }
      if (!response.ok) {
        const { status } = response;
        if (status === 429 || status === 503 || status === 504) {
          if (++requestAttempt !== maxAttempts) {
            await new Promise((resolve) => setTimeout(resolve, pickDelay(requestAttempt - 1)));
            continue;
          }
        }
        throw HttpError.fromResponse(response);
      }
      return response;
    }
  }
  function responseArrayBuffer(response) {
    return response.arrayBuffer();
  }
  function responseJson(response) {
    return response.json();
  }
  async function cancellableFetchOk(input, init, transformResponse, cancellationToken = uncancelableToken) {
    if (cancellationToken === uncancelableToken) {
      const response = await fetchOk(input, init);
      return await transformResponse(response);
    }
    const abortController = new AbortController();
    const unregisterCancellation = cancellationToken.add(() => abortController.abort());
    try {
      const response = await fetchOk(input, { ...init, signal: abortController.signal });
      return await transformResponse(response);
    } finally {
      unregisterCancellation();
    }
  }
  var tempUint642 = new Uint64();
  function getByteRangeHeader(startOffset, endOffset) {
    let endOffsetStr;
    if (typeof endOffset === "number") {
      endOffsetStr = `${endOffset - 1}`;
    } else {
      Uint64.decrement(tempUint642, endOffset);
      endOffsetStr = tempUint642.toString();
    }
    return { "Range": `bytes=${startOffset}-${endOffsetStr}` };
  }
  function parseUrl(url) {
    const urlProtocolPattern = /^([^:\/]+):\/\/([^\/]+)((?:\/.*)?)$/;
    let match = url.match(urlProtocolPattern);
    if (match === null) {
      throw new Error(`Invalid URL: ${JSON.stringify(url)}`);
    }
    return { protocol: match[1], host: match[2], path: match[3] };
  }
  function isNotFoundError(e) {
    if (!(e instanceof HttpError))
      return false;
    return e.status === 0 || e.status === 403 || e.status === 404;
  }

  // src/neuroglancer/credentials_provider/http_request.ts
  var maxCredentialsAttempts = 3;
  async function fetchWithCredentials(credentialsProvider, input, init, transformResponse, applyCredentials, errorHandler, cancellationToken = uncancelableToken) {
    let credentials;
    credentialsLoop:
      for (let credentialsAttempt = 0; ; ) {
        throwIfCanceled(cancellationToken);
        if (credentialsAttempt > 1) {
          await new Promise((resolve) => setTimeout(resolve, pickDelay(credentialsAttempt - 2)));
        }
        credentials = await credentialsProvider.get(credentials, cancellationToken);
        try {
          return await cancellableFetchOk(typeof input === "function" ? input(credentials.credentials) : input, applyCredentials(credentials.credentials, init), transformResponse, cancellationToken);
        } catch (error) {
          if (error instanceof HttpError) {
            if (errorHandler(error, credentials.credentials) === "refresh") {
              if (++credentialsAttempt === maxCredentialsAttempts)
                throw error;
              continue credentialsLoop;
            }
          }
          throw error;
        }
      }
  }

  // src/neuroglancer/credentials_provider/oauth2.ts
  function fetchWithOAuth2Credentials(credentialsProvider, input, init, transformResponse, cancellationToken = uncancelableToken) {
    if (credentialsProvider === void 0) {
      return cancellableFetchOk(input, init, transformResponse, cancellationToken);
    }
    return fetchWithCredentials(credentialsProvider, input, init, transformResponse, (credentials, init2) => {
      if (!credentials.accessToken)
        return init2;
      const headers = new Headers(init2.headers);
      headers.set("Authorization", `${credentials.tokenType} ${credentials.accessToken}`);
      return { ...init2, headers };
    }, (error, credentials) => {
      const { status } = error;
      if (status === 401) {
        return "refresh";
      } else if (status === 403 && !credentials.accessToken) {
        return "refresh";
      }
      if (error instanceof Error && credentials.email !== void 0) {
        error.message += `  (Using credentials for ${JSON.stringify(credentials.email)})`;
      }
      throw error;
    }, cancellationToken);
  }

  // src/neuroglancer/datasource/brainmaps/api.ts
  function makeRequest(instance, credentialsProvider, httpCall, cancellationToken = uncancelableToken) {
    return fetchWithOAuth2Credentials(credentialsProvider, `${instance.serverUrl}${httpCall.path}`, { method: httpCall.method, body: httpCall.payload }, httpCall.responseType === "json" ? responseJson : responseArrayBuffer, cancellationToken);
  }

  // src/neuroglancer/datasource/brainmaps/base.ts
  var VolumeChunkEncoding;
  (function(VolumeChunkEncoding6) {
    VolumeChunkEncoding6[VolumeChunkEncoding6["RAW"] = 0] = "RAW";
    VolumeChunkEncoding6[VolumeChunkEncoding6["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding6[VolumeChunkEncoding6["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
  })(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
  var VolumeSourceParameters = class {
  };
  VolumeSourceParameters.RPC_ID = "brainmaps/VolumeChunkSource";
  var MultiscaleMeshSourceParameters = class {
  };
  MultiscaleMeshSourceParameters.RPC_ID = "brainmaps/MultiscaleMeshSource";
  var MeshSourceParameters = class {
  };
  MeshSourceParameters.RPC_ID = "brainmaps/MeshSource";
  var SkeletonSourceParameters = class {
  };
  SkeletonSourceParameters.RPC_ID = "brainmaps/SkeletonSource";
  var AnnotationSourceParameters = class {
  };
  AnnotationSourceParameters.RPC_ID = "brainmaps/Annotation";
  var AnnotationSpatialIndexSourceParameters = class {
  };
  AnnotationSpatialIndexSourceParameters.RPC_ID = "brainmaps/AnnotationSpatialIndex";

  // src/neuroglancer/mesh/base.ts
  var MESH_LAYER_RPC_ID = "mesh/MeshLayer";
  var MULTISCALE_MESH_LAYER_RPC_ID = "mesh/MultiscaleMeshLayer";
  var FRAGMENT_SOURCE_RPC_ID = "mesh/FragmentSource";
  var MULTISCALE_FRAGMENT_SOURCE_RPC_ID = "mesh/MultiscaleFragmentSource";
  var VertexPositionFormat;
  (function(VertexPositionFormat2) {
    VertexPositionFormat2[VertexPositionFormat2["float32"] = 0] = "float32";
    VertexPositionFormat2[VertexPositionFormat2["uint10"] = 1] = "uint10";
    VertexPositionFormat2[VertexPositionFormat2["uint16"] = 2] = "uint16";
  })(VertexPositionFormat || (VertexPositionFormat = {}));

  // src/neuroglancer/util/zorder.ts
  function getOctreeChildIndex(x, y, z) {
    return x & 1 | y << 1 & 2 | z << 2 & 4;
  }
  function decodeZIndexCompressed(zindex, xBits, yBits, zBits) {
    const maxCoordBits = Math.max(xBits, yBits, zBits);
    let inputBit = 0;
    let inputValue = zindex.low;
    let x = 0, y = 0, z = 0;
    for (let coordBit = 0; coordBit < maxCoordBits; ++coordBit) {
      if (coordBit < xBits) {
        const bit = inputValue >>> inputBit & 1;
        x |= bit << coordBit;
        if (inputBit === 31) {
          inputBit = 0;
          inputValue = zindex.high;
        } else {
          ++inputBit;
        }
      }
      if (coordBit < yBits) {
        const bit = inputValue >>> inputBit & 1;
        y |= bit << coordBit;
        if (inputBit === 31) {
          inputBit = 0;
          inputValue = zindex.high;
        } else {
          ++inputBit;
        }
      }
      if (coordBit < zBits) {
        const bit = inputValue >>> inputBit & 1;
        z |= bit << coordBit;
        if (inputBit === 31) {
          inputBit = 0;
          inputValue = zindex.high;
        } else {
          ++inputBit;
        }
      }
    }
    return Uint32Array.of(x, y, z);
  }
  function encodeZIndexCompressed3d(zindex, xBits, yBits, zBits, x, y, z) {
    const maxBits = Math.max(xBits, yBits, zBits);
    let outputBit = 0;
    let outputNum = 0;
    let isHigh = false;
    function writeBit(b) {
      outputNum |= (b & 1) << outputBit;
      if (++outputBit === 32) {
        zindex.low = outputNum >>> 0;
        outputNum = 0;
        outputBit = 0;
        isHigh = true;
      }
    }
    for (let bit = 0; bit < maxBits; ++bit) {
      if (bit < xBits) {
        writeBit(x >> bit & 1);
      }
      if (bit < yBits) {
        writeBit(y >> bit & 1);
      }
      if (bit < zBits) {
        writeBit(z >> bit & 1);
      }
    }
    if (isHigh) {
      zindex.high = outputNum >>> 0;
    } else {
      zindex.high = 0;
      zindex.low = outputNum >>> 0;
    }
    return zindex;
  }
  function encodeZIndexCompressed(zindex, position, shape) {
    let outputBit = 0;
    const rank = position.length;
    let outputNum = 0;
    let isHigh = false;
    function writeBit(b) {
      outputNum |= (b & 1) << outputBit;
      if (++outputBit === 32) {
        zindex.low = outputNum >>> 0;
        outputNum = 0;
        outputBit = 0;
        isHigh = true;
      }
    }
    for (let bit = 0; bit < 32; ++bit) {
      for (let dim = 0; dim < rank; ++dim) {
        if (shape[dim] - 1 >>> bit) {
          writeBit(position[dim] >>> bit);
        }
      }
    }
    if (isHigh) {
      zindex.high = outputNum >>> 0;
    } else {
      zindex.high = 0;
      zindex.low = outputNum >>> 0;
    }
    return zindex;
  }
  function lessMsb(a, b) {
    return a < b && a < (a ^ b);
  }
  function zorder3LessThan(x0, y0, z0, x1, y1, z1) {
    let mostSignificant0 = z0, mostSignificant1 = z1;
    if (lessMsb(mostSignificant0 ^ mostSignificant1, y0 ^ y1)) {
      mostSignificant0 = y0;
      mostSignificant1 = y1;
    }
    if (lessMsb(mostSignificant0 ^ mostSignificant1, x0 ^ x1)) {
      mostSignificant0 = x0;
      mostSignificant1 = x1;
    }
    return mostSignificant0 < mostSignificant1;
  }

  // src/neuroglancer/mesh/multiscale.ts
  function getDesiredMultiscaleMeshChunks(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, callback) {
    const { octree, lodScales, chunkGridSpatialOrigin, chunkShape } = manifest;
    const maxLod = lodScales.length - 1;
    const m00 = modelViewProjection[0], m01 = modelViewProjection[4], m02 = modelViewProjection[8], m10 = modelViewProjection[1], m11 = modelViewProjection[5], m12 = modelViewProjection[9], m30 = modelViewProjection[3], m31 = modelViewProjection[7], m32 = modelViewProjection[11], m33 = modelViewProjection[15];
    const minWXcoeff = m30 > 0 ? 0 : 1;
    const minWYcoeff = m31 > 0 ? 0 : 1;
    const minWZcoeff = m32 > 0 ? 0 : 1;
    const nearA = clippingPlanes[4 * 4], nearB = clippingPlanes[4 * 4 + 1], nearC = clippingPlanes[4 * 4 + 2], nearD = clippingPlanes[4 * 4 + 3];
    function getPointW(x, y, z) {
      return m30 * x + m31 * y + m32 * z + m33;
    }
    function getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper) {
      return getPointW(xLower + minWXcoeff * (xUpper - xLower), yLower + minWYcoeff * (yUpper - yLower), zLower + minWZcoeff * (zUpper - zLower));
    }
    const minWClip = getPointW(-nearD * nearA, -nearD * nearB, -nearD * nearC);
    const objectXLower = manifest.clipLowerBound[0], objectYLower = manifest.clipLowerBound[1], objectZLower = manifest.clipLowerBound[2];
    const objectXUpper = manifest.clipUpperBound[0], objectYUpper = manifest.clipUpperBound[1], objectZUpper = manifest.clipUpperBound[2];
    const xScale = Math.sqrt((m00 * viewportWidth) ** 2 + (m10 * viewportHeight) ** 2);
    const yScale = Math.sqrt((m01 * viewportWidth) ** 2 + (m11 * viewportHeight) ** 2);
    const zScale = Math.sqrt((m02 * viewportWidth) ** 2 + (m12 * viewportHeight) ** 2);
    const scaleFactor = Math.max(xScale, yScale, zScale);
    function handleChunk(lod, row, priorLodScale) {
      const size = 1 << lod;
      const rowOffset = row * 5;
      const gridX = octree[rowOffset], gridY = octree[rowOffset + 1], gridZ = octree[rowOffset + 2], childBegin = octree[rowOffset + 3], childEndAndEmpty = octree[rowOffset + 4];
      let xLower = gridX * size * chunkShape[0] + chunkGridSpatialOrigin[0], yLower = gridY * size * chunkShape[1] + chunkGridSpatialOrigin[1], zLower = gridZ * size * chunkShape[2] + chunkGridSpatialOrigin[2];
      let xUpper = xLower + size * chunkShape[0], yUpper = yLower + size * chunkShape[1], zUpper = zLower + size * chunkShape[2];
      xLower = Math.max(xLower, objectXLower);
      yLower = Math.max(yLower, objectYLower);
      zLower = Math.max(zLower, objectZLower);
      xUpper = Math.min(xUpper, objectXUpper);
      yUpper = Math.min(yUpper, objectYUpper);
      zUpper = Math.min(zUpper, objectZUpper);
      if (isAABBVisible(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes)) {
        const minW = Math.max(minWClip, getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper));
        const pixelSize = minW / scaleFactor;
        if (priorLodScale === 0 || pixelSize * detailCutoff < priorLodScale) {
          const lodScale = lodScales[lod];
          if (lodScale !== 0) {
            callback(lod, row, lodScale / pixelSize, childEndAndEmpty >>> 31);
          }
          if (lod > 0 && (lodScale === 0 || pixelSize * detailCutoff < lodScale)) {
            const nextPriorLodScale = lodScale === 0 ? priorLodScale : lodScale;
            const childEnd = (childEndAndEmpty & 2147483647) >>> 0;
            for (let childRow = childBegin; childRow < childEnd; ++childRow) {
              handleChunk(lod - 1, childRow, nextPriorLodScale);
            }
          }
        }
      }
    }
    handleChunk(maxLod, octree.length / 5 - 1, 0);
  }

  // src/neuroglancer/mesh/triangle_strips.ts
  var DEBUG_TIMING = false;
  function normalizeTriangleVertexOrder(indices) {
    let maxVertex = 0;
    for (let i = 0, length4 = indices.length; i < length4; i += 3) {
      let a = indices[i], b = indices[i + 1], c = indices[i + 2];
      let t;
      if (a > b) {
        t = a;
        a = b;
        b = t;
      }
      if (b > c) {
        t = b;
        b = c;
        c = t;
      }
      if (a > b) {
        t = a;
        a = b;
        b = t;
      }
      indices[i] = a;
      indices[i + 1] = b;
      indices[i + 2] = c;
      if (c > maxVertex)
        maxVertex = c;
    }
    return maxVertex;
  }
  var collisions = 0;
  function hashTableInsert(table, numBuckets, value, emptyValue, hashCode, equals6) {
    const mask = numBuckets - 1 >>> 0;
    let bucket = (hashCode & mask) >>> 0;
    for (let probe = 0; true; ++probe) {
      const x = table[bucket];
      if (x === emptyValue) {
        table[bucket] = value;
        return value;
      }
      if (equals6(x)) {
        return x;
      }
      ++collisions;
      bucket = (bucket + probe + 1 & mask) >>> 0;
    }
  }
  function hashEdge(a, b) {
    return hashCombine(hashCombine(0, a), b);
  }
  var nextEdgeTable = 1053042;
  function getNextEdge(edgeIndexAndFlipped) {
    return nextEdgeTable >>> edgeIndexAndFlipped * 3 & 7;
  }
  function getBaseIndex(entry) {
    return (entry >>> 2) * 3;
  }
  function getEdgeIndex(entry) {
    return entry & 3;
  }
  function vertexAIndex(edgeIndex) {
    return edgeIndex >>> 1;
  }
  function vertexBIndex(edgeIndex) {
    return 1 + (edgeIndex + 1 >>> 1);
  }
  function vertexCIndex(edgeIndex) {
    return 2 - edgeIndex;
  }
  function getEdgeMapSize(numIndices) {
    const numEdges = numIndices;
    const edgeMapSize = 2 ** Math.ceil(Math.log2(numEdges));
    return edgeMapSize * 4;
  }
  function computeTriangleAdjacencies(triangleAdjacencies, indices, edgeMap) {
    const numTriangles = indices.length / 3;
    const edgeMapSize = edgeMap.length;
    const emptyEntry = 4294967295;
    triangleAdjacencies.fill(emptyEntry);
    edgeMap.fill(emptyEntry);
    for (let triangle = 0; triangle < numTriangles; ++triangle) {
      const baseIndex = triangle * 3;
      for (let edgeIndex = 0; edgeIndex < 3; ++edgeIndex) {
        const vertexA0 = indices[baseIndex + vertexAIndex(edgeIndex)];
        const vertexB0 = indices[baseIndex + vertexBIndex(edgeIndex)];
        const newEntry = triangle << 2 | edgeIndex;
        const existingEntry = hashTableInsert(edgeMap, edgeMapSize, newEntry, emptyEntry, hashEdge(vertexA0, vertexB0), (x) => {
          const otherBaseIndex = getBaseIndex(x);
          const otherEdgeIndex = getEdgeIndex(x);
          const vertexA1 = indices[otherBaseIndex + vertexAIndex(otherEdgeIndex)];
          const vertexB1 = indices[otherBaseIndex + vertexBIndex(otherEdgeIndex)];
          return vertexA0 === vertexA1 && vertexB0 === vertexB1;
        });
        if (existingEntry !== newEntry) {
          const otherBaseIndex = getBaseIndex(existingEntry);
          const otherEdgeIndex = getEdgeIndex(existingEntry);
          triangleAdjacencies[otherBaseIndex + otherEdgeIndex] = newEntry;
          triangleAdjacencies[baseIndex + edgeIndex] = existingEntry;
        }
      }
    }
    return triangleAdjacencies;
  }
  function emitTriangleStrips(indices, triangleAdjacencies, output, outputIndex) {
    const invalidVertex = ~0 >>> 32 - 8 * output.BYTES_PER_ELEMENT;
    const numIndices = indices.length;
    const numTriangles = numIndices / 3;
    const emptyEntry = 4294967295;
    startNewStrip:
      for (let triangle = 0; triangle < numTriangles; ++triangle) {
        let baseIndex = triangle * 3;
        if (indices[baseIndex] === invalidVertex) {
          continue;
        }
        for (let edgeIndex = 0; edgeIndex < 3; ++edgeIndex) {
          let entry = triangleAdjacencies[baseIndex + edgeIndex];
          if (entry === emptyEntry)
            continue;
          let otherBaseIndex = getBaseIndex(entry);
          if (indices[otherBaseIndex] === invalidVertex)
            continue;
          let otherEdgeIndex = getEdgeIndex(entry);
          output[outputIndex++] = indices[baseIndex + vertexCIndex(edgeIndex)];
          output[outputIndex++] = indices[baseIndex + vertexAIndex(edgeIndex)];
          output[outputIndex++] = indices[baseIndex + vertexBIndex(edgeIndex)];
          let edgeIndexAndFlipped = otherEdgeIndex;
          while (true) {
            indices[baseIndex] = invalidVertex;
            baseIndex = otherBaseIndex;
            output[outputIndex++] = indices[baseIndex + vertexCIndex(edgeIndexAndFlipped & 3)];
            edgeIndexAndFlipped = getNextEdge(edgeIndexAndFlipped);
            entry = triangleAdjacencies[baseIndex + (edgeIndexAndFlipped & 3)];
            if (entry === emptyEntry || indices[otherBaseIndex = getBaseIndex(entry)] === invalidVertex) {
              output[outputIndex++] = invalidVertex;
              indices[baseIndex] = invalidVertex;
              continue startNewStrip;
            }
            edgeIndexAndFlipped = getEdgeIndex(entry) | edgeIndexAndFlipped & 4;
          }
        }
        output[outputIndex++] = indices[baseIndex];
        output[outputIndex++] = indices[baseIndex + 1];
        output[outputIndex++] = indices[baseIndex + 2];
        indices[baseIndex] = invalidVertex;
        output[outputIndex++] = invalidVertex;
      }
    return outputIndex;
  }
  function computeTriangleStrips(indices, subChunkOffsets) {
    if (indices.length === 0)
      return indices;
    collisions = 0;
    if (subChunkOffsets === void 0) {
      subChunkOffsets = Uint32Array.of(0, indices.length);
    }
    let adjacenciesElapsed = 0;
    let emitElapsed = 0;
    let startTime = 0, midTime = 0, endTime = 0;
    const maxVertexIndex = normalizeTriangleVertexOrder(indices);
    const outputBufferSize = indices.length / 3 * 4;
    const output = maxVertexIndex >= 65535 ? new Uint32Array(outputBufferSize) : new Uint16Array(outputBufferSize);
    let outputIndex = 0;
    let maxSubChunkIndices = 0;
    const numSubChunks = subChunkOffsets.length - 1;
    for (let subChunk = 0; subChunk < numSubChunks; ++subChunk) {
      maxSubChunkIndices = Math.max(maxSubChunkIndices, subChunkOffsets[subChunk + 1] - subChunkOffsets[subChunk]);
    }
    const triangleAdjacencies = new Uint32Array(maxSubChunkIndices);
    const edgeMap = new Uint32Array(getEdgeMapSize(maxSubChunkIndices));
    let subChunkOffset = subChunkOffsets[0];
    for (let subChunk = 0; subChunk < numSubChunks; ++subChunk) {
      subChunkOffsets[subChunk] = outputIndex;
      const subChunkEnd = subChunkOffsets[subChunk + 1];
      const subIndices = indices.subarray(subChunkOffset, subChunkEnd);
      if (DEBUG_TIMING)
        startTime = Date.now();
      computeTriangleAdjacencies(triangleAdjacencies, subIndices, edgeMap);
      if (DEBUG_TIMING)
        midTime = Date.now();
      outputIndex = emitTriangleStrips(subIndices, triangleAdjacencies, output, outputIndex);
      if (DEBUG_TIMING) {
        endTime = Date.now();
        adjacenciesElapsed += midTime - startTime;
        emitElapsed += endTime - midTime;
      }
      subChunkOffset = subChunkEnd;
    }
    --outputIndex;
    subChunkOffsets[numSubChunks] = outputIndex;
    const shrunkOutput = new output.constructor(outputIndex);
    shrunkOutput.set(output.subarray(0, outputIndex));
    if (DEBUG_TIMING) {
      console.log(`reduced from ${indices.byteLength}(${indices.BYTES_PER_ELEMENT}) -> ${shrunkOutput.byteLength}(${shrunkOutput.BYTES_PER_ELEMENT}): adj=${adjacenciesElapsed}, emit=${emitElapsed}, ${collisions}/${indices.length} collisions`);
    }
    return shrunkOutput;
  }

  // src/neuroglancer/mesh/backend.ts
  var MESH_OBJECT_MANIFEST_CHUNK_PRIORITY = 100;
  var MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY = 50;
  var CONVERT_TO_TRIANGLE_STRIPS = false;
  var ManifestChunk = class extends Chunk {
    constructor() {
      super();
      this.objectId = new Uint64();
    }
    initializeManifestChunk(key, objectId) {
      super.initialize(key);
      this.objectId.assign(objectId);
    }
    freeSystemMemory() {
      this.fragmentIds = null;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      msg.fragmentIds = this.fragmentIds;
    }
    downloadSucceeded() {
      this.systemMemoryBytes = 100;
      this.gpuMemoryBytes = 0;
      super.downloadSucceeded();
      if (this.priorityTier < ChunkPriorityTier.RECENT) {
        this.source.chunkManager.scheduleUpdateChunkPriorities();
      }
    }
    toString() {
      return this.objectId.toString();
    }
  };
  function serializeMeshData(data, msg, transfers) {
    const { vertexPositions, indices, vertexNormals, strips } = data;
    msg["vertexPositions"] = vertexPositions;
    msg["indices"] = indices;
    msg["strips"] = strips;
    msg["vertexNormals"] = vertexNormals;
    let vertexPositionsBuffer = vertexPositions.buffer;
    transfers.push(vertexPositionsBuffer);
    let indicesBuffer = indices.buffer;
    if (indicesBuffer !== vertexPositionsBuffer) {
      transfers.push(indicesBuffer);
    }
    transfers.push(vertexNormals.buffer);
  }
  function getMeshDataSize(data) {
    let { vertexPositions, indices, vertexNormals } = data;
    return vertexPositions.byteLength + indices.byteLength + vertexNormals.byteLength;
  }
  var FragmentChunk = class extends Chunk {
    constructor() {
      super();
      this.manifestChunk = null;
      this.fragmentId = null;
      this.meshData = null;
    }
    initializeFragmentChunk(key, manifestChunk, fragmentId) {
      super.initialize(key);
      this.manifestChunk = manifestChunk;
      this.fragmentId = fragmentId;
    }
    freeSystemMemory() {
      this.manifestChunk = null;
      this.meshData = null;
      this.fragmentId = null;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      serializeMeshData(this.meshData, msg, transfers);
      this.meshData = null;
    }
    downloadSucceeded() {
      this.systemMemoryBytes = this.gpuMemoryBytes = getMeshDataSize(this.meshData);
      super.downloadSucceeded();
    }
  };
  function decodeJsonManifestChunk(chunk, response, keysPropertyName) {
    verifyObject(response);
    chunk.fragmentIds = verifyObjectProperty(response, keysPropertyName, verifyStringArray);
  }
  function computeVertexNormals(positions, indices) {
    const faceNormal = vec3_exports.create();
    const v1v0 = vec3_exports.create();
    const v2v1 = vec3_exports.create();
    let vertexNormals = new Float32Array(positions.length);
    let numIndices = indices.length;
    for (let i = 0; i < numIndices; i += 3) {
      let i0 = indices[i] * 3, i1 = indices[i + 1] * 3, i2 = indices[i + 2] * 3;
      for (let j = 0; j < 3; ++j) {
        v1v0[j] = positions[i1 + j] - positions[i0 + j];
        v2v1[j] = positions[i2 + j] - positions[i1 + j];
      }
      vec3_exports.cross(faceNormal, v1v0, v2v1);
      vec3_exports.normalize(faceNormal, faceNormal);
      for (let k = 0; k < 3; ++k) {
        let index = indices[i + k];
        let offset = index * 3;
        for (let j = 0; j < 3; ++j) {
          vertexNormals[offset + j] += faceNormal[j];
        }
      }
    }
    let numVertices = vertexNormals.length;
    for (let i = 0; i < numVertices; i += 3) {
      let vec = vertexNormals.subarray(i, i + 3);
      vec3_exports.normalize(vec, vec);
    }
    return vertexNormals;
  }
  function snorm8(x) {
    return Math.min(Math.max(-127, x * 127 + 0.5), 127) >>> 0;
  }
  function signNotZero(x) {
    return x < 0 ? -1 : 1;
  }
  function encodeNormals32fx3ToOctahedron8x2(out, normals) {
    const length4 = normals.length;
    let outIndex = 0;
    for (let i = 0; i < length4; i += 3) {
      const x = normals[i], y = normals[i + 1], z = normals[i + 2];
      const invL1Norm = 1 / (Math.abs(x) + Math.abs(y) + Math.abs(z));
      if (z < 0) {
        out[outIndex] = snorm8((1 - Math.abs(y * invL1Norm)) * signNotZero(x));
        out[outIndex + 1] = snorm8((1 - Math.abs(x * invL1Norm)) * signNotZero(y));
      } else {
        out[outIndex] = snorm8(x * invL1Norm);
        out[outIndex + 1] = snorm8(y * invL1Norm);
      }
      outIndex += 2;
    }
  }
  function decodeVertexPositionsAndIndices(verticesPerPrimitive, data, endianness, vertexByteOffset, numVertices, indexByteOffset, numPrimitives) {
    let vertexPositions = new Float32Array(data, vertexByteOffset, numVertices * 3);
    convertEndian32(vertexPositions, endianness);
    if (indexByteOffset === void 0) {
      indexByteOffset = vertexByteOffset + 12 * numVertices;
    }
    let numIndices;
    if (numPrimitives !== void 0) {
      numIndices = numPrimitives * verticesPerPrimitive;
    }
    let indices = numIndices === void 0 ? new Uint32Array(data, indexByteOffset) : new Uint32Array(data, indexByteOffset, numIndices);
    if (indices.length % verticesPerPrimitive !== 0) {
      throw new Error(`Number of indices is not a multiple of ${verticesPerPrimitive}: ${indices.length}.`);
    }
    convertEndian32(indices, endianness);
    return { vertexPositions, indices };
  }
  function decodeTriangleVertexPositionsAndIndices(data, endianness, vertexByteOffset, numVertices, indexByteOffset, numTriangles) {
    return decodeVertexPositionsAndIndices(3, data, endianness, vertexByteOffset, numVertices, indexByteOffset, numTriangles);
  }
  var MeshSource = class extends ChunkSource {
    constructor(rpc2, options) {
      super(rpc2, options);
      let fragmentSource = this.fragmentSource = this.registerDisposer(rpc2.getRef(options["fragmentSource"]));
      fragmentSource.meshSource = this;
    }
    getChunk(objectId) {
      const key = getObjectKey(objectId);
      let chunk = this.chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(ManifestChunk);
        chunk.initializeManifestChunk(key, objectId);
        this.addChunk(chunk);
      }
      return chunk;
    }
    getFragmentKey(objectKey, fragmentId) {
      return { key: `${objectKey}/${fragmentId}`, fragmentId };
    }
    getFragmentChunk(manifestChunk, fragmentId) {
      const fragmentSource = this.fragmentSource;
      const { key: fragmentKey, fragmentId: parsedFragmentId } = this.getFragmentKey(manifestChunk.key, fragmentId);
      let chunk = fragmentSource.chunks.get(fragmentKey);
      if (chunk === void 0) {
        chunk = fragmentSource.getNewChunk_(FragmentChunk);
        chunk.initializeFragmentChunk(fragmentKey, manifestChunk, parsedFragmentId);
        fragmentSource.addChunk(chunk);
      }
      return chunk;
    }
  };
  var FragmentSource = class extends ChunkSource {
    constructor() {
      super(...arguments);
      this.meshSource = null;
    }
    download(chunk, cancellationToken) {
      return this.meshSource.downloadFragment(chunk, cancellationToken);
    }
  };
  FragmentSource = __decorateClass([
    registerSharedObject(FRAGMENT_SOURCE_RPC_ID)
  ], FragmentSource);
  var MeshLayer = class extends withSegmentationLayerBackendState(withSharedVisibility(withChunkManager(PerspectiveViewRenderLayerBackend))) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.source = this.registerDisposer(rpc2.getRef(options["source"]));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
        this.updateChunkPriorities();
      }));
    }
    attach(attachment) {
      const scheduleUpdateChunkPriorities = () => {
        this.chunkManager.scheduleUpdateChunkPriorities();
      };
      const { view } = attachment;
      attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
      attachment.registerDisposer(scheduleUpdateChunkPriorities);
      scheduleUpdateChunkPriorities();
    }
    updateChunkPriorities() {
      const visibility = this.visibility.value;
      if (visibility === Number.NEGATIVE_INFINITY) {
        return;
      }
      this.chunkManager.registerLayer(this);
      const priorityTier = getPriorityTier(visibility);
      const basePriority = getBasePriority(visibility);
      const { source, chunkManager } = this;
      forEachVisibleSegment(this, (objectId) => {
        let manifestChunk = source.getChunk(objectId);
        ++this.numVisibleChunksNeeded;
        chunkManager.requestChunk(manifestChunk, priorityTier, basePriority + MESH_OBJECT_MANIFEST_CHUNK_PRIORITY);
        const state = manifestChunk.state;
        if (state === ChunkState.SYSTEM_MEMORY_WORKER || state === ChunkState.SYSTEM_MEMORY || state === ChunkState.GPU_MEMORY) {
          ++this.numVisibleChunksAvailable;
          for (let fragmentId of manifestChunk.fragmentIds) {
            let fragmentChunk = source.getFragmentChunk(manifestChunk, fragmentId);
            ++this.numVisibleChunksNeeded;
            chunkManager.requestChunk(fragmentChunk, priorityTier, basePriority + MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY);
            if (fragmentChunk.state === ChunkState.GPU_MEMORY) {
              ++this.numVisibleChunksAvailable;
            }
          }
        }
      });
    }
  };
  MeshLayer = __decorateClass([
    registerSharedObject(MESH_LAYER_RPC_ID)
  ], MeshLayer);
  var MultiscaleManifestChunk = class extends Chunk {
    constructor() {
      super();
      this.objectId = new Uint64();
    }
    initializeManifestChunk(key, objectId) {
      super.initialize(key);
      this.objectId.assign(objectId);
    }
    freeSystemMemory() {
      this.manifest = void 0;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      msg.manifest = this.manifest;
    }
    downloadSucceeded() {
      this.systemMemoryBytes = this.manifest.octree.byteLength;
      this.gpuMemoryBytes = 0;
      super.downloadSucceeded();
      if (this.priorityTier < ChunkPriorityTier.RECENT) {
        this.source.chunkManager.scheduleUpdateChunkPriorities();
      }
    }
    toString() {
      return this.objectId.toString();
    }
  };
  var MultiscaleFragmentChunk = class extends Chunk {
    constructor() {
      super();
      this.subChunkOffsets = null;
      this.meshData = null;
      this.lod = 0;
      this.chunkIndex = 0;
      this.manifestChunk = null;
    }
    freeSystemMemory() {
      this.meshData = this.subChunkOffsets = null;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      serializeMeshData(this.meshData, msg, transfers);
      const { subChunkOffsets } = this;
      msg["subChunkOffsets"] = subChunkOffsets;
      transfers.push(subChunkOffsets.buffer);
      this.meshData = this.subChunkOffsets = null;
    }
    downloadSucceeded() {
      const { subChunkOffsets } = this;
      this.systemMemoryBytes = this.gpuMemoryBytes = getMeshDataSize(this.meshData);
      this.systemMemoryBytes += subChunkOffsets.byteLength;
      super.downloadSucceeded();
    }
  };
  var MultiscaleMeshSource = class extends ChunkSource {
    constructor(rpc2, options) {
      super(rpc2, options);
      let fragmentSource = this.fragmentSource = this.registerDisposer(rpc2.getRef(options["fragmentSource"]));
      this.format = options["format"];
      fragmentSource.meshSource = this;
    }
    getChunk(objectId) {
      const key = getObjectKey(objectId);
      let chunk = this.chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(MultiscaleManifestChunk);
        chunk.initializeManifestChunk(key, objectId);
        this.addChunk(chunk);
      }
      return chunk;
    }
    getFragmentChunk(manifestChunk, lod, chunkIndex) {
      let key = `${manifestChunk.key}/${lod}:${chunkIndex}`;
      let fragmentSource = this.fragmentSource;
      let chunk = fragmentSource.chunks.get(key);
      if (chunk === void 0) {
        chunk = fragmentSource.getNewChunk_(MultiscaleFragmentChunk);
        chunk.initialize(key);
        chunk.lod = lod;
        chunk.chunkIndex = chunkIndex;
        chunk.manifestChunk = manifestChunk;
        fragmentSource.addChunk(chunk);
      }
      return chunk;
    }
  };
  var MultiscaleFragmentSource = class extends ChunkSource {
    constructor() {
      super(...arguments);
      this.meshSource = null;
    }
    download(chunk, cancellationToken) {
      return this.meshSource.downloadFragment(chunk, cancellationToken);
    }
  };
  MultiscaleFragmentSource = __decorateClass([
    registerSharedObject(MULTISCALE_FRAGMENT_SOURCE_RPC_ID)
  ], MultiscaleFragmentSource);
  var tempModelMatrix = mat4_exports.create();
  var MultiscaleMeshLayer = class extends withSegmentationLayerBackendState(withSharedVisibility(withChunkManager(PerspectiveViewRenderLayerBackend))) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.source = this.registerDisposer(rpc2.getRef(options["source"]));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
        this.updateChunkPriorities();
      }));
    }
    attach(attachment) {
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      const { view } = attachment;
      attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
      attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
      attachment.registerDisposer(scheduleUpdateChunkPriorities);
      scheduleUpdateChunkPriorities();
    }
    updateChunkPriorities() {
      const maxVisibility = this.visibility.value;
      if (maxVisibility === Number.NEGATIVE_INFINITY) {
        return;
      }
      const { transform: { value: transform } } = this;
      if (transform.error !== void 0)
        return;
      const manifestChunks = new Array();
      this.chunkManager.registerLayer(this);
      {
        const priorityTier = getPriorityTier(maxVisibility);
        const basePriority = getBasePriority(maxVisibility);
        const { source: source2, chunkManager: chunkManager2 } = this;
        forEachVisibleSegment(this, (objectId) => {
          const manifestChunk = source2.getChunk(objectId);
          ++this.numVisibleChunksNeeded;
          chunkManager2.requestChunk(manifestChunk, priorityTier, basePriority + MESH_OBJECT_MANIFEST_CHUNK_PRIORITY);
          const state = manifestChunk.state;
          if (state === ChunkState.SYSTEM_MEMORY_WORKER || state === ChunkState.SYSTEM_MEMORY || state === ChunkState.GPU_MEMORY) {
            manifestChunks.push(manifestChunk);
            ++this.numVisibleChunksAvailable;
          }
        });
      }
      if (manifestChunks.length === 0)
        return;
      const { source, chunkManager } = this;
      for (const { view } of this.attachments.values()) {
        const visibility = view.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
          continue;
        }
        const priorityTier = getPriorityTier(visibility);
        const basePriority = getBasePriority(visibility);
        const projectionParameters = view.projectionParameters.value;
        const modelViewProjectionMatrix = tempModelMatrix;
        try {
          get3dModelToDisplaySpaceMatrix(modelViewProjectionMatrix, projectionParameters.displayDimensionRenderInfo, transform);
        } catch {
          continue;
        }
        mat4_exports.multiply(modelViewProjectionMatrix, projectionParameters.viewProjectionMat, modelViewProjectionMatrix);
        const clippingPlanes = getFrustrumPlanes(new Float32Array(24), modelViewProjectionMatrix);
        const detailCutoff = this.renderScaleTarget.value;
        for (const manifestChunk of manifestChunks) {
          const maxLod = manifestChunk.manifest.lodScales.length - 1;
          getDesiredMultiscaleMeshChunks(manifestChunk.manifest, modelViewProjectionMatrix, clippingPlanes, detailCutoff, projectionParameters.width, projectionParameters.height, (lod, chunkIndex, _renderScale, empty) => {
            if (empty)
              return;
            let fragmentChunk = source.getFragmentChunk(manifestChunk, lod, chunkIndex);
            ++this.numVisibleChunksNeeded;
            chunkManager.requestChunk(fragmentChunk, priorityTier, basePriority + MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY - maxLod + lod);
            if (fragmentChunk.state === ChunkState.GPU_MEMORY) {
              ++this.numVisibleChunksAvailable;
            }
          });
        }
      }
    }
  };
  MultiscaleMeshLayer = __decorateClass([
    registerSharedObject(MULTISCALE_MESH_LAYER_RPC_ID)
  ], MultiscaleMeshLayer);
  function convertMeshData(data, vertexPositionFormat) {
    const normals = computeVertexNormals(data.vertexPositions, data.indices);
    const encodedNormals = new Uint8Array(normals.length / 3 * 2);
    encodeNormals32fx3ToOctahedron8x2(encodedNormals, normals);
    let encodedIndices;
    let strips;
    if (CONVERT_TO_TRIANGLE_STRIPS) {
      encodedIndices = computeTriangleStrips(data.indices, data.subChunkOffsets);
      strips = true;
    } else {
      if (data.indices.BYTES_PER_ELEMENT === 4 && data.vertexPositions.length / 3 < 65535) {
        encodedIndices = new Uint16Array(data.indices.length);
        encodedIndices.set(data.indices);
      } else {
        encodedIndices = data.indices;
      }
      strips = false;
    }
    let encodedVertexPositions;
    if (vertexPositionFormat === VertexPositionFormat.uint10) {
      const vertexPositions = data.vertexPositions;
      const numVertices = vertexPositions.length / 3;
      encodedVertexPositions = new Uint32Array(numVertices);
      for (let inputIndex = 0, outputIndex = 0; outputIndex < numVertices; inputIndex += 3, ++outputIndex) {
        encodedVertexPositions[outputIndex] = vertexPositions[inputIndex] & 1023 | (vertexPositions[inputIndex + 1] & 1023) << 10 | (vertexPositions[inputIndex + 2] & 1023) << 20;
      }
    } else if (vertexPositionFormat === VertexPositionFormat.uint16) {
      const vertexPositions = data.vertexPositions;
      if (vertexPositions.BYTES_PER_ELEMENT === 2) {
        encodedVertexPositions = vertexPositions;
      } else {
        encodedVertexPositions = new Uint16Array(vertexPositions.length);
        encodedVertexPositions.set(vertexPositions);
      }
    } else {
      encodedVertexPositions = data.vertexPositions;
    }
    return {
      vertexPositions: encodedVertexPositions,
      vertexNormals: encodedNormals,
      indices: encodedIndices,
      strips
    };
  }
  function assignMeshFragmentData(chunk, data, vertexPositionFormat = VertexPositionFormat.float32) {
    chunk.meshData = convertMeshData(data, vertexPositionFormat);
  }
  function assignMultiscaleMeshFragmentData(chunk, data, vertexPositionFormat) {
    chunk.meshData = convertMeshData(data, vertexPositionFormat);
    chunk.subChunkOffsets = data.subChunkOffsets;
  }
  function generateHigherOctreeLevel(octree, priorStart, priorEnd) {
    let curEnd = priorEnd;
    for (let i = 0; i < 3; ++i) {
      octree[curEnd * 5 + i] = octree[priorStart * 5 + i] >>> 1;
    }
    octree[curEnd * 5 + 3] = priorStart;
    for (let i = priorStart + 1; i < priorEnd; ++i) {
      const x = octree[i * 5] >>> 1, y = octree[i * 5 + 1] >>> 1, z = octree[i * 5 + 2] >>> 1;
      if (x !== octree[curEnd * 5] || y !== octree[curEnd * 5 + 1] || z !== octree[curEnd * 5 + 2]) {
        octree[curEnd * 5 + 4] = i;
        ++curEnd;
        octree[curEnd * 5] = x;
        octree[curEnd * 5 + 1] = y;
        octree[curEnd * 5 + 2] = z;
        octree[curEnd * 5 + 3] = i;
      }
    }
    octree[curEnd * 5 + 4] = priorEnd;
    ++curEnd;
    return curEnd;
  }
  function computeOctreeChildOffsets(octree, childStart, childEnd, parentEnd) {
    let childNode = childStart;
    for (let parentNode = childEnd; parentNode < parentEnd; ++parentNode) {
      const parentX = octree[parentNode * 5], parentY = octree[parentNode * 5 + 1], parentZ = octree[parentNode * 5 + 2];
      while (childNode < childEnd) {
        const childX = octree[childNode * 5] >>> 1, childY = octree[childNode * 5 + 1] >>> 1, childZ = octree[childNode * 5 + 2] >>> 1;
        if (!zorder3LessThan(childX, childY, childZ, parentX, parentY, parentZ)) {
          break;
        }
        ++childNode;
      }
      octree[parentNode * 5 + 3] = childNode;
      while (childNode < childEnd) {
        const childX = octree[childNode * 5] >>> 1, childY = octree[childNode * 5 + 1] >>> 1, childZ = octree[childNode * 5 + 2] >>> 1;
        if (childX != parentX || childY != parentY || childZ != parentZ) {
          break;
        }
        ++childNode;
      }
      octree[parentNode * 5 + 4] += childNode;
    }
  }

  // src/neuroglancer/skeleton/base.ts
  var SKELETON_LAYER_RPC_ID = "skeleton/SkeletonLayer";

  // src/neuroglancer/skeleton/backend.ts
  var SKELETON_CHUNK_PRIORITY = 60;
  var SkeletonChunk = class extends Chunk {
    constructor() {
      super();
      this.objectId = new Uint64();
      this.vertexPositions = null;
      this.vertexAttributes = null;
      this.indices = null;
    }
    initializeSkeletonChunk(key, objectId) {
      super.initialize(key);
      this.objectId.assign(objectId);
    }
    freeSystemMemory() {
      this.vertexPositions = this.indices = null;
    }
    getVertexAttributeBytes() {
      let total = this.vertexPositions.byteLength;
      const { vertexAttributes } = this;
      if (vertexAttributes != null) {
        vertexAttributes.forEach((a) => {
          total += a.byteLength;
        });
      }
      return total;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      const vertexPositions = this.vertexPositions;
      const indices = this.indices;
      msg["numVertices"] = vertexPositions.length / 3;
      msg["indices"] = indices;
      transfers.push(indices.buffer);
      const { vertexAttributes } = this;
      if (vertexAttributes != null && vertexAttributes.length > 0) {
        const vertexData = new Uint8Array(this.getVertexAttributeBytes());
        vertexData.set(new Uint8Array(vertexPositions.buffer, vertexPositions.byteOffset, vertexPositions.byteLength));
        let vertexAttributeOffsets = msg["vertexAttributeOffsets"] = new Uint32Array(vertexAttributes.length + 1);
        vertexAttributeOffsets[0] = 0;
        let offset = vertexPositions.byteLength;
        vertexAttributes.forEach((a, i) => {
          vertexAttributeOffsets[i + 1] = offset;
          vertexData.set(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), offset);
          offset += a.byteLength;
        });
        transfers.push(vertexData.buffer);
        msg["vertexAttributes"] = vertexData;
      } else {
        msg["vertexAttributes"] = new Uint8Array(vertexPositions.buffer, vertexPositions.byteOffset, vertexPositions.byteLength);
        msg["vertexAttributeOffsets"] = Uint32Array.of(0);
        if (vertexPositions.buffer !== transfers[0]) {
          transfers.push(vertexPositions.buffer);
        }
      }
      this.vertexPositions = this.indices = this.vertexAttributes = null;
    }
    downloadSucceeded() {
      this.systemMemoryBytes = this.gpuMemoryBytes = this.indices.byteLength + this.getVertexAttributeBytes();
      super.downloadSucceeded();
    }
  };
  var SkeletonSource = class extends ChunkSource {
    getChunk(objectId) {
      const key = getObjectKey(objectId);
      let chunk = this.chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(SkeletonChunk);
        chunk.initializeSkeletonChunk(key, objectId);
        this.addChunk(chunk);
      }
      return chunk;
    }
  };
  var SkeletonLayer = class extends withSegmentationLayerBackendState(withSharedVisibility(withChunkManager(ChunkRenderLayerBackend))) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.source = this.registerDisposer(rpc2.getRef(options["source"]));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
        this.updateChunkPriorities();
      }));
    }
    updateChunkPriorities() {
      const visibility = this.visibility.value;
      if (visibility === Number.NEGATIVE_INFINITY) {
        return;
      }
      this.chunkManager.registerLayer(this);
      const priorityTier = getPriorityTier(visibility);
      const basePriority = getBasePriority(visibility);
      const { source, chunkManager } = this;
      forEachVisibleSegment(this, (objectId) => {
        const chunk = source.getChunk(objectId);
        ++this.numVisibleChunksNeeded;
        if (chunk.state === ChunkState.GPU_MEMORY) {
          ++this.numVisibleChunksAvailable;
        }
        chunkManager.requestChunk(chunk, priorityTier, basePriority + SKELETON_CHUNK_PRIORITY);
      });
    }
  };
  SkeletonLayer = __decorateClass([
    registerSharedObject(SKELETON_LAYER_RPC_ID)
  ], SkeletonLayer);
  function decodeSkeletonVertexPositionsAndIndices(chunk, data, endianness, vertexByteOffset, numVertices, indexByteOffset, numEdges) {
    const meshData = decodeVertexPositionsAndIndices(2, data, endianness, vertexByteOffset, numVertices, indexByteOffset, numEdges);
    chunk.vertexPositions = meshData.vertexPositions;
    chunk.indices = meshData.indices;
  }

  // src/neuroglancer/sliceview/backend_chunk_decoders/compressed_segmentation.ts
  async function decodeCompressedSegmentationChunk(chunk, cancellationToken, response) {
    cancellationToken;
    chunk.data = new Uint32Array(response);
  }

  // src/neuroglancer/async_computation/index.ts
  function asyncComputation(id) {
    return { id };
  }

  // src/neuroglancer/async_computation/encode_compressed_segmentation_request.ts
  var encodeCompressedSegmentationUint32 = asyncComputation("encodeCompressedSegmentationUint32");
  var encodeCompressedSegmentationUint64 = asyncComputation("encodeCompressedSegmentationUint64");

  // src/neuroglancer/async_computation/request.ts
  var freeWorkers = [];
  var pendingTasks = new Map();
  var tasks = new Map();
  var maxWorkers = typeof navigator.hardwareConcurrency === "undefined" ? 4 : Math.min(12, navigator.hardwareConcurrency);
  var nextTaskId = 0;
  function returnWorker(worker) {
    for (const [id, task] of pendingTasks) {
      pendingTasks.delete(id);
      worker.postMessage(task.msg, task.transfer);
      return;
    }
    freeWorkers.push(worker);
  }
  function getNewWorker() {
    let port;
    if (typeof Worker === "undefined") {
      const channel = new MessageChannel();
      port = channel.port2;
      rpc.invoke(WORKER_RPC_ID, { port: channel.port1, path: "async_computation.bundle.js" }, [channel.port1]);
    } else {
      port = new Worker("async_computation.bundle.js");
    }
    port.onmessage = (msg) => {
      const { id, value, error } = msg.data;
      returnWorker(port);
      const callbacks = tasks.get(id);
      tasks.delete(id);
      if (callbacks === void 0)
        return;
      callbacks.cleanup();
      if (error !== void 0) {
        callbacks.reject(new Error(error));
      } else {
        callbacks.resolve(value);
      }
    };
    return port;
  }
  function requestAsyncComputation(request, cancellationToken, transfer, ...args) {
    if (cancellationToken.isCanceled)
      return Promise.reject(CANCELED);
    const id = nextTaskId++;
    const msg = { t: request.id, id, args };
    const cleanup = cancellationToken.add(() => {
      pendingTasks.delete(id);
      tasks.delete(id);
    });
    const promise = new Promise((resolve, reject) => {
      tasks.set(id, { resolve, reject, cleanup });
    });
    if (freeWorkers.length !== 0) {
      freeWorkers.pop().postMessage(msg, transfer);
    } else if (tasks.size < maxWorkers) {
      getNewWorker().postMessage(msg, transfer);
    } else {
      pendingTasks.set(id, { msg, transfer });
    }
    return promise;
  }

  // src/neuroglancer/sliceview/backend_chunk_decoders/postprocess.ts
  async function postProcessRawData(chunk, cancellationToken, data) {
    cancellationToken;
    const { spec } = chunk.source;
    if (spec.compressedSegmentationBlockSize !== void 0) {
      const { dataType } = spec;
      const chunkDataSize = chunk.chunkDataSize;
      const shape = [chunkDataSize[0], chunkDataSize[1], chunkDataSize[2], chunkDataSize[3] || 1];
      switch (dataType) {
        case DataType.UINT32:
          chunk.data = await requestAsyncComputation(encodeCompressedSegmentationUint32, cancellationToken, [data.buffer], data, shape, spec.compressedSegmentationBlockSize);
          break;
        case DataType.UINT64:
          chunk.data = await requestAsyncComputation(encodeCompressedSegmentationUint64, cancellationToken, [data.buffer], data, shape, spec.compressedSegmentationBlockSize);
          break;
        default:
          throw new Error(`Unsupported data type for compressed segmentation: ${DataType[dataType]}`);
      }
    } else {
      chunk.data = data;
    }
  }

  // src/neuroglancer/async_computation/decode_jpeg_request.ts
  var decodeJpeg = asyncComputation("decodeJpeg");

  // src/neuroglancer/sliceview/backend_chunk_decoders/jpeg.ts
  async function decodeJpegChunk(chunk, cancellationToken, response) {
    const chunkDataSize = chunk.chunkDataSize;
    const decoded = await requestAsyncComputation(decodeJpeg, cancellationToken, [response], new Uint8Array(response), chunkDataSize[0], chunkDataSize[1] * chunkDataSize[2], chunkDataSize[3] || 1, false);
    await postProcessRawData(chunk, cancellationToken, decoded);
  }

  // src/neuroglancer/sliceview/backend_chunk_decoders/raw.ts
  async function decodeRawChunk(chunk, cancellationToken, response, endianness = ENDIANNESS, byteOffset = 0, byteLength = response.byteLength) {
    cancellationToken;
    let { spec } = chunk.source;
    let { dataType } = spec;
    let numElements = prod(chunk.chunkDataSize);
    let bytesPerElement = DATA_TYPE_BYTES[dataType];
    let expectedBytes = numElements * bytesPerElement;
    if (expectedBytes !== byteLength) {
      throw new Error(`Raw-format chunk is ${byteLength} bytes, but ${numElements} * ${bytesPerElement} = ${expectedBytes} bytes are expected.`);
    }
    const data = makeDataTypeArrayView(dataType, response, byteOffset, byteLength);
    convertEndian(data, endianness, bytesPerElement);
    await postProcessRawData(chunk, cancellationToken, data);
  }

  // src/neuroglancer/sliceview/volume/backend.ts
  var VolumeChunk = class extends SliceViewChunk {
    constructor() {
      super();
      this.source = null;
    }
    initializeVolumeChunk(key, chunkGridPosition) {
      super.initializeVolumeChunk(key, chunkGridPosition);
      this.chunkDataSize = null;
      this.data = null;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      let chunkDataSize = this.chunkDataSize;
      if (chunkDataSize !== this.source.spec.chunkDataSize) {
        msg["chunkDataSize"] = chunkDataSize;
      }
      let data = msg["data"] = this.data;
      if (data !== null) {
        transfers.push(data.buffer);
      }
      this.data = null;
    }
    downloadSucceeded() {
      var _a, _b;
      this.systemMemoryBytes = this.gpuMemoryBytes = (_b = (_a = this.data) == null ? void 0 : _a.byteLength) != null ? _b : 0;
      super.downloadSucceeded();
    }
    freeSystemMemory() {
      this.data = null;
    }
  };
  function computeChunkBounds(source, chunk) {
    const { spec, tempChunkDataSize, tempChunkPosition: tempChunkPosition4 } = source;
    const { upperVoxelBound, rank, baseVoxelOffset } = spec;
    let origChunkDataSize = spec.chunkDataSize;
    let newChunkDataSize = tempChunkDataSize;
    const chunkPosition = multiply6(tempChunkPosition4, chunk.chunkGridPosition, origChunkDataSize);
    let partial = false;
    for (let i = 0; i < rank; ++i) {
      let upper = Math.min(upperVoxelBound[i], chunkPosition[i] + origChunkDataSize[i]);
      let size = newChunkDataSize[i] = upper - chunkPosition[i];
      if (size !== origChunkDataSize[i]) {
        partial = true;
      }
    }
    add6(chunkPosition, chunkPosition, baseVoxelOffset);
    if (partial) {
      chunk.chunkDataSize = Uint32Array.from(newChunkDataSize);
    } else {
      chunk.chunkDataSize = origChunkDataSize;
    }
    return chunkPosition;
  }
  var VolumeChunkSource = class extends SliceViewChunkSourceBackend {
    constructor(rpc2, options) {
      super(rpc2, options);
      const rank = this.spec.rank;
      this.tempChunkDataSize = new Uint32Array(rank);
      this.tempChunkPosition = new Float32Array(rank);
    }
    computeChunkBounds(chunk) {
      return computeChunkBounds(this, chunk);
    }
  };
  VolumeChunkSource.prototype.chunkConstructor = VolumeChunk;

  // src/neuroglancer/util/string.ts
  function defaultStringCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }

  // src/neuroglancer/datasource/brainmaps/backend.ts
  var CHUNK_DECODERS = new Map([
    [
      VolumeChunkEncoding.RAW,
      decodeRawChunk
    ],
    [VolumeChunkEncoding.JPEG, decodeJpegChunk],
    [
      VolumeChunkEncoding.COMPRESSED_SEGMENTATION,
      decodeCompressedSegmentationChunk
    ]
  ]);
  function applyChangeStack(changeStack, payload) {
    if (!changeStack) {
      return;
    }
    payload.change_spec = {
      change_stack_id: changeStack.changeStackId
    };
    if (changeStack.timeStamp) {
      payload.change_spec.time_stamp = changeStack.timeStamp;
    }
    if (changeStack.skipEquivalences) {
      payload.change_spec.skip_equivalences = changeStack.skipEquivalences;
    }
  }
  function BrainmapsSource(Base, parametersConstructor) {
    return WithParameters(WithSharedCredentialsProviderCounterpart()(Base), parametersConstructor);
  }
  var tempUint643 = new Uint64();
  var BrainmapsVolumeChunkSource = class extends BrainmapsSource(VolumeChunkSource, VolumeSourceParameters) {
    constructor() {
      super(...arguments);
      this.chunkDecoder = CHUNK_DECODERS.get(this.parameters.encoding);
    }
    applyEncodingParams(payload) {
      let { encoding } = this.parameters;
      switch (encoding) {
        case VolumeChunkEncoding.RAW:
          payload.subvolume_format = "RAW";
          break;
        case VolumeChunkEncoding.JPEG:
          payload.subvolume_format = "SINGLE_IMAGE";
          payload.image_format_options = {
            image_format: "JPEG",
            jpeg_quality: this.parameters.jpegQuality
          };
          return;
        case VolumeChunkEncoding.COMPRESSED_SEGMENTATION:
          payload.subvolume_format = "RAW";
          payload.image_format_options = {
            compressed_segmentation_block_size: vec3Key(this.spec.compressedSegmentationBlockSize)
          };
          break;
        default:
          throw new Error(`Invalid encoding: ${encoding}`);
      }
    }
    async download(chunk, cancellationToken) {
      let { parameters } = this;
      let path;
      let chunkPosition = this.computeChunkBounds(chunk);
      let chunkDataSize = chunk.chunkDataSize;
      path = `/v1/volumes/${parameters["volumeId"]}/subvolume:binary`;
      let payload = {
        geometry: {
          corner: vec3Key(chunkPosition),
          size: vec3Key(chunkDataSize),
          scale: parameters.scaleIndex
        }
      };
      this.applyEncodingParams(payload);
      applyChangeStack(parameters.changeSpec, payload);
      const response = await makeRequest(parameters["instance"], this.credentialsProvider, {
        method: "POST",
        payload: JSON.stringify(payload),
        path,
        responseType: "arraybuffer"
      }, cancellationToken);
      await this.chunkDecoder(chunk, cancellationToken, response);
    }
  };
  BrainmapsVolumeChunkSource = __decorateClass([
    registerSharedObject()
  ], BrainmapsVolumeChunkSource);
  function getFragmentCorner(fragmentId, xBits, yBits, zBits) {
    const id = new Uint64();
    if (!id.tryParseString(fragmentId, 16)) {
      throw new Error(`Couldn't parse fragmentId ${fragmentId} as hex-encoded Uint64`);
    }
    return decodeZIndexCompressed(id, xBits, yBits, zBits);
  }
  function decodeMultiscaleManifestChunk(chunk, response) {
    verifyObject(response);
    const source = chunk.source;
    const fragmentKeys = verifyObjectProperty(response, "fragmentKey", verifyStringArray);
    const supervoxelIds = verifyObjectProperty(response, "supervoxelId", verifyStringArray);
    const length4 = fragmentKeys.length;
    if (length4 !== supervoxelIds.length) {
      throw new Error("Expected fragmentKey and supervoxelId arrays to have the same length.");
    }
    const fragmentSupervoxelIds = new Map();
    fragmentKeys.forEach((fragmentId, i) => {
      let ids = fragmentSupervoxelIds.get(fragmentId);
      if (ids === void 0) {
        ids = [];
        fragmentSupervoxelIds.set(fragmentId, ids);
      }
      ids.push(supervoxelIds[i]);
    });
    const { chunkShape } = source.parameters.info;
    const gridShape = source.parameters.info.lods[0].gridShape;
    const xBits = Math.ceil(Math.log2(gridShape[0])), yBits = Math.ceil(Math.log2(gridShape[1])), zBits = Math.ceil(Math.log2(gridShape[2]));
    const fragmentIdAndCorners = Array.from(fragmentSupervoxelIds.entries()).map(([id, supervoxelIds2]) => ({
      fragmentId: id,
      corner: getFragmentCorner(id, xBits, yBits, zBits),
      supervoxelIds: supervoxelIds2
    }));
    fragmentIdAndCorners.sort((a, b) => {
      return zorder3LessThan(a.corner[0], a.corner[1], a.corner[2], b.corner[0], b.corner[1], b.corner[2]) ? -1 : 1;
    });
    let clipLowerBound, clipUpperBound;
    let minNumLods = 0;
    let octree;
    if (length4 === 0) {
      clipLowerBound = clipUpperBound = kZeroVec;
      octree = Uint32Array.of(0, 0, 0, 0, 2147483648);
    } else {
      const minCoord = vec3_exports.clone(kInfinityVec);
      const maxCoord = vec3_exports.clone(kZeroVec);
      fragmentIdAndCorners.forEach((x) => {
        const { corner } = x;
        for (let i = 0; i < 3; ++i) {
          minCoord[i] = Math.min(minCoord[i], corner[i]);
          maxCoord[i] = Math.max(maxCoord[i], corner[i]);
        }
      });
      minNumLods = 1;
      while (maxCoord[0] >>> minNumLods - 1 != minCoord[0] >>> minNumLods - 1 || maxCoord[1] >>> minNumLods - 1 != minCoord[1] >>> minNumLods - 1 || maxCoord[2] >>> minNumLods - 1 != minCoord[2] >>> minNumLods - 1) {
        ++minNumLods;
      }
      clipLowerBound = vec3_exports.multiply(minCoord, minCoord, chunkShape);
      clipUpperBound = vec3_exports.add(maxCoord, vec3_exports.multiply(maxCoord, maxCoord, chunkShape), chunkShape);
    }
    const { lods } = source.parameters.info;
    const lodScales = new Float32Array(Math.max(lods.length, minNumLods));
    for (let lodIndex = 0; lodIndex < lods.length; ++lodIndex) {
      lodScales[lodIndex] = lods[lodIndex].scale;
    }
    if (length4 !== 0) {
      const octreeTemp = new Uint32Array(fragmentIdAndCorners.length * lodScales.length * 5);
      fragmentIdAndCorners.forEach((x, i) => {
        octreeTemp.set(x.corner, i * 5);
        octreeTemp[i * 5] = x.corner[0];
      });
      let priorStart = 0;
      let priorEnd = fragmentIdAndCorners.length;
      for (let lod = 1; lod < lodScales.length; ++lod) {
        const curEnd = generateHigherOctreeLevel(octreeTemp, priorStart, priorEnd);
        priorStart = priorEnd;
        priorEnd = curEnd;
      }
      octree = octreeTemp.slice(0, priorEnd * 5);
    }
    const manifest = {
      chunkShape,
      chunkGridSpatialOrigin: kZeroVec,
      clipLowerBound,
      clipUpperBound,
      octree,
      lodScales,
      vertexOffsets: new Float32Array(lodScales.length * 3)
    };
    chunk.manifest = manifest;
    chunk.fragmentSupervoxelIds = fragmentIdAndCorners;
  }
  var maxMeshBatchSize = 255;
  function decodeBatchMeshResponse(response, callback) {
    let length4 = response.byteLength;
    let index = 0;
    const dataView = new DataView(response);
    const headerSize = 8 + 8 + 8 + 8;
    while (index < length4) {
      if (index + headerSize > length4) {
        throw new Error(`Invalid batch mesh fragment response.`);
      }
      const objectIdLow = dataView.getUint32(index, true);
      const objectIdHigh = dataView.getUint32(index + 4, true);
      const objectIdString = new Uint64(objectIdLow, objectIdHigh).toString();
      const prefix = objectIdString + "\0";
      index += 8;
      const fragmentKeyLength = dataView.getUint32(index, true);
      const fragmentKeyLengthHigh = dataView.getUint32(index + 4, true);
      index += 8;
      if (fragmentKeyLengthHigh !== 0) {
        throw new Error(`Invalid batch mesh fragment response.`);
      }
      if (index + fragmentKeyLength + 8 + 8 > length4) {
        throw new Error(`Invalid batch mesh fragment response.`);
      }
      const fragmentKey = new TextDecoder().decode(new Uint8Array(response, index, fragmentKeyLength));
      const fullKey = prefix + fragmentKey;
      index += fragmentKeyLength;
      const numVertices = dataView.getUint32(index, true);
      const numVerticesHigh = dataView.getUint32(index + 4, true);
      index += 8;
      const numTriangles = dataView.getUint32(index, true);
      const numTrianglesHigh = dataView.getUint32(index + 4, true);
      index += 8;
      if (numVerticesHigh !== 0 || numTrianglesHigh !== 0) {
        throw new Error(`Invalid batch mesh fragment response.`);
      }
      const endOffset = index + numTriangles * 12 + numVertices * 12;
      if (endOffset > length4) {
        throw new Error(`Invalid batch mesh fragment response.`);
      }
      callback({
        fullKey,
        buffer: response,
        verticesOffset: index,
        numVertices,
        indicesOffset: index + 12 * numVertices,
        numIndices: numTriangles * 3
      });
      index = endOffset;
    }
  }
  function combineBatchMeshFragments(fragments) {
    let totalVertices = 0, totalIndices = 0;
    for (let fragment of fragments) {
      totalVertices += fragment.numVertices;
      totalIndices += fragment.numIndices;
    }
    const vertexBuffer = new Float32Array(totalVertices * 3);
    const indexBuffer = new Uint32Array(totalIndices);
    let vertexOffset = 0;
    let indexOffset = 0;
    for (const fragment of fragments) {
      vertexBuffer.set(new Float32Array(fragment.buffer, fragment.verticesOffset, fragment.numVertices * 3), vertexOffset * 3);
      const { numIndices } = fragment;
      const sourceIndices = new Uint32Array(fragment.buffer, fragment.indicesOffset, numIndices);
      convertEndian32(sourceIndices, Endianness.LITTLE);
      for (let i = 0; i < numIndices; ++i) {
        indexBuffer[indexOffset++] = sourceIndices[i] + vertexOffset;
      }
      vertexOffset += fragment.numVertices;
    }
    convertEndian32(vertexBuffer, Endianness.LITTLE);
    return { vertexPositions: vertexBuffer, indices: indexBuffer };
  }
  async function makeBatchMeshRequest(credentialsProvider, parameters, ids, cancellationToken) {
    const path = `/v1/objects/meshes:batch`;
    const batches = [];
    let prevObjectId;
    let batchSize = 0;
    const pendingIds = new Map();
    for (const [id, idData] of ids) {
      pendingIds.set(id, idData);
      ids.delete(id);
      const splitIndex = id.indexOf("\0");
      const objectId = id.substring(0, splitIndex);
      const fragmentId = id.substring(splitIndex + 1);
      if (objectId !== prevObjectId) {
        batches.push({ object_id: objectId, fragment_keys: [] });
      }
      batches[batches.length - 1].fragment_keys.push(fragmentId);
      if (++batchSize === maxMeshBatchSize)
        break;
    }
    const payload = {
      volume_id: parameters.volumeId,
      mesh_name: parameters.meshName,
      batches
    };
    try {
      return await makeRequest(parameters["instance"], credentialsProvider, {
        method: "POST",
        path,
        payload: JSON.stringify(payload),
        responseType: "arraybuffer"
      }, cancellationToken);
    } finally {
      for (const [id, idData] of pendingIds) {
        ids.set(id, idData);
      }
    }
  }
  var BrainmapsMultiscaleMeshSource = class extends BrainmapsSource(MultiscaleMeshSource, MultiscaleMeshSourceParameters) {
    constructor() {
      super(...arguments);
      this.listFragmentsParams = (() => {
        const { parameters } = this;
        const { changeSpec } = parameters;
        if (changeSpec !== void 0) {
          return `&header.changeStackId=${changeSpec.changeStackId}`;
        }
        return "";
      })();
    }
    download(chunk, cancellationToken) {
      let { parameters } = this;
      const path = `/v1/objects/${parameters["volumeId"]}/meshes/${parameters.info.lods[0].info.name}:listfragments?object_id=${chunk.objectId}&return_supervoxel_ids=true` + this.listFragmentsParams;
      return makeRequest(parameters["instance"], this.credentialsProvider, {
        method: "GET",
        path,
        responseType: "json"
      }, cancellationToken).then((response) => decodeMultiscaleManifestChunk(chunk, response));
    }
    async downloadFragment(chunk, cancellationToken) {
      const { parameters } = this;
      const manifestChunk = chunk.manifestChunk;
      const { fragmentSupervoxelIds } = manifestChunk;
      const manifest = manifestChunk.manifest;
      const { lod } = chunk;
      const { octree } = manifest;
      const numBaseChunks = fragmentSupervoxelIds.length;
      const row = chunk.chunkIndex;
      let startChunkIndex = row;
      while (startChunkIndex >= numBaseChunks) {
        startChunkIndex = octree[startChunkIndex * 5 + 3];
      }
      let endChunkIndex = row + 1;
      while (endChunkIndex > numBaseChunks) {
        endChunkIndex = octree[endChunkIndex * 5 - 1] & 2147483647;
      }
      const { relativeBlockShape, gridShape } = parameters.info.lods[lod];
      const xBits = Math.ceil(Math.log2(gridShape[0])), yBits = Math.ceil(Math.log2(gridShape[1])), zBits = Math.ceil(Math.log2(gridShape[2]));
      let ids = new Map();
      for (let chunkIndex = startChunkIndex; chunkIndex < endChunkIndex; ++chunkIndex) {
        const gridX = Math.floor(octree[chunkIndex * 5] / relativeBlockShape[0]), gridY = Math.floor(octree[chunkIndex * 5 + 1] / relativeBlockShape[1]), gridZ = Math.floor(octree[chunkIndex * 5 + 2] / relativeBlockShape[2]);
        const fragmentKey = encodeZIndexCompressed3d(tempUint643, xBits, yBits, zBits, gridX, gridY, gridZ).toString(16).padStart(16, "0");
        const entry = fragmentSupervoxelIds[chunkIndex];
        for (const supervoxelId of entry.supervoxelIds) {
          ids.set(supervoxelId + "\0" + fragmentKey, chunkIndex);
        }
      }
      let prevLod = Math.max(0, lod - 1);
      let fragments = [];
      const idArray = Array.from(ids);
      idArray.sort((a, b) => defaultStringCompare(a[0], b[0]));
      ids = new Map(idArray);
      const meshName = parameters.info.lods[lod].info.name;
      const parallelRequests = true;
      await new Promise((resolve, reject) => {
        let requestsInProgress = 0;
        let error = false;
        const maybeIssueMoreRequests = () => {
          if (error)
            return;
          while (ids.size !== 0) {
            ++requestsInProgress;
            makeBatchMeshRequest(this.credentialsProvider, { instance: parameters.instance, volumeId: parameters.volumeId, meshName }, ids, cancellationToken).then((response) => {
              --requestsInProgress;
              decodeBatchMeshResponse(response, (fragment) => {
                const chunkIndex = ids.get(fragment.fullKey);
                if (!ids.delete(fragment.fullKey)) {
                  throw new Error(`Received unexpected fragment key: ${JSON.stringify(fragment.fullKey)}.`);
                }
                fragment.chunkIndex = chunkIndex;
                fragments.push(fragment);
              });
              maybeIssueMoreRequests();
            }).catch((e) => {
              error = true;
              reject(e);
            });
            if (!parallelRequests)
              break;
          }
          chunk.downloadSlots = Math.max(1, requestsInProgress);
          if (requestsInProgress === 0) {
            resolve(void 0);
            return;
          }
        };
        maybeIssueMoreRequests();
      });
      fragments.sort((a, b) => a.chunkIndex - b.chunkIndex);
      let indexOffset = 0;
      const numSubChunks = 1 << 3 * (lod - prevLod);
      const subChunkOffsets = new Uint32Array(numSubChunks + 1);
      let prevSubChunkIndex = 0;
      for (const fragment of fragments) {
        const row2 = fragment.chunkIndex;
        const subChunkIndex = getOctreeChildIndex(octree[row2 * 5] >>> prevLod, octree[row2 * 5 + 1] >>> prevLod, octree[row2 * 5 + 2] >>> prevLod) & numSubChunks - 1;
        subChunkOffsets.fill(indexOffset, prevSubChunkIndex + 1, subChunkIndex + 1);
        prevSubChunkIndex = subChunkIndex;
        indexOffset += fragment.numIndices;
      }
      subChunkOffsets.fill(indexOffset, prevSubChunkIndex + 1, numSubChunks + 1);
      assignMultiscaleMeshFragmentData(chunk, { ...combineBatchMeshFragments(fragments), subChunkOffsets }, VertexPositionFormat.float32);
    }
  };
  BrainmapsMultiscaleMeshSource = __decorateClass([
    registerSharedObject()
  ], BrainmapsMultiscaleMeshSource);
  function groupFragmentsIntoBatches(ids) {
    const batches = [];
    let index = 0;
    const length4 = ids.length;
    while (index < length4) {
      batches.push(JSON.stringify(ids.slice(index, index + maxMeshBatchSize)));
      index += maxMeshBatchSize;
    }
    return batches;
  }
  function decodeManifestChunkWithSupervoxelIds(chunk, response) {
    verifyObject(response);
    const fragmentKeys = verifyObjectProperty(response, "fragmentKey", verifyStringArray);
    const supervoxelIds = verifyObjectProperty(response, "supervoxelId", verifyStringArray);
    const length4 = fragmentKeys.length;
    if (length4 !== supervoxelIds.length) {
      throw new Error("Expected fragmentKey and supervoxelId arrays to have the same length.");
    }
    let fragmentIds = supervoxelIds.map((supervoxelId, index) => supervoxelId + "\0" + fragmentKeys[index]);
    chunk.fragmentIds = groupFragmentsIntoBatches(fragmentIds);
  }
  var BrainmapsMeshSource = class extends BrainmapsSource(MeshSource, MeshSourceParameters) {
    constructor() {
      super(...arguments);
      this.listFragmentsParams = (() => {
        const { parameters } = this;
        const { changeSpec } = parameters;
        if (changeSpec !== void 0) {
          return `&header.changeStackId=${changeSpec.changeStackId}`;
        }
        return "";
      })();
    }
    download(chunk, cancellationToken) {
      let { parameters } = this;
      const path = `/v1/objects/${parameters["volumeId"]}/meshes/${parameters["meshName"]}:listfragments?object_id=${chunk.objectId}&return_supervoxel_ids=true` + this.listFragmentsParams;
      return makeRequest(parameters["instance"], this.credentialsProvider, {
        method: "GET",
        path,
        responseType: "json"
      }, cancellationToken).then((response) => decodeManifestChunkWithSupervoxelIds(chunk, response));
    }
    async downloadFragment(chunk, cancellationToken) {
      let { parameters } = this;
      const ids = new Map();
      for (const id of JSON.parse(chunk.fragmentId)) {
        ids.set(id, null);
      }
      let fragments = [];
      const { credentialsProvider } = this;
      while (ids.size !== 0) {
        const response = await makeBatchMeshRequest(credentialsProvider, parameters, ids, cancellationToken);
        decodeBatchMeshResponse(response, (fragment) => {
          if (!ids.delete(fragment.fullKey)) {
            throw new Error(`Received unexpected fragment key: ${JSON.stringify(fragment.fullKey)}.`);
          }
          fragments.push(fragment);
        });
      }
      assignMeshFragmentData(chunk, combineBatchMeshFragments(fragments));
    }
  };
  BrainmapsMeshSource = __decorateClass([
    registerSharedObject()
  ], BrainmapsMeshSource);
  function decodeSkeletonChunk(chunk, response) {
    let dv = new DataView(response);
    let numVertices = dv.getUint32(0, true);
    let numVerticesHigh = dv.getUint32(4, true);
    if (numVerticesHigh !== 0) {
      throw new Error(`The number of vertices should not exceed 2^32-1.`);
    }
    let numEdges = dv.getUint32(8, true);
    let numEdgesHigh = dv.getUint32(12, true);
    if (numEdgesHigh !== 0) {
      throw new Error(`The number of edges should not exceed 2^32-1.`);
    }
    decodeSkeletonVertexPositionsAndIndices(chunk, response, Endianness.LITTLE, 16, numVertices, void 0, numEdges);
  }
  var BrainmapsSkeletonSource = class extends BrainmapsSource(SkeletonSource, SkeletonSourceParameters) {
    download(chunk, cancellationToken) {
      const { parameters } = this;
      let payload = {
        object_id: `${chunk.objectId}`
      };
      const path = `/v1/objects/${parameters["volumeId"]}/meshes/${parameters.meshName}/skeleton:binary`;
      applyChangeStack(parameters.changeSpec, payload);
      return makeRequest(parameters["instance"], this.credentialsProvider, {
        method: "POST",
        path,
        payload: JSON.stringify(payload),
        responseType: "arraybuffer"
      }, cancellationToken).then((response) => decodeSkeletonChunk(chunk, response));
    }
  };
  BrainmapsSkeletonSource = __decorateClass([
    registerSharedObject()
  ], BrainmapsSkeletonSource);
  var spatialAnnotationTypes = ["LOCATION", "LINE", "VOLUME"];
  function parseCommaSeparatedPoint(x) {
    const pattern = /(-?[0-9]+),(-?[0-9]+),(-?[0-9]+)/;
    const cornerParts = x.match(pattern);
    if (cornerParts === null) {
      throw new Error(`Error parsing number triplet: ${JSON.stringify(x)}.`);
    }
    return vec3_exports.fromValues(parseFloat(cornerParts[1]), parseFloat(cornerParts[2]), parseFloat(cornerParts[3]));
  }
  function getIdPrefix(parameters) {
    return parameters.volumeId + ":" + parameters.changestack + ":";
  }
  function parseBrainmapsAnnotationId(idPrefix, fullId) {
    if (!fullId.startsWith(idPrefix)) {
      throw new Error(`Received annotation id ${JSON.stringify(fullId)} does not have expected prefix of ${JSON.stringify(idPrefix)}.`);
    }
    const id = fullId.substring(idPrefix.length);
    return id;
  }
  function parseObjectLabels(obj) {
    if (obj == null) {
      return void 0;
    }
    return [parseArray(obj, (x) => Uint64.parseString("" + x, 10))];
  }
  function parseAnnotation(entry, idPrefix, expectedId) {
    const corner = verifyObjectProperty(entry, "corner", (x) => parseCommaSeparatedPoint(verifyString(x)));
    const size = verifyObjectProperty(entry, "size", (x) => parseCommaSeparatedPoint(verifyString(x)));
    const description = verifyObjectProperty(entry, "payload", verifyOptionalString);
    const spatialAnnotationType = verifyObjectProperty(entry, "type", verifyString);
    const fullId = verifyObjectProperty(entry, "id", verifyString);
    const id = parseBrainmapsAnnotationId(idPrefix, fullId);
    const segments = verifyObjectProperty(entry, "objectLabels", parseObjectLabels);
    if (expectedId !== void 0 && id !== expectedId) {
      throw new Error(`Received annotation has unexpected id ${JSON.stringify(fullId)}.`);
    }
    switch (spatialAnnotationType) {
      case "LOCATION":
        if (vec3_exports.equals(size, kZeroVec)) {
          return {
            type: AnnotationType.POINT,
            id,
            point: corner,
            description,
            relatedSegments: segments,
            properties: []
          };
        } else {
          const radii = vec3_exports.scale(vec3_exports.create(), size, 0.5);
          const center = vec3_exports.add(vec3_exports.create(), corner, radii);
          return {
            type: AnnotationType.ELLIPSOID,
            id,
            center,
            radii,
            description,
            relatedSegments: segments,
            properties: []
          };
        }
      case "LINE":
        return {
          type: AnnotationType.LINE,
          id,
          pointA: corner,
          pointB: vec3_exports.add(vec3_exports.create(), corner, size),
          description,
          relatedSegments: segments,
          properties: []
        };
      case "VOLUME":
        return {
          type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,
          id,
          pointA: corner,
          pointB: vec3_exports.add(vec3_exports.create(), corner, size),
          description,
          relatedSegments: segments,
          properties: []
        };
      default:
        throw new Error(`Unknown spatial annotation type: ${JSON.stringify(spatialAnnotationType)}.`);
    }
  }
  function parseAnnotationResponse(response, idPrefix, expectedId) {
    verifyObject(response);
    const entry = verifyObjectProperty(response, "annotations", (x) => parseFixedLengthArray([void 0], x, verifyObject))[0];
    return parseAnnotation(entry, idPrefix, expectedId);
  }
  var annotationPropertySerializers = makeAnnotationPropertySerializers(3, []);
  function parseAnnotations(chunk, responses) {
    const serializer = new AnnotationSerializer(annotationPropertySerializers);
    const source = chunk.source.parent;
    const idPrefix = getIdPrefix(source.parameters);
    responses.forEach((response, responseIndex) => {
      try {
        verifyObject(response);
        const annotationsArray = verifyObjectProperty(response, "annotations", (x) => x === void 0 ? [] : x);
        if (!Array.isArray(annotationsArray)) {
          throw new Error(`Expected array, but received ${JSON.stringify(typeof annotationsArray)}.`);
        }
        for (const entry of annotationsArray) {
          try {
            serializer.add(parseAnnotation(entry, idPrefix));
          } catch (e) {
            throw new Error(`Error parsing annotation: ${e.message}`);
          }
        }
      } catch (parseError) {
        throw new Error(`Error parsing ${spatialAnnotationTypes[responseIndex]} annotations: ${parseError.message}`);
      }
    });
    chunk.data = Object.assign(new AnnotationGeometryData(), serializer.serialize());
  }
  function getSpatialAnnotationTypeFromId(id) {
    const index = id.indexOf(".");
    return id.substring(0, index);
  }
  function toCommaSeparated(v) {
    return `${Math.round(v[0])},${Math.round(v[1])},${Math.round(v[2])}`;
  }
  function getFullSpatialAnnotationId(parameters, id) {
    return `${parameters.volumeId}:${parameters.changestack}:${id}`;
  }
  function annotationToBrainmaps(annotation) {
    const payload = annotation.description || "";
    const objectLabels = annotation.relatedSegments === void 0 ? void 0 : annotation.relatedSegments[0].map((x) => x.toString());
    switch (annotation.type) {
      case AnnotationType.LINE: {
        const { pointA, pointB } = annotation;
        const size = vec3_exports.subtract(vec3_exports.create(), pointB, pointA);
        return {
          type: "LINE",
          corner: toCommaSeparated(pointA),
          size: toCommaSeparated(size),
          object_labels: objectLabels,
          payload
        };
      }
      case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX: {
        const { pointA, pointB } = annotation;
        const minPoint = min3(vec3_exports.create(), pointA, pointB);
        const maxPoint = max3(vec3_exports.create(), pointA, pointB);
        const size = vec3_exports.subtract(maxPoint, maxPoint, minPoint);
        return {
          type: "VOLUME",
          corner: toCommaSeparated(minPoint),
          size: toCommaSeparated(size),
          object_labels: objectLabels,
          payload
        };
      }
      case AnnotationType.POINT: {
        return {
          type: "LOCATION",
          corner: toCommaSeparated(annotation.point),
          size: "0,0,0",
          object_labels: objectLabels,
          payload
        };
      }
      case AnnotationType.ELLIPSOID: {
        const corner = vec3_exports.subtract(vec3_exports.create(), annotation.center, annotation.radii);
        const size = vec3_exports.scale(vec3_exports.create(), annotation.radii, 2);
        return {
          type: "LOCATION",
          corner: toCommaSeparated(corner),
          size: toCommaSeparated(size),
          object_labels: objectLabels,
          payload
        };
      }
    }
  }
  var BrainmapsAnnotationGeometryChunkSource = class extends BrainmapsSource(AnnotationGeometryChunkSourceBackend, AnnotationSpatialIndexSourceParameters) {
    async download(chunk, cancellationToken) {
      const { parameters } = this;
      return Promise.all(spatialAnnotationTypes.map((spatialAnnotationType) => makeRequest(parameters.instance, this.credentialsProvider, {
        method: "POST",
        path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,
        payload: JSON.stringify({
          type: spatialAnnotationType,
          ignore_payload: true
        }),
        responseType: "json"
      }, cancellationToken))).then((values) => {
        parseAnnotations(chunk, values);
      });
    }
  };
  BrainmapsAnnotationGeometryChunkSource = __decorateClass([
    registerSharedObject()
  ], BrainmapsAnnotationGeometryChunkSource);
  var BrainmapsAnnotationSource = class extends BrainmapsSource(AnnotationSource2, AnnotationSourceParameters) {
    downloadSegmentFilteredGeometry(chunk, _relationshipIndex, cancellationToken) {
      const { parameters } = this;
      return Promise.all(spatialAnnotationTypes.map((spatialAnnotationType) => makeRequest(parameters.instance, this.credentialsProvider, {
        method: "POST",
        path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,
        payload: JSON.stringify({
          type: spatialAnnotationType,
          object_labels: [chunk.objectId.toString()],
          ignore_payload: true
        }),
        responseType: "json"
      }, cancellationToken))).then((values) => {
        parseAnnotations(chunk, values);
      });
    }
    downloadMetadata(chunk, cancellationToken) {
      const { parameters } = this;
      const id = chunk.key;
      return makeRequest(parameters.instance, this.credentialsProvider, {
        method: "POST",
        path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,
        payload: JSON.stringify({
          type: getSpatialAnnotationTypeFromId(id),
          id: getFullSpatialAnnotationId(parameters, id)
        }),
        responseType: "json"
      }, cancellationToken).then((response) => {
        chunk.annotation = parseAnnotationResponse(response, getIdPrefix(parameters), id);
      }, () => {
        chunk.annotation = null;
      });
    }
    add(annotation) {
      const { parameters } = this;
      const brainmapsAnnotation = annotationToBrainmaps(annotation);
      return makeRequest(parameters.instance, this.credentialsProvider, {
        method: "POST",
        path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:push`,
        payload: JSON.stringify({ annotations: [brainmapsAnnotation] }),
        responseType: "json"
      }).then((response) => {
        verifyObject(response);
        const ids = verifyObjectProperty(response, "ids", verifyStringArray);
        if (ids.length !== 1) {
          throw new Error(`Expected list of 1 id, but received ${JSON.stringify(ids)}.`);
        }
        const idPrefix = getIdPrefix(this.parameters);
        return parseBrainmapsAnnotationId(idPrefix, ids[0]);
      });
    }
    update(id, annotation) {
      const { parameters } = this;
      const brainmapsAnnotation = annotationToBrainmaps(annotation);
      brainmapsAnnotation.id = getFullSpatialAnnotationId(parameters, id);
      return makeRequest(parameters.instance, this.credentialsProvider, {
        method: "POST",
        path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:push`,
        payload: JSON.stringify({ annotations: [brainmapsAnnotation] }),
        responseType: "json"
      });
    }
    delete(id) {
      const { parameters } = this;
      return makeRequest(parameters.instance, this.credentialsProvider, {
        method: "POST",
        path: `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:delete`,
        payload: JSON.stringify({
          type: getSpatialAnnotationTypeFromId(id),
          ids: [getFullSpatialAnnotationId(parameters, id)]
        }),
        responseType: "json"
      });
    }
  };
  BrainmapsAnnotationSource = __decorateClass([
    registerSharedObject()
  ], BrainmapsAnnotationSource);

  // src/neuroglancer/datasource/boss/api.ts
  function fetchWithBossCredentials(credentialsProvider, input, init, transformResponse, cancellationToken = uncancelableToken) {
    return cancellableFetchOk(input, init, transformResponse, cancellationToken).catch((error) => {
      if (error.status !== 500 && error.status !== 401 && error.status !== 403 && error.status !== 504) {
        throw error;
      }
      return fetchWithCredentials(credentialsProvider, input, init, transformResponse, (credentials) => {
        const headers = new Headers(init.headers);
        headers.set("Authorization", `Bearer ${credentials}`);
        return { ...init, headers };
      }, (error2) => {
        const { status } = error2;
        if (status === 403 || status === 401) {
          return "refresh";
        }
        throw error2;
      }, cancellationToken);
    });
  }

  // src/neuroglancer/datasource/boss/base.ts
  var BossSourceParameters = class {
  };
  var VolumeChunkSourceParameters = class extends BossSourceParameters {
    static stringify(parameters) {
      return `boss:volume:${parameters.baseUrl}/${parameters.collection}/${parameters.experiment}/${parameters.channel}/${parameters.resolution}/${parameters.encoding}`;
    }
  };
  VolumeChunkSourceParameters.RPC_ID = "boss/VolumeChunkSource";
  var MeshSourceParameters2 = class {
    static stringify(parameters) {
      return `boss:mesh:${parameters.baseUrl}`;
    }
  };
  MeshSourceParameters2.RPC_ID = "boss/MeshChunkSource";

  // src/neuroglancer/async_computation/decode_gzip_request.ts
  var decodeGzip = asyncComputation("decodeGzip");

  // src/neuroglancer/util/numpy_dtype.ts
  var supportedDataTypes = new Map();
  supportedDataTypes.set("|u1", {
    endianness: Endianness.LITTLE,
    dataType: DataType.UINT8
  });
  supportedDataTypes.set("|i1", {
    endianness: Endianness.LITTLE,
    dataType: DataType.INT8
  });
  for (let [endiannessChar, endianness] of [
    ["<", Endianness.LITTLE],
    [">", Endianness.BIG]
  ]) {
    for (let typeChar of ["u", "i"]) {
      supportedDataTypes.set(`${endiannessChar}${typeChar}8`, {
        endianness,
        dataType: DataType.UINT64
      });
    }
    supportedDataTypes.set(`${endiannessChar}u2`, {
      endianness,
      dataType: DataType.UINT16
    });
    supportedDataTypes.set(`${endiannessChar}i2`, {
      endianness,
      dataType: DataType.INT16
    });
    supportedDataTypes.set(`${endiannessChar}u4`, {
      endianness,
      dataType: DataType.UINT32
    });
    supportedDataTypes.set(`${endiannessChar}i4`, {
      endianness,
      dataType: DataType.INT32
    });
    supportedDataTypes.set(`${endiannessChar}f4`, {
      endianness,
      dataType: DataType.FLOAT32
    });
  }
  function parseNumpyDtype(typestr) {
    const dtype = supportedDataTypes.get(typestr);
    if (dtype === void 0) {
      throw new Error(`Unsupported numpy data type: ${JSON.stringify(typestr)}`);
    }
    return dtype;
  }

  // src/neuroglancer/util/npy.ts
  var NumpyArray = class {
    constructor(data, shape, dataType, fortranOrder) {
      this.data = data;
      this.shape = shape;
      this.dataType = dataType;
      this.fortranOrder = fortranOrder;
    }
  };
  function parseNpy(x) {
    if (x[0] !== 147 || x[1] !== 78 || x[2] !== 85 || x[3] !== 77 || x[4] !== 80 || x[5] !== 89) {
      throw new Error("Data does not match npy format.");
    }
    const majorVersion = x[6], minorVersion = x[7];
    if (majorVersion !== 1 || minorVersion !== 0) {
      throw new Error(`Unsupported npy version ${majorVersion}.${minorVersion}`);
    }
    const dv = new DataView(x.buffer, x.byteOffset, x.byteLength);
    const headerLength = dv.getUint16(8, true);
    const header = new TextDecoder("utf-8").decode(x.subarray(10, headerLength + 10));
    let headerObject;
    const dataOffset = headerLength + 10;
    try {
      headerObject = pythonLiteralParse(header);
    } catch (e) {
      throw new Error(`Failed to parse npy header: ${e}`);
    }
    const dtype = headerObject["descr"];
    let shape = headerObject["shape"];
    let numElements = 1;
    if (!Array.isArray(shape)) {
      throw new Error("Invalid shape ${JSON.stringify(shape)}");
    }
    for (let dim of shape) {
      if (typeof dim !== "number") {
        throw new Error("Invalid shape ${JSON.stringify(shape)}");
      }
      numElements *= dim;
    }
    const { dataType, endianness } = parseNumpyDtype(dtype);
    const bytesPerElement = DATA_TYPE_BYTES[dataType];
    const javascriptElementsPerArrayElement = DATA_TYPE_JAVASCRIPT_ELEMENTS_PER_ARRAY_ELEMENT[dataType];
    const arrayConstructor = DATA_TYPE_ARRAY_CONSTRUCTOR[dataType];
    const javascriptElements = javascriptElementsPerArrayElement * numElements;
    if (bytesPerElement * numElements + dataOffset !== x.byteLength) {
      throw new Error("Expected length does not match length of data");
    }
    const data = new arrayConstructor(x.buffer, x.byteOffset + dataOffset, javascriptElements);
    convertEndian(data, endianness, bytesPerElement);
    return new NumpyArray(data, shape, dataType, headerObject["fortran_order"] === true);
  }

  // src/neuroglancer/sliceview/backend_chunk_decoders/bossNpz.ts
  async function decodeBossNpzChunk(chunk, cancellationToken, response) {
    let parseResult = parseNpy(await requestAsyncComputation(decodeGzip, cancellationToken, [response], new Uint8Array(response)));
    let chunkDataSize = chunk.chunkDataSize;
    let source = chunk.source;
    let { shape } = parseResult;
    if (shape.length !== 3 || shape[0] !== chunkDataSize[2] || shape[1] !== chunkDataSize[1] || shape[2] !== chunkDataSize[0]) {
      throw new Error(`Shape ${JSON.stringify(shape)} does not match chunkDataSize ${vec3Key(chunkDataSize)}`);
    }
    let parsedDataType = parseResult.dataType;
    let { spec } = source;
    if (parsedDataType !== spec.dataType) {
      throw new Error(`Data type ${DataType[parsedDataType]} does not match expected data type ${DataType[spec.dataType]}`);
    }
    await postProcessRawData(chunk, cancellationToken, parseResult.data);
  }

  // src/neuroglancer/datasource/boss/backend.ts
  var chunkDecoders = new Map();
  chunkDecoders.set("npz", decodeBossNpzChunk);
  chunkDecoders.set("jpeg", decodeJpegChunk);
  var acceptHeaders = new Map();
  acceptHeaders.set("npz", "application/npygz");
  acceptHeaders.set("jpeg", "image/jpeg");
  function BossSource(Base, parametersConstructor) {
    return WithParameters(WithSharedCredentialsProviderCounterpart()(Base), parametersConstructor);
  }
  var BossVolumeChunkSource = class extends BossSource(VolumeChunkSource, VolumeChunkSourceParameters) {
    constructor() {
      super(...arguments);
      this.chunkDecoder = chunkDecoders.get(this.parameters.encoding);
    }
    async download(chunk, cancellationToken) {
      let { parameters } = this;
      let url = `${parameters.baseUrl}/latest/cutout/${parameters.collection}/${parameters.experiment}/${parameters.channel}/${parameters.resolution}`;
      {
        let chunkPosition = this.computeChunkBounds(chunk);
        let chunkDataSize = chunk.chunkDataSize;
        for (let i = 0; i < 3; ++i) {
          url += `/${chunkPosition[i]}:${chunkPosition[i] + chunkDataSize[i]}`;
        }
      }
      url += "/";
      if (parameters.window !== void 0) {
        url += `?window=${parameters.window[0]},${parameters.window[1]}`;
      }
      const response = await fetchWithBossCredentials(this.credentialsProvider, url, { headers: { "Accept": acceptHeaders.get(parameters.encoding) } }, responseArrayBuffer, cancellationToken);
      await this.chunkDecoder(chunk, cancellationToken, response);
    }
  };
  BossVolumeChunkSource = __decorateClass([
    registerSharedObject()
  ], BossVolumeChunkSource);
  function decodeManifestChunk(chunk, response) {
    return decodeJsonManifestChunk(chunk, response, "fragments");
  }
  function decodeFragmentChunk(chunk, response) {
    let dv = new DataView(response);
    let numVertices = dv.getUint32(0, true);
    assignMeshFragmentData(chunk, decodeTriangleVertexPositionsAndIndices(response, Endianness.LITTLE, 4, numVertices));
  }
  var BossMeshSource = class extends BossSource(MeshSource, MeshSourceParameters2) {
    download(chunk, cancellationToken) {
      const { parameters } = this;
      return cancellableFetchOk(`${parameters.baseUrl}${chunk.objectId}`, {}, responseArrayBuffer, cancellationToken).then((response) => decodeManifestChunk(chunk, response));
    }
    downloadFragment(chunk, cancellationToken) {
      const { parameters } = this;
      return cancellableFetchOk(`${parameters.baseUrl}${chunk.fragmentId}`, {}, responseArrayBuffer, cancellationToken).then((response) => decodeFragmentChunk(chunk, response));
    }
  };
  BossMeshSource = __decorateClass([
    registerSharedObject()
  ], BossMeshSource);

  // src/neuroglancer/datasource/dvid/base.ts
  var VolumeChunkEncoding2;
  (function(VolumeChunkEncoding6) {
    VolumeChunkEncoding6[VolumeChunkEncoding6["JPEG"] = 0] = "JPEG";
    VolumeChunkEncoding6[VolumeChunkEncoding6["RAW"] = 1] = "RAW";
    VolumeChunkEncoding6[VolumeChunkEncoding6["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
    VolumeChunkEncoding6[VolumeChunkEncoding6["COMPRESSED_SEGMENTATIONARRAY"] = 3] = "COMPRESSED_SEGMENTATIONARRAY";
  })(VolumeChunkEncoding2 || (VolumeChunkEncoding2 = {}));
  var DVIDSourceParameters = class {
  };
  var VolumeChunkSourceParameters2 = class extends DVIDSourceParameters {
  };
  VolumeChunkSourceParameters2.RPC_ID = "dvid/VolumeChunkSource";
  var SkeletonSourceParameters2 = class extends DVIDSourceParameters {
  };
  SkeletonSourceParameters2.RPC_ID = "dvid/SkeletonSource";
  var MeshSourceParameters3 = class extends DVIDSourceParameters {
  };
  MeshSourceParameters3.RPC_ID = "dvid/MeshSource";

  // src/neuroglancer/skeleton/decode_swc_skeleton.ts
  function decodeSwcSkeletonChunk(chunk, swcStr) {
    let swcObjects = parseSwc(swcStr);
    if (swcObjects.length < 1) {
      throw new Error(`ERROR parsing swc data`);
    }
    let indexMap = new Uint32Array(swcObjects.length);
    let nodeCount = 0;
    let edgeCount = 0;
    swcObjects.forEach((swcObj, i) => {
      if (swcObj) {
        indexMap[i] = nodeCount++;
        if (swcObj.parent >= 0) {
          ++edgeCount;
        }
      }
    });
    let glVertices = new Float32Array(3 * nodeCount);
    let glIndices = new Uint32Array(2 * edgeCount);
    let nodeIndex = 0;
    let edgetIndex = 0;
    swcObjects.forEach(function(swcObj) {
      if (swcObj) {
        glVertices[3 * nodeIndex] = swcObj.x;
        glVertices[3 * nodeIndex + 1] = swcObj.y;
        glVertices[3 * nodeIndex + 2] = swcObj.z;
        if (swcObj.parent >= 0) {
          glIndices[2 * edgetIndex] = nodeIndex;
          glIndices[2 * edgetIndex + 1] = indexMap[swcObj.parent];
          ++edgetIndex;
        }
        ++nodeIndex;
      }
    });
    chunk.indices = glIndices;
    chunk.vertexPositions = glVertices;
  }
  function parseSwc(swcStr) {
    let swcInputAr = swcStr.split("\n");
    let swcObjectsAr = new Array();
    let float = "-?\\d*(?:\\.\\d+)?";
    let pattern = new RegExp("^[ \\t]*(" + [
      "\\d+",
      "\\d+",
      float,
      float,
      float,
      float,
      "-1|\\d+"
    ].join(")[ \\t]+(") + ")[ \\t]*$");
    swcInputAr.forEach(function(e) {
      let match = e.match(pattern);
      if (match) {
        let point = swcObjectsAr[parseInt(match[1], 10)] = new PointObj();
        point.type = parseInt(match[2], 10);
        point.x = parseFloat(match[3]);
        point.y = parseFloat(match[4]);
        point.z = parseFloat(match[5]);
        point.radius = parseFloat(match[6]);
        point.parent = parseInt(match[7], 10);
      }
    });
    return swcObjectsAr;
  }
  var PointObj = class {
  };

  // src/neuroglancer/datasource/dvid/api.ts
  var DVIDInstance = class {
    constructor(baseUrl, nodeKey) {
      this.baseUrl = baseUrl;
      this.nodeKey = nodeKey;
    }
    getNodeApiUrl(path = "") {
      return `${this.baseUrl}/api/node/${this.nodeKey}${path}`;
    }
    getRepoInfoUrl() {
      return `${this.baseUrl}/api/repos/info`;
    }
    getKeyValueUrl(dataName, key) {
      return `${this.getNodeApiUrl()}/${dataName}/key/${key}`;
    }
    getKeyValueRangeUrl(dataName, startKey, endKey) {
      return `${this.getNodeApiUrl()}/${dataName}/keyrange/${startKey}/${endKey}`;
    }
    getKeyValuesUrl(dataName) {
      return `${this.getNodeApiUrl()}/${dataName}/keyvalues?jsontar=false`;
    }
  };
  function appendQueryStringForDvid(url, user) {
    if (url.includes("?")) {
      url += "&";
    } else {
      url += "?";
    }
    url += "app=Neuroglancer";
    if (user) {
      url += `&u=${user}`;
    }
    return url;
  }
  function responseText(response) {
    return response.text();
  }
  function makeRequestWithCredentials(credentialsProvider, httpCall, cancellationToken = uncancelableToken) {
    return fetchWithDVIDCredentials(credentialsProvider, httpCall.url, { method: httpCall.method, body: httpCall.payload }, httpCall.responseType === "" ? responseText : httpCall.responseType === "json" ? responseJson : responseArrayBuffer, cancellationToken);
  }
  function fetchWithDVIDCredentials(credentialsProvider, input, init, transformResponse, cancellationToken = uncancelableToken) {
    return fetchWithCredentials(credentialsProvider, input, init, transformResponse, (credentials, init2) => {
      let newInit = { ...init2 };
      if (credentials.token) {
        newInit.headers = { ...newInit.headers, Authorization: `Bearer ${credentials}` };
      }
      return newInit;
    }, (error) => {
      const { status } = error;
      if (status === 403 || status === 401) {
        return "refresh";
      }
      throw error;
    }, cancellationToken);
  }

  // src/neuroglancer/datasource/dvid/backend.ts
  function DVIDSource(Base, parametersConstructor) {
    return WithParameters(WithSharedCredentialsProviderCounterpart()(Base), parametersConstructor);
  }
  var DVIDSkeletonSource = class extends DVIDSource(SkeletonSource, SkeletonSourceParameters2) {
    download(chunk, cancellationToken) {
      const { parameters } = this;
      let bodyid = `${chunk.objectId}`;
      const url = `${parameters.baseUrl}/api/node/${parameters["nodeKey"]}/${parameters["dataInstanceKey"]}/key/` + bodyid + "_swc";
      return makeRequestWithCredentials(this.credentialsProvider, {
        method: "GET",
        url: appendQueryStringForDvid(url, parameters.user),
        responseType: "arraybuffer"
      }, cancellationToken).then((response) => {
        let enc = new TextDecoder("utf-8");
        decodeSwcSkeletonChunk(chunk, enc.decode(response));
      });
    }
  };
  DVIDSkeletonSource = __decorateClass([
    registerSharedObject()
  ], DVIDSkeletonSource);
  function decodeFragmentChunk2(chunk, response) {
    let dv = new DataView(response);
    let numVertices = dv.getUint32(0, true);
    assignMeshFragmentData(chunk, decodeTriangleVertexPositionsAndIndices(response, Endianness.LITTLE, 4, numVertices));
  }
  var DVIDMeshSource = class extends DVIDSource(MeshSource, MeshSourceParameters3) {
    download(chunk) {
      chunk.fragmentIds = [`${chunk.objectId}`];
      return Promise.resolve(void 0);
    }
    downloadFragment(chunk, cancellationToken) {
      const { parameters } = this;
      const dvidInstance = new DVIDInstance(parameters.baseUrl, parameters.nodeKey);
      const meshUrl = dvidInstance.getKeyValueUrl(parameters.dataInstanceKey, `${chunk.fragmentId}.ngmesh`);
      return makeRequestWithCredentials(this.credentialsProvider, {
        method: "GET",
        url: appendQueryStringForDvid(meshUrl, parameters.user),
        responseType: "arraybuffer"
      }, cancellationToken).then((response) => decodeFragmentChunk2(chunk, response));
    }
  };
  DVIDMeshSource = __decorateClass([
    registerSharedObject()
  ], DVIDMeshSource);
  var DVIDVolumeChunkSource = class extends DVIDSource(VolumeChunkSource, VolumeChunkSourceParameters2) {
    async download(chunk, cancellationToken) {
      let params = this.parameters;
      let path;
      {
        let chunkPosition = this.computeChunkBounds(chunk);
        let chunkDataSize = chunk.chunkDataSize;
        path = this.getPath(chunkPosition, chunkDataSize);
      }
      const decoder = this.getDecoder(params);
      const response = await makeRequestWithCredentials(this.credentialsProvider, {
        method: "GET",
        url: appendQueryStringForDvid(`${params.baseUrl}${path}`, params.user),
        responseType: "arraybuffer"
      }, cancellationToken);
      await decoder(chunk, cancellationToken, params.encoding === VolumeChunkEncoding2.JPEG ? response.slice(16) : response);
    }
    getPath(chunkPosition, chunkDataSize) {
      let params = this.parameters;
      if (params.encoding === VolumeChunkEncoding2.JPEG) {
        return `/api/node/${params["nodeKey"]}/${params["dataInstanceKey"]}/subvolblocks/${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}`;
      } else if (params.encoding === VolumeChunkEncoding2.RAW) {
        return `/api/node/${params["nodeKey"]}/${params["dataInstanceKey"]}/raw/0_1_2/${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}/jpeg`;
      } else if (params.encoding === VolumeChunkEncoding2.COMPRESSED_SEGMENTATIONARRAY) {
        return `/api/node/${params["nodeKey"]}/${params["dataInstanceKey"]}/raw/0_1_2/${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip&scale=${params["dataScale"]}`;
      } else {
        return `/api/node/${params["nodeKey"]}/${params["dataInstanceKey"]}/raw/0_1_2/${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip`;
      }
    }
    getDecoder(params) {
      if (params.encoding === VolumeChunkEncoding2.JPEG || params.encoding === VolumeChunkEncoding2.RAW) {
        return decodeJpegChunk;
      } else {
        return decodeCompressedSegmentationChunk;
      }
    }
  };
  DVIDVolumeChunkSource = __decorateClass([
    registerSharedObject()
  ], DVIDVolumeChunkSource);

  // src/neuroglancer/datasource/render/base.ts
  var RenderBaseSourceParameters = class {
  };
  var RenderSourceParameters = class extends RenderBaseSourceParameters {
  };
  var TileChunkSourceParameters = class extends RenderSourceParameters {
  };
  TileChunkSourceParameters.RPC_ID = "render/TileChunkSource";

  // src/neuroglancer/datasource/render/backend.ts
  var chunkDecoders2 = new Map();
  chunkDecoders2.set("jpg", async (chunk, cancellationToken, response) => {
    const chunkDataSize = chunk.chunkDataSize;
    const decoded = await requestAsyncComputation(decodeJpeg, cancellationToken, [response], new Uint8Array(response), chunkDataSize[0], chunkDataSize[1] * chunkDataSize[2], 3, true);
    await postProcessRawData(chunk, cancellationToken, decoded);
  });
  chunkDecoders2.set("raw16", (chunk, cancellationToken, response) => {
    return decodeRawChunk(chunk, cancellationToken, response, Endianness.BIG);
  });
  var TileChunkSource = class extends WithParameters(VolumeChunkSource, TileChunkSourceParameters) {
    constructor() {
      super(...arguments);
      this.chunkDecoder = chunkDecoders2.get(this.parameters.encoding);
      this.queryString = (() => {
        let { parameters } = this;
        let query_params = [];
        if (parameters.channel !== void 0) {
          query_params.push("channels=" + parameters.channel);
        }
        if (parameters.minIntensity !== void 0) {
          query_params.push(`minIntensity=${JSON.stringify(parameters.minIntensity)}`);
        }
        if (parameters.maxIntensity !== void 0) {
          query_params.push(`maxIntensity=${JSON.stringify(parameters.maxIntensity)}`);
        }
        if (parameters.maxTileSpecsToRender !== void 0) {
          query_params.push(`maxTileSpecsToRender=${JSON.stringify(parameters.maxTileSpecsToRender)}`);
        }
        if (parameters.filter !== void 0) {
          query_params.push(`filter=${JSON.stringify(parameters.filter)}`);
        }
        return query_params.join("&");
      })();
    }
    async download(chunk, cancellationToken) {
      let { parameters } = this;
      let { chunkGridPosition } = chunk;
      let scale6 = 1 / Math.pow(2, parameters.level);
      chunk.chunkDataSize = this.spec.chunkDataSize;
      let xTileSize = chunk.chunkDataSize[0] * Math.pow(2, parameters.level);
      let yTileSize = chunk.chunkDataSize[1] * Math.pow(2, parameters.level);
      let chunkPosition = vec3_exports.create();
      chunkPosition[0] = chunkGridPosition[0] * xTileSize;
      chunkPosition[1] = chunkGridPosition[1] * yTileSize;
      chunkPosition[2] = chunkGridPosition[2];
      let imageMethod;
      if (parameters.encoding === "raw16") {
        imageMethod = "raw16-image";
      } else {
        imageMethod = "jpeg-image";
      }
      let path = `/render-ws/v1/owner/${parameters.owner}/project/${parameters.project}/stack/${parameters.stack}/z/${chunkPosition[2]}/box/${chunkPosition[0]},${chunkPosition[1]},${xTileSize},${yTileSize},${scale6}/${imageMethod}`;
      const response = await cancellableFetchOk(`${parameters.baseUrl}${path}?${this.queryString}`, {}, responseArrayBuffer, cancellationToken);
      await this.chunkDecoder(chunk, cancellationToken, response);
    }
  };
  TileChunkSource = __decorateClass([
    registerSharedObject()
  ], TileChunkSource);

  // src/neuroglancer/util/object_id.ts
  var OBJECT_ID_SYMBOL = Symbol("objectId");
  var nextObjectId = 0;
  function getObjectId(x) {
    if (x instanceof Object) {
      let id = x[OBJECT_ID_SYMBOL];
      if (id === void 0) {
        id = x[OBJECT_ID_SYMBOL] = nextObjectId++;
      }
      return `o${id}`;
    } else {
      return "" + JSON.stringify(x);
    }
  }

  // src/neuroglancer/util/s3.ts
  async function cancellableFetchS3Ok(bucket, path, requestInit, transformResponse, cancellationToken = uncancelableToken) {
    return await cancellableFetchOk(`https://${bucket}.s3.amazonaws.com${path}`, requestInit, transformResponse, cancellationToken);
  }

  // src/neuroglancer/util/special_protocol_request.ts
  async function cancellableFetchSpecialOk(credentialsProvider, url, init, transformResponse, cancellationToken = uncancelableToken) {
    const u = parseUrl(url);
    switch (u.protocol) {
      case "gs":
        return fetchWithOAuth2Credentials(credentialsProvider, `https://www.googleapis.com/storage/v1/b/${u.host}/o/${encodeURIComponent(u.path.substring(1))}?alt=media&neuroglancer=${getRandomHexString()}`, init, transformResponse, cancellationToken);
      case "gs+xml":
        return fetchWithOAuth2Credentials(credentialsProvider, `https://storage.googleapis.com/${u.host}${u.path}?neuroglancer=${getRandomHexString()}`, init, transformResponse, cancellationToken);
      case "s3":
        return cancellableFetchS3Ok(u.host, u.path, init, transformResponse, cancellationToken);
      default:
        return fetchWithOAuth2Credentials(credentialsProvider, url, init, transformResponse, cancellationToken);
    }
  }

  // src/neuroglancer/chunk_manager/generic_file_source.ts
  var GenericSharedDataChunk = class extends Chunk {
    constructor() {
      super(...arguments);
      this.backendOnly = true;
    }
    initialize(key) {
      super.initialize(key);
      this.requesters = new Set();
    }
    downloadSucceeded() {
      super.downloadSucceeded();
      let { requesters, data } = this;
      this.requesters = void 0;
      for (let requester of requesters) {
        requester.resolve(data);
      }
    }
    downloadFailed(error) {
      super.downloadFailed(error);
      let { requesters } = this;
      this.requesters = void 0;
      for (let requester of requesters) {
        requester.reject(error);
      }
    }
    freeSystemMemory() {
      this.data = void 0;
    }
  };
  var GenericSharedDataSource = class extends ChunkSourceBase {
    constructor(chunkManager, options) {
      super(chunkManager);
      this.registerDisposer(chunkManager);
      const { encodeKey = stableStringify } = options;
      this.downloadFunction = options.download;
      this.encodeKeyFunction = encodeKey;
      const { sourceQueueLevel = 0 } = options;
      this.sourceQueueLevel = sourceQueueLevel;
      this.registerDisposer(this.chunkManager.recomputeChunkPrioritiesLate.add(() => {
        this.updateChunkPriorities();
      }));
    }
    updateChunkPriorities() {
      let { chunkManager } = this;
      for (let chunk of this.chunks.values()) {
        let { requesters } = chunk;
        if (requesters !== void 0) {
          for (let requester of requesters) {
            const { priorityTier, priority } = requester.getPriority();
            if (priorityTier === ChunkPriorityTier.RECENT)
              continue;
            chunkManager.requestChunk(chunk, priorityTier, priority);
          }
        }
      }
    }
    async download(chunk, cancellationToken) {
      const { size, data } = await this.downloadFunction(chunk.decodedKey, cancellationToken);
      chunk.systemMemoryBytes = size;
      chunk.data = data;
    }
    getData(key, getPriority, cancellationToken) {
      const encodedKey = this.encodeKeyFunction(key);
      let chunk = this.chunks.get(encodedKey);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(GenericSharedDataChunk);
        chunk.decodedKey = key;
        chunk.initialize(encodedKey);
        this.addChunk(chunk);
      }
      return makeCancelablePromise(cancellationToken, (resolve, reject, token) => {
        switch (chunk.state) {
          case ChunkState.FAILED:
            reject(chunk.error);
            return;
          case ChunkState.SYSTEM_MEMORY_WORKER:
            resolve(chunk.data);
            return;
        }
        const requester = { resolve, reject, getPriority };
        chunk.requesters.add(requester);
        token.add(() => {
          let { requesters } = chunk;
          if (requesters !== void 0) {
            requesters.delete(requester);
            this.chunkManager.scheduleUpdateChunkPriorities();
          }
          reject(CANCELED);
        });
        this.chunkManager.scheduleUpdateChunkPriorities();
      });
    }
    static get(chunkManager, memoizeKey, options) {
      return chunkManager.memoize.get(`getFileSource:${memoizeKey}`, () => new GenericSharedDataSource(chunkManager.addRef(), options));
    }
    static getData(chunkManager, memoizeKey, options, key, getPriority, cancellationToken) {
      const source = GenericSharedDataSource.get(chunkManager, memoizeKey, options);
      const result = source.getData(key, getPriority, cancellationToken);
      source.dispose();
      return result;
    }
    static getUrl(chunkManager, credentialsProvider, decodeFunction, url, getPriority, cancellationToken) {
      return GenericSharedDataSource.getData(chunkManager, `${getObjectId(decodeFunction)}`, {
        download: (url2, cancellationToken2) => cancellableFetchSpecialOk(credentialsProvider, url2, {}, responseArrayBuffer, cancellationToken2).then((response) => decodeFunction(response, cancellationToken2))
      }, url, getPriority, cancellationToken);
    }
  };

  // src/neuroglancer/datasource/precomputed/base.ts
  var VolumeChunkEncoding3;
  (function(VolumeChunkEncoding6) {
    VolumeChunkEncoding6[VolumeChunkEncoding6["RAW"] = 0] = "RAW";
    VolumeChunkEncoding6[VolumeChunkEncoding6["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding6[VolumeChunkEncoding6["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
    VolumeChunkEncoding6[VolumeChunkEncoding6["COMPRESSO"] = 3] = "COMPRESSO";
    VolumeChunkEncoding6[VolumeChunkEncoding6["PNG"] = 4] = "PNG";
  })(VolumeChunkEncoding3 || (VolumeChunkEncoding3 = {}));
  var VolumeChunkSourceParameters3 = class {
  };
  VolumeChunkSourceParameters3.RPC_ID = "precomputed/VolumeChunkSource";
  var MeshSourceParameters4 = class {
  };
  MeshSourceParameters4.RPC_ID = "precomputed/MeshSource";
  var DataEncoding;
  (function(DataEncoding2) {
    DataEncoding2[DataEncoding2["RAW"] = 0] = "RAW";
    DataEncoding2[DataEncoding2["GZIP"] = 1] = "GZIP";
  })(DataEncoding || (DataEncoding = {}));
  var ShardingHashFunction;
  (function(ShardingHashFunction2) {
    ShardingHashFunction2[ShardingHashFunction2["IDENTITY"] = 0] = "IDENTITY";
    ShardingHashFunction2[ShardingHashFunction2["MURMURHASH3_X86_128"] = 1] = "MURMURHASH3_X86_128";
  })(ShardingHashFunction || (ShardingHashFunction = {}));
  var MultiscaleMeshSourceParameters2 = class {
  };
  MultiscaleMeshSourceParameters2.RPC_ID = "precomputed/MultiscaleMeshSource";
  var SkeletonSourceParameters3 = class {
  };
  SkeletonSourceParameters3.RPC_ID = "precomputed/SkeletonSource";
  var AnnotationSpatialIndexSourceParameters2 = class {
  };
  AnnotationSpatialIndexSourceParameters2.RPC_ID = "precomputed/AnnotationSpatialIndexSource";
  var AnnotationSourceParameters2 = class {
  };
  AnnotationSourceParameters2.RPC_ID = "precomputed/AnnotationSource";
  var IndexedSegmentPropertySourceParameters = class {
  };
  IndexedSegmentPropertySourceParameters.RPC_ID = "precomputed/IndexedSegmentPropertySource";

  // src/neuroglancer/skeleton/decode_precomputed_skeleton.ts
  function decodeSkeletonChunk2(chunk, response, vertexAttributes) {
    let dv = new DataView(response);
    let numVertices = dv.getUint32(0, true);
    let numEdges = dv.getUint32(4, true);
    const vertexPositionsStartOffset = 8;
    let curOffset = 8 + numVertices * 4 * 3;
    decodeSkeletonVertexPositionsAndIndices(chunk, response, Endianness.LITTLE, vertexPositionsStartOffset, numVertices, curOffset, numEdges);
    curOffset += numEdges * 4 * 2;
    let attributes = [];
    for (let info of vertexAttributes.values()) {
      const bytesPerVertex = DATA_TYPE_BYTES[info.dataType] * info.numComponents;
      const totalBytes = bytesPerVertex * numVertices;
      const attribute = new Uint8Array(response, curOffset, totalBytes);
      switch (bytesPerVertex) {
        case 2:
          convertEndian16(attribute, Endianness.LITTLE);
          break;
        case 4:
        case 8:
          convertEndian32(attribute, Endianness.LITTLE);
          break;
      }
      attributes.push(attribute);
      curOffset += totalBytes;
    }
    chunk.vertexAttributes = attributes;
  }

  // src/neuroglancer/async_computation/decode_compresso_request.ts
  var decodeCompresso = asyncComputation("decodeCompresso");

  // src/neuroglancer/sliceview/backend_chunk_decoders/compresso.ts
  async function decodeCompressoChunk(chunk, cancellationToken, response) {
    let image = await requestAsyncComputation(decodeCompresso, cancellationToken, [response], new Uint8Array(response));
    await decodeRawChunk(chunk, cancellationToken, image.buffer);
  }

  // src/neuroglancer/async_computation/decode_png_request.ts
  var decodePng = asyncComputation("decodePng");

  // src/neuroglancer/sliceview/backend_chunk_decoders/png.ts
  async function decodePngChunk(chunk, cancellationToken, response) {
    const chunkDataSize = chunk.chunkDataSize;
    const dataType = chunk.source.spec.dataType;
    let image = await requestAsyncComputation(decodePng, cancellationToken, [response], new Uint8Array(response), chunkDataSize[0], chunkDataSize[1] * chunkDataSize[2], chunkDataSize[3] || 1, DATA_TYPE_BYTES[dataType], false);
    await decodeRawChunk(chunk, cancellationToken, image.buffer);
  }

  // src/neuroglancer/util/byte_range_http_requests.ts
  var cacheMode = navigator.userAgent.indexOf("Chrome") !== -1 ? "no-store" : "default";
  function fetchSpecialHttpByteRange(credentialsProvider, url, startOffset, endOffset, cancellationToken) {
    return cancellableFetchSpecialOk(credentialsProvider, url, {
      headers: getByteRangeHeader(startOffset, endOffset),
      cache: cacheMode
    }, responseArrayBuffer, cancellationToken);
  }

  // src/neuroglancer/util/hash.ts
  function murmurHash3_x86_128Mix(h) {
    h ^= h >>> 16;
    h = Math.imul(h, 2246822507);
    h ^= h >>> 13;
    h = Math.imul(h, 3266489909);
    h ^= h >>> 16;
    return h;
  }
  function rotl32(x, r) {
    return x << r | x >>> 32 - r;
  }
  function murmurHash3_x86_128Hash64Bits(out, seed, low, high) {
    let h1 = seed, h2 = seed, h3 = seed, h4 = seed;
    const c1 = 597399067;
    const c2 = 2869860233;
    const c3 = 951274213;
    let k22 = Math.imul(high, c2);
    k22 = rotl32(k22, 16);
    k22 = Math.imul(k22, c3);
    h2 ^= k22;
    let k12 = Math.imul(low, c1);
    k12 = rotl32(k12, 15);
    k12 = Math.imul(k12, c2);
    h1 ^= k12;
    const len4 = 8;
    h1 ^= len4;
    h2 ^= len4;
    h3 ^= len4;
    h4 ^= len4;
    h1 = h1 + h2 >>> 0;
    h1 = h1 + h3 >>> 0;
    h1 = h1 + h4 >>> 0;
    h2 = h2 + h1 >>> 0;
    h3 = h3 + h1 >>> 0;
    h4 = h4 + h1 >>> 0;
    h1 = murmurHash3_x86_128Mix(h1);
    h2 = murmurHash3_x86_128Mix(h2);
    h3 = murmurHash3_x86_128Mix(h3);
    h4 = murmurHash3_x86_128Mix(h4);
    h1 = h1 + h2 >>> 0;
    h1 = h1 + h3 >>> 0;
    h1 = h1 + h4 >>> 0;
    h2 = h2 + h1 >>> 0;
    out.low = h1;
    out.high = h2;
    return out;
  }

  // src/neuroglancer/datasource/precomputed/backend.ts
  var DEBUG_MULTISCALE_INDEX = false;
  var shardingHashFunctions = new Map([
    [
      ShardingHashFunction.MURMURHASH3_X86_128,
      (out) => {
        murmurHash3_x86_128Hash64Bits(out, 0, out.low, out.high);
      }
    ],
    [ShardingHashFunction.IDENTITY, (_out) => {
    }]
  ]);
  function getMinishardIndexDataSource(chunkManager, credentialsProvider, parameters) {
    const { url, sharding } = parameters;
    if (sharding === void 0)
      return void 0;
    const source = GenericSharedDataSource.get(chunkManager, stableStringify({
      type: "precomputed:shardedDataSource",
      url,
      sharding,
      credentialsProvider: getObjectId(credentialsProvider)
    }), {
      download: async function(shardAndMinishard, cancellationToken) {
        const minishard = Uint64.lowMask(new Uint64(), sharding.minishardBits);
        Uint64.and(minishard, minishard, shardAndMinishard);
        const shard = Uint64.lowMask(new Uint64(), sharding.shardBits);
        const temp = new Uint64();
        Uint64.rshift(temp, shardAndMinishard, sharding.minishardBits);
        Uint64.and(shard, shard, temp);
        const shardUrl = `${url}/${shard.toString(16).padStart(Math.ceil(sharding.shardBits / 4), "0")}.shard`;
        const shardIndexSize = new Uint64(16);
        Uint64.lshift(shardIndexSize, shardIndexSize, sharding.minishardBits);
        const shardIndexStart = Uint64.lshift(new Uint64(), minishard, 4);
        const shardIndexEnd = Uint64.addUint32(new Uint64(), shardIndexStart, 16);
        let shardIndexResponse;
        try {
          shardIndexResponse = await fetchSpecialHttpByteRange(credentialsProvider, shardUrl, shardIndexStart, shardIndexEnd, cancellationToken);
        } catch (e) {
          if (isNotFoundError(e))
            return { data: void 0, size: 0 };
          throw e;
        }
        if (shardIndexResponse.byteLength !== 16) {
          throw new Error(`Failed to retrieve minishard offset`);
        }
        const shardIndexDv = new DataView(shardIndexResponse);
        const minishardStartOffset = new Uint64(shardIndexDv.getUint32(0, true), shardIndexDv.getUint32(4, true));
        const minishardEndOffset = new Uint64(shardIndexDv.getUint32(8, true), shardIndexDv.getUint32(12, true));
        if (Uint64.equal(minishardStartOffset, minishardEndOffset)) {
          return { data: void 0, size: 0 };
        }
        Uint64.add(minishardStartOffset, minishardStartOffset, shardIndexSize);
        Uint64.add(minishardEndOffset, minishardEndOffset, shardIndexSize);
        let minishardIndexResponse = await fetchSpecialHttpByteRange(credentialsProvider, shardUrl, minishardStartOffset, minishardEndOffset, cancellationToken);
        if (sharding.minishardIndexEncoding === DataEncoding.GZIP) {
          minishardIndexResponse = (await requestAsyncComputation(decodeGzip, cancellationToken, [minishardIndexResponse], new Uint8Array(minishardIndexResponse))).buffer;
        }
        if (minishardIndexResponse.byteLength % 24 !== 0) {
          throw new Error(`Invalid minishard index length: ${minishardIndexResponse.byteLength}`);
        }
        const minishardIndex = new Uint32Array(minishardIndexResponse);
        convertEndian32(minishardIndex, Endianness.LITTLE);
        const minishardIndexSize = minishardIndex.byteLength / 24;
        let prevEntryKeyLow = 0, prevEntryKeyHigh = 0;
        let prevStartLow = shardIndexSize.low, prevStartHigh = shardIndexSize.high;
        for (let i = 0; i < minishardIndexSize; ++i) {
          let entryKeyLow = prevEntryKeyLow + minishardIndex[i * 2];
          let entryKeyHigh = prevEntryKeyHigh + minishardIndex[i * 2 + 1];
          if (entryKeyLow >= 4294967296) {
            entryKeyLow -= 4294967296;
            entryKeyHigh += 1;
          }
          prevEntryKeyLow = minishardIndex[i * 2] = entryKeyLow;
          prevEntryKeyHigh = minishardIndex[i * 2 + 1] = entryKeyHigh;
          let startLow = prevStartLow + minishardIndex[(minishardIndexSize + i) * 2];
          let startHigh = prevStartHigh + minishardIndex[(minishardIndexSize + i) * 2 + 1];
          if (startLow >= 4294967296) {
            startLow -= 4294967296;
            startHigh += 1;
          }
          minishardIndex[(minishardIndexSize + i) * 2] = startLow;
          minishardIndex[(minishardIndexSize + i) * 2 + 1] = startHigh;
          const sizeLow = minishardIndex[(2 * minishardIndexSize + i) * 2];
          const sizeHigh = minishardIndex[(2 * minishardIndexSize + i) * 2 + 1];
          let endLow = startLow + sizeLow;
          let endHigh = startHigh + sizeHigh;
          if (endLow >= 4294967296) {
            endLow -= 4294967296;
            endHigh += 1;
          }
          prevStartLow = endLow;
          prevStartHigh = endHigh;
          minishardIndex[(2 * minishardIndexSize + i) * 2] = endLow;
          minishardIndex[(2 * minishardIndexSize + i) * 2 + 1] = endHigh;
        }
        return { data: { data: minishardIndex, shardUrl }, size: minishardIndex.byteLength };
      },
      encodeKey: (key) => key.toString(),
      sourceQueueLevel: 1
    });
    source.sharding = sharding;
    source.credentialsProvider = credentialsProvider;
    return source;
  }
  function findMinishardEntry(minishardIndex, key) {
    const minishardIndexData = minishardIndex.data;
    const minishardIndexSize = minishardIndexData.length / 6;
    const keyLow = key.low, keyHigh = key.high;
    for (let i = 0; i < minishardIndexSize; ++i) {
      if (minishardIndexData[i * 2] !== keyLow || minishardIndexData[i * 2 + 1] !== keyHigh) {
        continue;
      }
      const startOffset = new Uint64(minishardIndexData[(minishardIndexSize + i) * 2], minishardIndexData[(minishardIndexSize + i) * 2 + 1]);
      const endOffset = new Uint64(minishardIndexData[(2 * minishardIndexSize + i) * 2], minishardIndexData[(2 * minishardIndexSize + i) * 2 + 1]);
      return { startOffset, endOffset };
    }
    return void 0;
  }
  async function getShardedData(minishardIndexSource, chunk, key, cancellationToken) {
    const { sharding } = minishardIndexSource;
    const hashFunction = shardingHashFunctions.get(sharding.hash);
    const hashCode = Uint64.rshift(new Uint64(), key, sharding.preshiftBits);
    hashFunction(hashCode);
    const shardAndMinishard = Uint64.lowMask(new Uint64(), sharding.minishardBits + sharding.shardBits);
    Uint64.and(shardAndMinishard, shardAndMinishard, hashCode);
    const getPriority = () => ({ priorityTier: chunk.priorityTier, priority: chunk.priority });
    const minishardIndex = await minishardIndexSource.getData(shardAndMinishard, getPriority, cancellationToken);
    if (minishardIndex === void 0)
      return void 0;
    const minishardEntry = findMinishardEntry(minishardIndex, key);
    if (minishardEntry === void 0)
      return void 0;
    const { startOffset, endOffset } = minishardEntry;
    let data = await fetchSpecialHttpByteRange(minishardIndexSource.credentialsProvider, minishardIndex.shardUrl, startOffset, endOffset, cancellationToken);
    if (minishardIndexSource.sharding.dataEncoding === DataEncoding.GZIP) {
      data = (await requestAsyncComputation(decodeGzip, cancellationToken, [data], new Uint8Array(data))).buffer;
    }
    return { data, shardInfo: { shardUrl: minishardIndex.shardUrl, offset: startOffset } };
  }
  function getOrNotFoundError(v) {
    if (v === void 0)
      throw new Error("not found");
    return v;
  }
  var chunkDecoders3 = new Map();
  chunkDecoders3.set(VolumeChunkEncoding3.RAW, decodeRawChunk);
  chunkDecoders3.set(VolumeChunkEncoding3.JPEG, decodeJpegChunk);
  chunkDecoders3.set(VolumeChunkEncoding3.COMPRESSED_SEGMENTATION, decodeCompressedSegmentationChunk);
  chunkDecoders3.set(VolumeChunkEncoding3.COMPRESSO, decodeCompressoChunk);
  chunkDecoders3.set(VolumeChunkEncoding3.PNG, decodePngChunk);
  var PrecomputedVolumeChunkSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(VolumeChunkSource), VolumeChunkSourceParameters3) {
    constructor() {
      super(...arguments);
      this.chunkDecoder = chunkDecoders3.get(this.parameters.encoding);
      this.minishardIndexSource = getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, this.parameters);
      this.gridShape = (() => {
        const gridShape = new Uint32Array(3);
        const { upperVoxelBound, chunkDataSize } = this.spec;
        for (let i = 0; i < 3; ++i) {
          gridShape[i] = Math.ceil(upperVoxelBound[i] / chunkDataSize[i]);
        }
        return gridShape;
      })();
    }
    async download(chunk, cancellationToken) {
      var _a;
      const { parameters } = this;
      const { minishardIndexSource } = this;
      let response;
      if (minishardIndexSource === void 0) {
        let url;
        {
          let chunkPosition = this.computeChunkBounds(chunk);
          let chunkDataSize = chunk.chunkDataSize;
          url = `${parameters.url}/${chunkPosition[0]}-${chunkPosition[0] + chunkDataSize[0]}_${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;
        }
        try {
          response = await cancellableFetchSpecialOk(this.credentialsProvider, url, {}, responseArrayBuffer, cancellationToken);
        } catch (e) {
          if (isNotFoundError(e)) {
            response = void 0;
          } else {
            throw e;
          }
        }
      } else {
        this.computeChunkBounds(chunk);
        const { gridShape } = this;
        const { chunkGridPosition } = chunk;
        const xBits = Math.ceil(Math.log2(gridShape[0])), yBits = Math.ceil(Math.log2(gridShape[1])), zBits = Math.ceil(Math.log2(gridShape[2]));
        const chunkIndex = encodeZIndexCompressed3d(new Uint64(), xBits, yBits, zBits, chunkGridPosition[0], chunkGridPosition[1], chunkGridPosition[2]);
        response = (_a = await getShardedData(minishardIndexSource, chunk, chunkIndex, cancellationToken)) == null ? void 0 : _a.data;
      }
      if (response !== void 0) {
        await this.chunkDecoder(chunk, cancellationToken, response);
      }
    }
  };
  PrecomputedVolumeChunkSource = __decorateClass([
    registerSharedObject()
  ], PrecomputedVolumeChunkSource);
  function decodeManifestChunk2(chunk, response) {
    return decodeJsonManifestChunk(chunk, response, "fragments");
  }
  function decodeFragmentChunk3(chunk, response) {
    let dv = new DataView(response);
    let numVertices = dv.getUint32(0, true);
    assignMeshFragmentData(chunk, decodeTriangleVertexPositionsAndIndices(response, Endianness.LITTLE, 4, numVertices));
  }
  var PrecomputedMeshSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(MeshSource), MeshSourceParameters4) {
    async download(chunk, cancellationToken) {
      const { parameters } = this;
      const response = await cancellableFetchSpecialOk(this.credentialsProvider, `${parameters.url}/${chunk.objectId}:${parameters.lod}`, {}, responseJson, cancellationToken);
      decodeManifestChunk2(chunk, response);
    }
    async downloadFragment(chunk, cancellationToken) {
      const { parameters } = this;
      const response = await cancellableFetchSpecialOk(this.credentialsProvider, `${parameters.url}/${chunk.fragmentId}`, {}, responseArrayBuffer, cancellationToken);
      decodeFragmentChunk3(chunk, response);
    }
  };
  PrecomputedMeshSource = __decorateClass([
    registerSharedObject()
  ], PrecomputedMeshSource);
  function decodeMultiscaleManifestChunk2(chunk, response) {
    if (response.byteLength < 28 || response.byteLength % 4 !== 0) {
      throw new Error(`Invalid index file size: ${response.byteLength}`);
    }
    const dv = new DataView(response);
    let offset = 0;
    const chunkShape = vec3_exports.fromValues(dv.getFloat32(offset, true), dv.getFloat32(offset + 4, true), dv.getFloat32(offset + 8, true));
    offset += 12;
    const gridOrigin = vec3_exports.fromValues(dv.getFloat32(offset, true), dv.getFloat32(offset + 4, true), dv.getFloat32(offset + 8, true));
    offset += 12;
    const numStoredLods = dv.getUint32(offset, true);
    offset += 4;
    if (response.byteLength < offset + (4 + 4 + 4 * 3) * numStoredLods) {
      throw new Error(`Invalid index file size for ${numStoredLods} lods: ${response.byteLength}`);
    }
    const storedLodScales = new Float32Array(response, offset, numStoredLods);
    offset += 4 * numStoredLods;
    convertEndian32(storedLodScales, Endianness.LITTLE);
    const vertexOffsets = new Float32Array(response, offset, numStoredLods * 3);
    convertEndian32(vertexOffsets, Endianness.LITTLE);
    offset += 12 * numStoredLods;
    const numFragmentsPerLod = new Uint32Array(response, offset, numStoredLods);
    offset += 4 * numStoredLods;
    convertEndian32(numFragmentsPerLod, Endianness.LITTLE);
    const totalFragments = numFragmentsPerLod.reduce((a, b) => a + b);
    if (response.byteLength !== offset + 16 * totalFragments) {
      throw new Error(`Invalid index file size for ${numStoredLods} lods and ${totalFragments} total fragments: ${response.byteLength}`);
    }
    const fragmentInfo = new Uint32Array(response, offset);
    convertEndian32(fragmentInfo, Endianness.LITTLE);
    const clipLowerBound = vec3_exports.fromValues(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
    const clipUpperBound = vec3_exports.fromValues(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    let numLods = Math.max(1, storedLodScales.length);
    {
      let fragmentBase = 0;
      for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {
        const numFragments = numFragmentsPerLod[lodIndex];
        if (DEBUG_MULTISCALE_INDEX) {
          for (let i = 1; i < numFragments; ++i) {
            let x0 = fragmentInfo[fragmentBase + numFragments * 0 + (i - 1)];
            let y0 = fragmentInfo[fragmentBase + numFragments * 1 + (i - 1)];
            let z0 = fragmentInfo[fragmentBase + numFragments * 2 + (i - 1)];
            let x1 = fragmentInfo[fragmentBase + numFragments * 0 + i];
            let y1 = fragmentInfo[fragmentBase + numFragments * 1 + i];
            let z1 = fragmentInfo[fragmentBase + numFragments * 2 + i];
            if (!zorder3LessThan(x0, y0, z0, x1, y1, z1)) {
              console.log(`Fragment index violates zorder constraint: lod=${lodIndex}, chunk ${i - 1} = [${x0},${y0},${z0}], chunk ${i} = [${x1},${y1},${z1}]`);
            }
          }
        }
        for (let i = 0; i < 3; ++i) {
          let upperBoundValue = Number.NEGATIVE_INFINITY;
          let lowerBoundValue = Number.POSITIVE_INFINITY;
          const base = fragmentBase + numFragments * i;
          for (let j = 0; j < numFragments; ++j) {
            const v = fragmentInfo[base + j];
            upperBoundValue = Math.max(upperBoundValue, v);
            lowerBoundValue = Math.min(lowerBoundValue, v);
          }
          if (numFragments != 0) {
            while (upperBoundValue >>> numLods - lodIndex - 1 != lowerBoundValue >>> numLods - lodIndex - 1) {
              ++numLods;
            }
            if (lodIndex === 0) {
              clipLowerBound[i] = Math.min(clipLowerBound[i], (1 << lodIndex) * lowerBoundValue);
              clipUpperBound[i] = Math.max(clipUpperBound[i], (1 << lodIndex) * (upperBoundValue + 1));
            }
          }
        }
        fragmentBase += numFragments * 4;
      }
    }
    let maxFragments = 0;
    {
      let prevNumFragments = 0;
      let prevLodIndex = 0;
      for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {
        const numFragments = numFragmentsPerLod[lodIndex];
        maxFragments += prevNumFragments * (lodIndex - prevLodIndex);
        prevLodIndex = lodIndex;
        prevNumFragments = numFragments;
        maxFragments += numFragments;
      }
      maxFragments += (numLods - 1 - prevLodIndex) * prevNumFragments;
    }
    const octreeTemp = new Uint32Array(5 * maxFragments);
    const offsetsTemp = new Float64Array(maxFragments + 1);
    let octree;
    {
      let priorStart = 0;
      let baseRow = 0;
      let dataOffset = 0;
      let fragmentBase = 0;
      for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {
        const numFragments = numFragmentsPerLod[lodIndex];
        for (let j = 0; j < numFragments; ++j) {
          for (let i = 0; i < 3; ++i) {
            octreeTemp[5 * (baseRow + j) + i] = fragmentInfo[fragmentBase + j + i * numFragments];
          }
          const dataSize = fragmentInfo[fragmentBase + j + 3 * numFragments];
          dataOffset += dataSize;
          offsetsTemp[baseRow + j + 1] = dataOffset;
          if (dataSize === 0) {
            octreeTemp[5 * (baseRow + j) + 4] = 2147483648;
          }
        }
        fragmentBase += 4 * numFragments;
        if (lodIndex !== 0) {
          computeOctreeChildOffsets(octreeTemp, priorStart, baseRow, baseRow + numFragments);
        }
        priorStart = baseRow;
        baseRow += numFragments;
        while (lodIndex + 1 < numLods && (lodIndex + 1 >= storedLodScales.length || storedLodScales[lodIndex + 1] === 0)) {
          const curEnd = generateHigherOctreeLevel(octreeTemp, priorStart, baseRow);
          offsetsTemp.fill(dataOffset, baseRow + 1, curEnd + 1);
          priorStart = baseRow;
          baseRow = curEnd;
          ++lodIndex;
        }
      }
      octree = octreeTemp.slice(0, 5 * baseRow);
      chunk.offsets = offsetsTemp.slice(0, baseRow + 1);
    }
    const source = chunk.source;
    const { lodScaleMultiplier } = source.parameters.metadata;
    const lodScales = new Float32Array(numLods);
    lodScales.set(storedLodScales, 0);
    for (let i = 0; i < storedLodScales.length; ++i) {
      lodScales[i] *= lodScaleMultiplier;
    }
    chunk.manifest = {
      chunkShape,
      chunkGridSpatialOrigin: gridOrigin,
      clipLowerBound: vec3_exports.add(clipLowerBound, gridOrigin, vec3_exports.multiply(clipLowerBound, clipLowerBound, chunkShape)),
      clipUpperBound: vec3_exports.add(clipUpperBound, gridOrigin, vec3_exports.multiply(clipUpperBound, clipUpperBound, chunkShape)),
      octree,
      lodScales,
      vertexOffsets
    };
  }
  async function decodeMultiscaleFragmentChunk(chunk, response) {
    const { lod } = chunk;
    const source = chunk.manifestChunk.source;
    const m = await Promise.resolve().then(() => (init_draco(), draco_exports));
    const rawMesh = await m.decodeDracoPartitioned(new Uint8Array(response), source.parameters.metadata.vertexQuantizationBits, lod !== 0);
    assignMultiscaleMeshFragmentData(chunk, rawMesh, source.format.vertexPositionFormat);
  }
  var PrecomputedMultiscaleMeshSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(MultiscaleMeshSource), MultiscaleMeshSourceParameters2) {
    constructor() {
      super(...arguments);
      this.minishardIndexSource = getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, { url: this.parameters.url, sharding: this.parameters.metadata.sharding });
    }
    async download(chunk, cancellationToken) {
      const { parameters, minishardIndexSource } = this;
      let data;
      if (minishardIndexSource === void 0) {
        data = await cancellableFetchSpecialOk(this.credentialsProvider, `${parameters.url}/${chunk.objectId}.index`, {}, responseArrayBuffer, cancellationToken);
      } else {
        ({ data, shardInfo: chunk.shardInfo } = getOrNotFoundError(await getShardedData(minishardIndexSource, chunk, chunk.objectId, cancellationToken)));
      }
      decodeMultiscaleManifestChunk2(chunk, data);
    }
    async downloadFragment(chunk, cancellationToken) {
      const { parameters } = this;
      const manifestChunk = chunk.manifestChunk;
      const chunkIndex = chunk.chunkIndex;
      const { shardInfo, offsets } = manifestChunk;
      const startOffset = offsets[chunkIndex];
      const endOffset = offsets[chunkIndex + 1];
      let requestUrl;
      let adjustedStartOffset, adjustedEndOffset;
      if (shardInfo !== void 0) {
        requestUrl = shardInfo.shardUrl;
        const fullDataSize = offsets[offsets.length - 1];
        let startLow = shardInfo.offset.low - fullDataSize + startOffset;
        let startHigh = shardInfo.offset.high;
        let endLow = startLow + endOffset - startOffset;
        let endHigh = startHigh;
        while (startLow < 0) {
          startLow += 4294967296;
          startHigh -= 1;
        }
        while (endLow < 0) {
          endLow += 4294967296;
          endHigh -= 1;
        }
        while (endLow > 4294967296) {
          endLow -= 4294967296;
          endHigh += 1;
        }
        adjustedStartOffset = new Uint64(startLow, startHigh);
        adjustedEndOffset = new Uint64(endLow, endHigh);
      } else {
        requestUrl = `${parameters.url}/${manifestChunk.objectId}`;
        adjustedStartOffset = startOffset;
        adjustedEndOffset = endOffset;
      }
      const response = await fetchSpecialHttpByteRange(this.credentialsProvider, requestUrl, adjustedStartOffset, adjustedEndOffset, cancellationToken);
      await decodeMultiscaleFragmentChunk(chunk, response);
    }
  };
  PrecomputedMultiscaleMeshSource = __decorateClass([
    registerSharedObject()
  ], PrecomputedMultiscaleMeshSource);
  async function fetchByUint64(credentialsProvider, url, chunk, minishardIndexSource, id, cancellationToken) {
    if (minishardIndexSource === void 0) {
      try {
        return await cancellableFetchSpecialOk(credentialsProvider, `${url}/${id}`, {}, responseArrayBuffer, cancellationToken);
      } catch (e) {
        if (isNotFoundError(e))
          return void 0;
        throw e;
      }
    }
    const result = await getShardedData(minishardIndexSource, chunk, id, cancellationToken);
    if (result === void 0)
      return void 0;
    return result.data;
  }
  var PrecomputedSkeletonSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(SkeletonSource), SkeletonSourceParameters3) {
    constructor() {
      super(...arguments);
      this.minishardIndexSource = getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, { url: this.parameters.url, sharding: this.parameters.metadata.sharding });
    }
    async download(chunk, cancellationToken) {
      const { parameters } = this;
      const response = getOrNotFoundError(await fetchByUint64(this.credentialsProvider, parameters.url, chunk, this.minishardIndexSource, chunk.objectId, cancellationToken));
      decodeSkeletonChunk2(chunk, response, parameters.metadata.vertexAttributes);
    }
  };
  PrecomputedSkeletonSource = __decorateClass([
    registerSharedObject()
  ], PrecomputedSkeletonSource);
  function parseAnnotations2(buffer, parameters, propertySerializer) {
    const dv = new DataView(buffer);
    if (buffer.byteLength <= 8)
      throw new Error("Expected at least 8 bytes");
    const countLow = dv.getUint32(0, true);
    const countHigh = dv.getUint32(4, true);
    if (countHigh !== 0)
      throw new Error("Annotation count too high");
    const numBytes = propertySerializer.serializedBytes;
    const expectedBytes = 8 + (numBytes + 8) * countLow;
    if (buffer.byteLength !== expectedBytes) {
      throw new Error(`Expected ${expectedBytes} bytes, but received: ${buffer.byteLength} bytes`);
    }
    const idOffset = 8 + numBytes * countLow;
    const id = new Uint64();
    const ids = new Array(countLow);
    for (let i = 0; i < countLow; ++i) {
      id.low = dv.getUint32(idOffset + i * 8, true);
      id.high = dv.getUint32(idOffset + i * 8 + 4, true);
      ids[i] = id.toString();
    }
    const geometryData = new AnnotationGeometryData();
    const origData = new Uint8Array(buffer, 8, numBytes * countLow);
    let data;
    const { propertyGroupBytes } = propertySerializer;
    if (propertyGroupBytes.length > 1) {
      data = new Uint8Array(origData.length);
      let origOffset = 0;
      let groupOffset = 0;
      for (let groupIndex = 0; groupIndex < propertyGroupBytes.length; ++groupIndex) {
        const groupBytesPerAnnotation = propertyGroupBytes[groupIndex];
        for (let annotationIndex = 0; annotationIndex < countLow; ++annotationIndex) {
          let origBase = origOffset + annotationIndex * numBytes;
          let newBase = groupOffset + annotationIndex * groupBytesPerAnnotation;
          for (let i = 0; i < groupBytesPerAnnotation; ++i) {
            data[newBase + i] = origData[origBase + i];
          }
        }
        origOffset += groupBytesPerAnnotation;
        groupOffset += groupBytesPerAnnotation * countLow;
      }
    } else {
      data = origData;
    }
    geometryData.data = data;
    const typeToOffset = geometryData.typeToOffset = new Array(annotationTypes.length);
    typeToOffset.fill(0);
    typeToOffset[parameters.type] = 0;
    const typeToIds = geometryData.typeToIds = new Array(annotationTypes.length);
    const typeToIdMaps = geometryData.typeToIdMaps = new Array(annotationTypes.length);
    typeToIds.fill([]);
    typeToIds[parameters.type] = ids;
    typeToIdMaps.fill(new Map());
    typeToIdMaps[parameters.type] = new Map(ids.map((id2, i) => [id2, i]));
    return geometryData;
  }
  function parseSingleAnnotation(buffer, parameters, propertySerializer, id) {
    const handler = annotationTypeHandlers[parameters.type];
    const baseNumBytes = propertySerializer.serializedBytes;
    const numRelationships = parameters.relationships.length;
    const minNumBytes = baseNumBytes + 4 * numRelationships;
    if (buffer.byteLength < minNumBytes) {
      throw new Error(`Expected at least ${minNumBytes} bytes, but received: ${buffer.byteLength}`);
    }
    const dv = new DataView(buffer);
    const annotation = handler.deserialize(dv, 0, true, parameters.rank, id);
    propertySerializer.deserialize(dv, 0, 0, 1, true, annotation.properties = new Array(parameters.properties.length));
    let offset = baseNumBytes;
    const relatedSegments = annotation.relatedSegments = [];
    relatedSegments.length = numRelationships;
    for (let i = 0; i < numRelationships; ++i) {
      const count = dv.getUint32(offset, true);
      if (buffer.byteLength < minNumBytes + count * 8) {
        throw new Error(`Expected at least ${minNumBytes} bytes, but received: ${buffer.byteLength}`);
      }
      offset += 4;
      const segments = relatedSegments[i] = [];
      for (let j = 0; j < count; ++j) {
        segments[j] = new Uint64(dv.getUint32(offset, true), dv.getUint32(offset + 4, true));
        offset += 8;
      }
    }
    if (offset !== buffer.byteLength) {
      throw new Error(`Expected ${offset} bytes, but received: ${buffer.byteLength}`);
    }
    return annotation;
  }
  var PrecomputedAnnotationSpatialIndexSourceBackend = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(AnnotationGeometryChunkSourceBackend), AnnotationSpatialIndexSourceParameters2) {
    constructor() {
      super(...arguments);
      this.minishardIndexSource = getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, this.parameters);
    }
    async download(chunk, cancellationToken) {
      const { parameters } = this;
      const { minishardIndexSource } = this;
      const { parent } = this;
      let response;
      const { chunkGridPosition } = chunk;
      if (minishardIndexSource === void 0) {
        const url = `${parameters.url}/${chunkGridPosition.join("_")}`;
        try {
          response = await cancellableFetchSpecialOk(this.credentialsProvider, url, {}, responseArrayBuffer, cancellationToken);
        } catch (e) {
          if (!isNotFoundError(e))
            throw e;
        }
      } else {
        const { upperChunkBound } = this.spec;
        const { chunkGridPosition: chunkGridPosition2 } = chunk;
        const chunkIndex = encodeZIndexCompressed(new Uint64(), chunkGridPosition2, upperChunkBound);
        const result = await getShardedData(minishardIndexSource, chunk, chunkIndex, cancellationToken);
        if (result !== void 0)
          response = result.data;
      }
      if (response !== void 0) {
        chunk.data = parseAnnotations2(response, parent.parameters, parent.annotationPropertySerializer);
      }
    }
  };
  PrecomputedAnnotationSpatialIndexSourceBackend = __decorateClass([
    registerSharedObject()
  ], PrecomputedAnnotationSpatialIndexSourceBackend);
  var PrecomputedAnnotationSourceBackend = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(AnnotationSource2), AnnotationSourceParameters2) {
    constructor() {
      super(...arguments);
      this.byIdMinishardIndexSource = getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, this.parameters.byId);
      this.relationshipIndexSource = this.parameters.relationships.map((x) => getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, x));
      this.annotationPropertySerializer = new AnnotationPropertySerializer(this.parameters.rank, annotationTypeHandlers[this.parameters.type].serializedBytes(this.parameters.rank), this.parameters.properties);
    }
    async downloadSegmentFilteredGeometry(chunk, relationshipIndex, cancellationToken) {
      const { parameters } = this;
      const response = await fetchByUint64(this.credentialsProvider, parameters.relationships[relationshipIndex].url, chunk, this.relationshipIndexSource[relationshipIndex], chunk.objectId, cancellationToken);
      if (response !== void 0) {
        chunk.data = parseAnnotations2(response, this.parameters, this.annotationPropertySerializer);
      }
    }
    async downloadMetadata(chunk, cancellationToken) {
      const { parameters } = this;
      const id = Uint64.parseString(chunk.key);
      const response = await fetchByUint64(this.credentialsProvider, parameters.byId.url, chunk, this.byIdMinishardIndexSource, id, cancellationToken);
      if (response === void 0) {
        chunk.annotation = null;
      } else {
        chunk.annotation = parseSingleAnnotation(response, this.parameters, this.annotationPropertySerializer, chunk.key);
      }
    }
  };
  PrecomputedAnnotationSourceBackend = __decorateClass([
    registerSharedObject()
  ], PrecomputedAnnotationSourceBackend);
  var PrecomputedIndexedSegmentPropertySourceBackend = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(IndexedSegmentPropertySourceBackend), IndexedSegmentPropertySourceParameters) {
    constructor() {
      super(...arguments);
      this.minishardIndexSource = getMinishardIndexDataSource(this.chunkManager, this.credentialsProvider, this.parameters);
    }
  };
  PrecomputedIndexedSegmentPropertySourceBackend = __decorateClass([
    registerSharedObject()
  ], PrecomputedIndexedSegmentPropertySourceBackend);

  // src/neuroglancer/datasource/nifti/base.ts
  var GET_NIFTI_VOLUME_INFO_RPC_ID = "nifti/getNiftiVolumeInfo";
  var VolumeSourceParameters2 = class {
  };
  VolumeSourceParameters2.RPC_ID = "nifti/VolumeChunkSource";

  // src/neuroglancer/sliceview/volume/base.ts
  var VolumeType;
  (function(VolumeType2) {
    VolumeType2[VolumeType2["UNKNOWN"] = 0] = "UNKNOWN";
    VolumeType2[VolumeType2["IMAGE"] = 1] = "IMAGE";
    VolumeType2[VolumeType2["SEGMENTATION"] = 2] = "SEGMENTATION";
  })(VolumeType || (VolumeType = {}));

  // src/neuroglancer/datasource/nifti/backend.ts
  var import_nifti_reader_js = __toModule(require_nifti());
  var NiftiFileData = class {
  };
  async function decodeNiftiFile(buffer, cancellationToken) {
    if ((0, import_nifti_reader_js.isCompressed)(buffer)) {
      buffer = (await requestAsyncComputation(decodeGzip, cancellationToken, [buffer], new Uint8Array(buffer))).buffer;
    }
    let data = new NiftiFileData();
    data.uncompressedData = buffer;
    let header = (0, import_nifti_reader_js.readHeader)(buffer);
    if (header === null) {
      throw new Error("Failed to parse NIFTI header.");
    }
    data.header = header;
    return { data, size: buffer.byteLength };
  }
  function getNiftiFileData(chunkManager, credentialsProvider, url, getPriority, cancellationToken) {
    return GenericSharedDataSource.getUrl(chunkManager, credentialsProvider, decodeNiftiFile, url, getPriority, cancellationToken);
  }
  var NIFTI_HEADER_INFO_PRIORITY = 1e3;
  async function getNiftiHeaderInfo(chunkManager, credentialsProvider, url, cancellationToken) {
    const data = await getNiftiFileData(chunkManager, credentialsProvider, url, () => ({ priorityTier: ChunkPriorityTier.VISIBLE, priority: NIFTI_HEADER_INFO_PRIORITY }), cancellationToken);
    return data.header;
  }
  function convertAffine(affine) {
    return mat4_exports.fromValues(affine[0][0], affine[1][0], affine[2][0], affine[3][0], affine[0][1], affine[1][1], affine[2][1], affine[3][1], affine[0][2], affine[1][2], affine[2][2], affine[3][2], affine[0][3], affine[1][3], affine[2][3], affine[3][3]);
  }
  var NiftiDataType;
  (function(NiftiDataType2) {
    NiftiDataType2[NiftiDataType2["NONE"] = 0] = "NONE";
    NiftiDataType2[NiftiDataType2["BINARY"] = 1] = "BINARY";
    NiftiDataType2[NiftiDataType2["UINT8"] = 2] = "UINT8";
    NiftiDataType2[NiftiDataType2["INT16"] = 4] = "INT16";
    NiftiDataType2[NiftiDataType2["INT32"] = 8] = "INT32";
    NiftiDataType2[NiftiDataType2["FLOAT32"] = 16] = "FLOAT32";
    NiftiDataType2[NiftiDataType2["COMPLEX64"] = 32] = "COMPLEX64";
    NiftiDataType2[NiftiDataType2["FLOAT64"] = 64] = "FLOAT64";
    NiftiDataType2[NiftiDataType2["RGB24"] = 128] = "RGB24";
    NiftiDataType2[NiftiDataType2["INT8"] = 256] = "INT8";
    NiftiDataType2[NiftiDataType2["UINT16"] = 512] = "UINT16";
    NiftiDataType2[NiftiDataType2["UINT32"] = 768] = "UINT32";
    NiftiDataType2[NiftiDataType2["INT64"] = 1024] = "INT64";
    NiftiDataType2[NiftiDataType2["UINT64"] = 1280] = "UINT64";
    NiftiDataType2[NiftiDataType2["FLOAT128"] = 1536] = "FLOAT128";
    NiftiDataType2[NiftiDataType2["COMPLEX128"] = 1792] = "COMPLEX128";
    NiftiDataType2[NiftiDataType2["COMPLEX256"] = 2048] = "COMPLEX256";
  })(NiftiDataType || (NiftiDataType = {}));
  var DATA_TYPE_CONVERSIONS = new Map([
    [256, { dataType: DataType.INT8 }],
    [2, { dataType: DataType.UINT8 }],
    [4, { dataType: DataType.INT16 }],
    [512, { dataType: DataType.UINT16 }],
    [8, { dataType: DataType.INT32 }],
    [768, { dataType: DataType.UINT32 }],
    [1024, { dataType: DataType.UINT64 }],
    [1280, { dataType: DataType.UINT64 }],
    [16, { dataType: DataType.FLOAT32 }]
  ]);
  registerPromiseRPC(GET_NIFTI_VOLUME_INFO_RPC_ID, async function(x, cancellationToken) {
    const chunkManager = this.getRef(x["chunkManager"]);
    const credentialsProvider = this.getOptionalRef(x["credentialsProvider"]);
    try {
      const header = await getNiftiHeaderInfo(chunkManager, credentialsProvider, x["url"], cancellationToken);
      let dataTypeInfo = DATA_TYPE_CONVERSIONS.get(header.datatypeCode);
      if (dataTypeInfo === void 0) {
        throw new Error(`Unsupported data type: ${NiftiDataType[header.datatypeCode] || header.datatypeCode}.`);
      }
      let spatialInvScale = 1;
      let spatialUnit = "";
      switch (header.xyzt_units & import_nifti_reader_js.NIFTI1.SPATIAL_UNITS_MASK) {
        case import_nifti_reader_js.NIFTI1.UNITS_METER:
          spatialInvScale = 1;
          spatialUnit = "m";
          break;
        case import_nifti_reader_js.NIFTI1.UNITS_MM:
          spatialInvScale = 1e3;
          spatialUnit = "m";
          break;
        case import_nifti_reader_js.NIFTI1.UNITS_MICRON:
          spatialInvScale = 1e6;
          spatialUnit = "m";
          break;
      }
      let timeUnit = "";
      let timeInvScale = 1;
      switch (header.xyzt_units & import_nifti_reader_js.NIFTI1.TEMPORAL_UNITS_MASK) {
        case import_nifti_reader_js.NIFTI1.UNITS_SEC:
          timeUnit = "s";
          timeInvScale = 1;
          break;
        case import_nifti_reader_js.NIFTI1.UNITS_MSEC:
          timeUnit = "s";
          timeInvScale = 1e3;
          break;
        case import_nifti_reader_js.NIFTI1.UNITS_USEC:
          timeUnit = "s";
          timeInvScale = 1e6;
          break;
        case import_nifti_reader_js.NIFTI1.UNITS_HZ:
          timeUnit = "Hz";
          timeInvScale = 1;
          break;
        case import_nifti_reader_js.NIFTI1.UNITS_RADS:
          timeUnit = "rad/s";
          timeInvScale = 1;
          break;
      }
      let units = [spatialUnit, spatialUnit, spatialUnit, timeUnit, "", "", ""];
      let sourceScales = Float64Array.of(header.pixDims[1] / spatialInvScale, header.pixDims[2] / spatialInvScale, header.pixDims[3] / spatialInvScale, header.pixDims[4] / timeInvScale, header.pixDims[5], header.pixDims[6], header.pixDims[7]);
      let viewScales = Float64Array.of(1 / spatialInvScale, 1 / spatialInvScale, 1 / spatialInvScale, 1 / timeInvScale, 1, 1, 1);
      let sourceNames = ["i", "j", "k", "m", "c^", "c1^", "c2^"];
      let viewNames = ["x", "y", "z", "t", "c^", "c1^", "c2^"];
      const rank = header.dims[0];
      sourceNames = sourceNames.slice(0, rank);
      viewNames = viewNames.slice(0, rank);
      units = units.slice(0, rank);
      sourceScales = sourceScales.slice(0, rank);
      viewScales = viewScales.slice(0, rank);
      const { quatern_b, quatern_c, quatern_d } = header;
      const quatern_a = Math.sqrt(1 - quatern_b * quatern_b - quatern_c * quatern_c - quatern_d * quatern_d);
      const qfac = header.pixDims[0] === -1 ? -1 : 1;
      const qoffset = vec3_exports.fromValues(header.qoffset_x, header.qoffset_y, header.qoffset_z);
      const method3Transform = convertAffine(header.affine);
      method3Transform;
      const method2Transform = translationRotationScaleZReflectionToMat4(mat4_exports.create(), qoffset, quat_exports.fromValues(quatern_b, quatern_c, quatern_d, quatern_a), kOneVec, qfac);
      const transform = createIdentity(Float64Array, rank + 1);
      const copyRank = Math.min(3, rank);
      for (let row = 0; row < copyRank; ++row) {
        for (let col = 0; col < copyRank; ++col) {
          transform[col * (rank + 1) + row] = method2Transform[col * 4 + row];
        }
        transform[rank * (rank + 1) + row] = method2Transform[12 + row];
      }
      let info = {
        rank,
        sourceNames,
        viewNames,
        units,
        sourceScales,
        viewScales,
        description: header.description,
        transform,
        dataType: dataTypeInfo.dataType,
        volumeSize: Uint32Array.from(header.dims.slice(1, 1 + rank))
      };
      return { value: info };
    } finally {
      chunkManager.dispose();
      credentialsProvider == null ? void 0 : credentialsProvider.dispose();
    }
  });
  var NiftiVolumeChunkSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(VolumeChunkSource), VolumeSourceParameters2) {
    async download(chunk, cancellationToken) {
      chunk.chunkDataSize = this.spec.chunkDataSize;
      const data = await getNiftiFileData(this.chunkManager, this.credentialsProvider, this.parameters.url, () => ({ priorityTier: chunk.priorityTier, priority: chunk.priority }), cancellationToken);
      const imageBuffer = (0, import_nifti_reader_js.readImage)(data.header, data.uncompressedData);
      await decodeRawChunk(chunk, cancellationToken, imageBuffer, data.header.littleEndian ? Endianness.LITTLE : Endianness.BIG);
    }
  };
  NiftiVolumeChunkSource = __decorateClass([
    registerSharedObject()
  ], NiftiVolumeChunkSource);

  // src/neuroglancer/async_computation/decode_blosc_request.ts
  var decodeBlosc = asyncComputation("decodeBlosc");

  // src/neuroglancer/datasource/n5/base.ts
  var VolumeChunkEncoding4;
  (function(VolumeChunkEncoding6) {
    VolumeChunkEncoding6[VolumeChunkEncoding6["RAW"] = 0] = "RAW";
    VolumeChunkEncoding6[VolumeChunkEncoding6["GZIP"] = 1] = "GZIP";
    VolumeChunkEncoding6[VolumeChunkEncoding6["BLOSC"] = 2] = "BLOSC";
  })(VolumeChunkEncoding4 || (VolumeChunkEncoding4 = {}));
  var VolumeChunkSourceParameters4 = class {
  };
  VolumeChunkSourceParameters4.RPC_ID = "n5/VolumeChunkSource";

  // src/neuroglancer/datasource/n5/backend.ts
  async function decodeChunk(chunk, cancellationToken, response, encoding) {
    const dv = new DataView(response);
    const mode = dv.getUint16(0, false);
    if (mode !== 0) {
      throw new Error(`Unsupported mode: ${mode}.`);
    }
    const numDimensions = dv.getUint16(2, false);
    if (numDimensions !== chunk.source.spec.rank) {
      throw new Error(`Number of dimensions must be 3.`);
    }
    let offset = 4;
    const shape = new Uint32Array(numDimensions);
    for (let i = 0; i < numDimensions; ++i) {
      shape[i] = dv.getUint32(offset, false);
      offset += 4;
    }
    chunk.chunkDataSize = shape;
    let buffer = new Uint8Array(response, offset);
    switch (encoding) {
      case VolumeChunkEncoding4.GZIP:
        buffer = await requestAsyncComputation(decodeGzip, cancellationToken, [buffer.buffer], buffer);
        break;
      case VolumeChunkEncoding4.BLOSC:
        buffer = await requestAsyncComputation(decodeBlosc, cancellationToken, [buffer.buffer], buffer);
        break;
    }
    await decodeRawChunk(chunk, cancellationToken, buffer.buffer, Endianness.BIG, buffer.byteOffset, buffer.byteLength);
  }
  var PrecomputedVolumeChunkSource2 = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(VolumeChunkSource), VolumeChunkSourceParameters4) {
    async download(chunk, cancellationToken) {
      const { parameters } = this;
      const { chunkGridPosition } = chunk;
      let url = parameters.url;
      const rank = this.spec.rank;
      for (let i = 0; i < rank; ++i) {
        url += `/${chunkGridPosition[i]}`;
      }
      try {
        const response = await cancellableFetchSpecialOk(this.credentialsProvider, url, {}, responseArrayBuffer, cancellationToken);
        await decodeChunk(chunk, cancellationToken, response, parameters.encoding);
      } catch (e) {
        if (!isNotFoundError(e))
          throw e;
      }
    }
  };
  PrecomputedVolumeChunkSource2 = __decorateClass([
    registerSharedObject()
  ], PrecomputedVolumeChunkSource2);

  // src/neuroglancer/datasource/zarr/base.ts
  var ZarrCompressor;
  (function(ZarrCompressor2) {
    ZarrCompressor2[ZarrCompressor2["RAW"] = 0] = "RAW";
    ZarrCompressor2[ZarrCompressor2["GZIP"] = 1] = "GZIP";
    ZarrCompressor2[ZarrCompressor2["BLOSC"] = 2] = "BLOSC";
  })(ZarrCompressor || (ZarrCompressor = {}));
  var VolumeChunkSourceParameters5 = class {
  };
  VolumeChunkSourceParameters5.RPC_ID = "zarr/VolumeChunkSource";

  // src/neuroglancer/datasource/zarr/backend.ts
  async function decodeChunk2(chunk, cancellationToken, response, encoding) {
    let buffer = new Uint8Array(response);
    switch (encoding.compressor) {
      case ZarrCompressor.GZIP:
        buffer = await requestAsyncComputation(decodeGzip, cancellationToken, [buffer.buffer], buffer);
        break;
      case ZarrCompressor.RAW:
        break;
      case ZarrCompressor.BLOSC:
        buffer = await requestAsyncComputation(decodeBlosc, cancellationToken, [buffer.buffer], buffer);
    }
    await decodeRawChunk(chunk, cancellationToken, buffer.buffer, encoding.endianness);
  }
  var PrecomputedVolumeChunkSource3 = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(VolumeChunkSource), VolumeChunkSourceParameters5) {
    async download(chunk, cancellationToken) {
      chunk.chunkDataSize = this.spec.chunkDataSize;
      const { parameters } = this;
      const { chunkGridPosition } = chunk;
      let { url, separator, order } = parameters;
      const rank = this.spec.rank;
      if (order === "C") {
        for (let i = rank; i > 0; --i) {
          url += `${i == rank ? "/" : separator}${chunkGridPosition[i - 1]}`;
        }
      } else {
        for (let i = 0; i < rank; ++i) {
          url += `${i == 0 ? "/" : separator}${chunkGridPosition[i]}`;
        }
      }
      try {
        const response = await cancellableFetchSpecialOk(this.credentialsProvider, url, {}, responseArrayBuffer, cancellationToken);
        await decodeChunk2(chunk, cancellationToken, response, parameters.encoding);
      } catch (e) {
        if (!isNotFoundError(e))
          throw e;
      }
    }
  };
  PrecomputedVolumeChunkSource3 = __decorateClass([
    registerSharedObject()
  ], PrecomputedVolumeChunkSource3);

  // src/neuroglancer/async_computation/vtk_mesh_request.ts
  var parseVTKFromArrayBuffer = asyncComputation("parseVTKFromArrayBuffer");

  // src/neuroglancer/single_mesh/base.ts
  var SINGLE_MESH_LAYER_RPC_ID = "single_mesh/SingleMeshLayer";
  var GET_SINGLE_MESH_INFO_RPC_ID = "single_mesh/getSingleMeshInfo";
  var SINGLE_MESH_CHUNK_KEY = "";
  var SingleMeshSourceParameters = class {
  };
  var SingleMeshSourceParametersWithInfo = class extends SingleMeshSourceParameters {
  };
  SingleMeshSourceParametersWithInfo.RPC_ID = "single_mesh/SingleMeshSource";

  // src/neuroglancer/single_mesh/backend.ts
  var SINGLE_MESH_CHUNK_PRIORITY = 50;
  var SingleMeshChunk = class extends Chunk {
    constructor() {
      super();
      this.data = null;
    }
    freeSystemMemory() {
      this.data = null;
    }
    serialize(msg, transfers) {
      super.serialize(msg, transfers);
      let { vertexPositions, indices, vertexNormals, vertexAttributes } = this.data;
      msg["vertexPositions"] = vertexPositions;
      msg["indices"] = indices;
      msg["vertexNormals"] = vertexNormals;
      msg["vertexAttributes"] = vertexAttributes;
      const transferSet = new Set();
      transferSet.add(vertexPositions.buffer);
      transferSet.add(indices.buffer);
      transferSet.add(vertexNormals.buffer);
      for (const data of vertexAttributes) {
        transferSet.add(data.buffer);
      }
      transfers.push(...transferSet);
      this.data = null;
    }
    downloadSucceeded() {
      let { vertexPositions, indices, vertexNormals, vertexAttributes } = this.data;
      let totalBytes = this.gpuMemoryBytes = vertexPositions.byteLength + indices.byteLength + vertexNormals.byteLength;
      for (const data of vertexAttributes) {
        totalBytes += data.byteLength;
      }
      this.systemMemoryBytes = this.gpuMemoryBytes = totalBytes;
      super.downloadSucceeded();
    }
  };
  var singleMeshFactories = new Map();
  function registerSingleMeshFactory(name, factory) {
    singleMeshFactories.set(name, factory);
  }
  var protocolPattern = /^(?:([a-zA-Z-+_]+):\/\/)?(.*)$/;
  function getDataSource(factories, url) {
    let m = url.match(protocolPattern);
    if (m === null || m[1] === void 0) {
      throw new Error(`Data source URL must have the form "<protocol>://<path>".`);
    }
    let dataSource = m[1];
    let factory = factories.get(dataSource);
    if (factory === void 0) {
      throw new Error(`Unsupported data source: ${JSON.stringify(dataSource)}.`);
    }
    return [factory, m[2], dataSource];
  }
  function getMesh(chunkManager, credentialsProvider, url, getPriority, cancellationToken) {
    let [factory, path] = getDataSource(singleMeshFactories, url);
    return factory.getMesh(chunkManager, credentialsProvider, path, getPriority, cancellationToken);
  }
  function getCombinedMesh(chunkManager, credentialsProvider, parameters, getPriority, cancellationToken) {
    return getMesh(chunkManager, credentialsProvider, parameters.meshSourceUrl, getPriority, cancellationToken);
  }
  var SingleMeshSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(ChunkSource), SingleMeshSourceParametersWithInfo) {
    getChunk() {
      const key = SINGLE_MESH_CHUNK_KEY;
      let chunk = this.chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(SingleMeshChunk);
        chunk.initialize(key);
        this.addChunk(chunk);
      }
      return chunk;
    }
    download(chunk, cancellationToken) {
      const getPriority = () => ({ priorityTier: chunk.priorityTier, priority: chunk.priority });
      return getCombinedMesh(this.chunkManager, this.credentialsProvider, this.parameters, getPriority, cancellationToken).then((data) => {
        if (stableStringify(data.info) !== stableStringify(this.parameters.info)) {
          throw new Error(`Mesh info has changed.`);
        }
        if (data.vertexNormals === void 0) {
          data.vertexNormals = computeVertexNormals(data.vertexPositions, data.indices);
        }
        chunk.data = data;
      });
    }
  };
  SingleMeshSource = __decorateClass([
    registerSharedObject()
  ], SingleMeshSource);
  var SingleMeshLayerBase = withSharedVisibility(withChunkManager(SharedObjectCounterpart));
  var SingleMeshLayer = class extends SingleMeshLayerBase {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.source = this.registerDisposer(rpc2.getRef(options["source"]));
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
        this.updateChunkPriorities();
      }));
    }
    updateChunkPriorities() {
      const visibility = this.visibility.value;
      if (visibility === Number.NEGATIVE_INFINITY) {
        return;
      }
      const priorityTier = getPriorityTier(visibility);
      const basePriority = getBasePriority(visibility);
      const { source, chunkManager } = this;
      const chunk = source.getChunk();
      chunkManager.requestChunk(chunk, priorityTier, basePriority + SINGLE_MESH_CHUNK_PRIORITY);
    }
  };
  SingleMeshLayer = __decorateClass([
    registerSharedObject(SINGLE_MESH_LAYER_RPC_ID)
  ], SingleMeshLayer);
  var INFO_PRIORITY = 1e3;
  registerPromiseRPC(GET_SINGLE_MESH_INFO_RPC_ID, async function(x, cancellationToken) {
    const chunkManager = this.getRef(x["chunkManager"]);
    const credentialsProvider = this.getOptionalRef(x["credentialsProvider"]);
    try {
      let parameters = x["parameters"];
      const mesh = await getCombinedMesh(chunkManager, credentialsProvider, parameters, () => ({ priorityTier: ChunkPriorityTier.VISIBLE, priority: INFO_PRIORITY }), cancellationToken);
      return { value: mesh.info };
    } finally {
      chunkManager.dispose();
      credentialsProvider == null ? void 0 : credentialsProvider.dispose();
    }
  });

  // src/neuroglancer/datasource/vtk/backend.ts
  function parse(buffer, cancellationToken) {
    return requestAsyncComputation(parseVTKFromArrayBuffer, cancellationToken, [buffer], buffer);
  }
  registerSingleMeshFactory("vtk", {
    description: "VTK",
    getMesh: (chunkManager, credentialsProvider, url, getPriority, cancellationToken) => GenericSharedDataSource.getUrl(chunkManager, credentialsProvider, parse, url, getPriority, cancellationToken).then((mesh) => {
      let result = {
        info: {
          numTriangles: mesh.numTriangles,
          numVertices: mesh.numVertices,
          vertexAttributes: []
        },
        indices: mesh.indices,
        vertexPositions: mesh.vertexPositions,
        vertexAttributes: []
      };
      for (const attribute of mesh.vertexAttributes) {
        result.info.vertexAttributes.push({
          name: attribute.name,
          dataType: DataType.FLOAT32,
          numComponents: attribute.numComponents
        });
        result.vertexAttributes.push(attribute.data);
      }
      return result;
    })
  });

  // src/neuroglancer/async_computation/obj_mesh_request.ts
  var parseOBJFromArrayBuffer = asyncComputation("parseOBJFromArrayBuffer");

  // src/neuroglancer/datasource/obj/backend.ts
  function parse2(buffer, cancellationToken) {
    return requestAsyncComputation(parseOBJFromArrayBuffer, cancellationToken, [buffer], buffer);
  }
  registerSingleMeshFactory("obj", {
    description: "OBJ",
    getMesh: (chunkManager, credentialsProvider, url, getPriority, cancellationToken) => GenericSharedDataSource.getUrl(chunkManager, credentialsProvider, parse2, url, getPriority, cancellationToken)
  });

  // src/neuroglancer/datasource/graphene/base.ts
  var VolumeChunkEncoding5;
  (function(VolumeChunkEncoding6) {
    VolumeChunkEncoding6[VolumeChunkEncoding6["RAW"] = 0] = "RAW";
    VolumeChunkEncoding6[VolumeChunkEncoding6["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding6[VolumeChunkEncoding6["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
  })(VolumeChunkEncoding5 || (VolumeChunkEncoding5 = {}));
  var VolumeChunkSourceParameters6 = class {
  };
  VolumeChunkSourceParameters6.RPC_ID = "graphene/VolumeChunkSource";
  var ChunkedGraphSourceParameters = class {
  };
  ChunkedGraphSourceParameters.RPC_ID = "graphene/ChunkedGraphSource";
  var MeshSourceParameters5 = class {
  };
  MeshSourceParameters5.RPC_ID = "graphene/MeshSource";
  var responseIdentity = async (x) => x;
  function isBaseSegmentId(segmentId, nBitsForLayerId) {
    const layerId = Uint64.rshift(new Uint64(), segmentId, 64 - nBitsForLayerId);
    return Uint64.equal(layerId, Uint64.ONE);
  }
  function getGrapheneFragmentKey(fragmentId) {
    const sharded = fragmentId.charAt(0) === "~";
    if (sharded) {
      const parts = fragmentId.substring(1).split(/:(.+)/);
      return { key: parts[0], fragmentId: parts[1] };
    } else {
      return { key: fragmentId, fragmentId };
    }
  }
  var CHUNKED_GRAPH_LAYER_RPC_ID = "ChunkedGraphLayer";
  var CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID = "ChunkedGraphLayer:updateSources";
  var RENDER_RATIO_LIMIT = 5;

  // src/neuroglancer/datasource/graphene/backend.ts
  var import_debounce2 = __toModule(require_debounce());
  function getVerifiedFragmentPromise(credentialsProvider, chunk, parameters, cancellationToken) {
    if (chunk.fragmentId && chunk.fragmentId.charAt(0) === "~") {
      let parts = chunk.fragmentId.substr(1).split(":");
      let startOffset, endOffset;
      startOffset = Number(parts[1]);
      endOffset = startOffset + Number(parts[2]);
      return fetchSpecialHttpByteRange(credentialsProvider, `${parameters.fragmentUrl}/initial/${parts[0]}`, startOffset, endOffset, cancellationToken);
    }
    return cancellableFetchSpecialOk(credentialsProvider, `${parameters.fragmentUrl}/dynamic/${chunk.fragmentId}`, {}, responseArrayBuffer, cancellationToken);
  }
  function getFragmentDownloadPromise(credentialsProvider, chunk, parameters, cancellationToken) {
    let fragmentDownloadPromise;
    if (parameters.sharding) {
      fragmentDownloadPromise = getVerifiedFragmentPromise(credentialsProvider, chunk, parameters, cancellationToken);
    } else {
      fragmentDownloadPromise = cancellableFetchSpecialOk(credentialsProvider, `${parameters.fragmentUrl}/${chunk.fragmentId}`, {}, responseArrayBuffer, cancellationToken);
    }
    return fragmentDownloadPromise;
  }
  async function decodeDracoFragmentChunk(chunk, response) {
    const m = await Promise.resolve().then(() => (init_draco(), draco_exports));
    const rawMesh = await m.decodeDraco(new Uint8Array(response));
    assignMeshFragmentData(chunk, rawMesh);
  }
  var GrapheneMeshSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(MeshSource), MeshSourceParameters5) {
    async download(chunk, cancellationToken) {
      const { parameters } = this;
      if (isBaseSegmentId(chunk.objectId, parameters.nBitsForLayerId)) {
        return decodeManifestChunk2(chunk, { fragments: [] });
      }
      let url = `${parameters.manifestUrl}/manifest`;
      let manifestUrl = `${url}/${chunk.objectId}:${parameters.lod}?verify=1&prepend_seg_ids=1`;
      await cancellableFetchSpecialOk(this.credentialsProvider, manifestUrl, {}, responseJson, cancellationToken).then((response) => decodeManifestChunk2(chunk, response));
    }
    async downloadFragment(chunk, cancellationToken) {
      const { parameters } = this;
      try {
        const response = await getFragmentDownloadPromise(void 0, chunk, parameters, cancellationToken);
        await decodeDracoFragmentChunk(chunk, response);
      } catch (e) {
        if (isNotFoundError(e)) {
          chunk.source.removeChunk(chunk);
        }
        Promise.reject(e);
      }
    }
    getFragmentKey(objectKey, fragmentId) {
      objectKey;
      return getGrapheneFragmentKey(fragmentId);
    }
  };
  GrapheneMeshSource = __decorateClass([
    registerSharedObject()
  ], GrapheneMeshSource);
  var ChunkedGraphChunk = class extends Chunk {
    constructor() {
      super(...arguments);
      this.backendOnly = true;
      this.source = null;
      this.leaves = [];
    }
    initializeVolumeChunk(key, chunkGridPosition) {
      super.initialize(key);
      this.chunkGridPosition = Float32Array.from(chunkGridPosition);
    }
    initializeChunkedGraphChunk(key, chunkGridPosition, segment) {
      this.initializeVolumeChunk(key, chunkGridPosition);
      this.chunkDataSize = null;
      this.systemMemoryBytes = 16;
      this.gpuMemoryBytes = 0;
      this.segment = segment;
    }
    downloadSucceeded() {
      this.systemMemoryBytes = 16;
      this.systemMemoryBytes += 16 * this.leaves.length;
      this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);
      if (this.priorityTier < ChunkPriorityTier.RECENT) {
        this.source.chunkManager.scheduleUpdateChunkPriorities();
      }
      super.downloadSucceeded();
    }
    freeSystemMemory() {
      this.leaves = [];
    }
  };
  function decodeChunkedGraphChunk(leaves) {
    const final = new Array(leaves.length);
    for (let i = 0; i < final.length; ++i) {
      final[i] = Uint64.parseString(leaves[i]);
    }
    return final;
  }
  var GrapheneChunkedGraphChunkSource = class extends WithParameters(WithSharedCredentialsProviderCounterpart()(ChunkSource), ChunkedGraphSourceParameters) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.spec = options.spec;
      const rank = this.spec.rank;
      this.tempChunkDataSize = new Uint32Array(rank);
      this.tempChunkPosition = new Float32Array(rank);
    }
    async download(chunk, cancellationToken) {
      let { parameters } = this;
      let chunkPosition = this.computeChunkBounds(chunk);
      let chunkDataSize = chunk.chunkDataSize;
      let bounds = `${chunkPosition[0]}-${chunkPosition[0] + chunkDataSize[0]}_${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;
      const request = cancellableFetchSpecialOk(this.credentialsProvider, `${parameters.url}/${chunk.segment}/leaves?int64_as_str=1&bounds=${bounds}`, {}, responseIdentity, cancellationToken);
      await this.withErrorMessage(request, `Fetching leaves of segment ${chunk.segment} in region ${bounds}: `).then((res) => res.json()).then((res) => {
        chunk.leaves = decodeChunkedGraphChunk(res["leaf_ids"]);
      }).catch((err) => console.error(err));
    }
    getChunk(chunkGridPosition, segment) {
      const key = `${vec3Key(chunkGridPosition)}-${segment}`;
      let chunk = this.chunks.get(key);
      if (chunk === void 0) {
        chunk = this.getNewChunk_(ChunkedGraphChunk);
        chunk.initializeChunkedGraphChunk(key, chunkGridPosition, segment);
        this.addChunk(chunk);
      }
      return chunk;
    }
    computeChunkBounds(chunk) {
      return computeChunkBounds(this, chunk);
    }
    async withErrorMessage(promise, errorPrefix) {
      const response = await promise;
      if (response.ok) {
        return response;
      } else {
        let msg;
        try {
          msg = (await response.json())["message"];
        } catch {
          msg = await response.text();
        }
        throw new Error(`[${response.status}] ${errorPrefix}${msg}`);
      }
    }
  };
  GrapheneChunkedGraphChunkSource = __decorateClass([
    registerSharedObject()
  ], GrapheneChunkedGraphChunkSource);
  var tempChunkPosition3 = vec3_exports.create();
  var tempCenter3 = vec3_exports.create();
  var tempChunkSize3 = vec3_exports.create();
  var ChunkedGraphLayer = class extends withSegmentationLayerBackendState(withSharedVisibility(withChunkManager(RenderLayerBackend))) {
    constructor(rpc2, options) {
      super(rpc2, options);
      this.debouncedupdateDisplayState = (0, import_debounce2.default)(() => {
        this.updateDisplayState();
      }, 100);
      this.source = this.registerDisposer(rpc2.getRef(options["source"]));
      this.localPosition = rpc2.get(options.localPosition);
      this.leafRequestsActive = rpc2.get(options.leafRequestsActive);
      this.nBitsForLayerId = rpc2.get(options.nBitsForLayerId);
      this.registerDisposer(this.chunkManager.recomputeChunkPriorities.add(() => {
        this.updateChunkPriorities();
        this.debouncedupdateDisplayState();
      }));
    }
    attach(attachment) {
      const scheduleUpdateChunkPriorities = () => this.chunkManager.scheduleUpdateChunkPriorities();
      const { view } = attachment;
      attachment.registerDisposer(scheduleUpdateChunkPriorities);
      attachment.registerDisposer(view.projectionParameters.changed.add(scheduleUpdateChunkPriorities));
      attachment.registerDisposer(view.visibility.changed.add(scheduleUpdateChunkPriorities));
      attachment.state = {
        displayDimensionRenderInfo: view.projectionParameters.value.displayDimensionRenderInfo
      };
    }
    get renderRatioLimit() {
      return RENDER_RATIO_LIMIT;
    }
    updateChunkPriorities() {
      const { source, chunkManager } = this;
      chunkManager.registerLayer(this);
      for (const attachment of this.attachments.values()) {
        const { view } = attachment;
        const visibility = view.visibility.value;
        if (visibility === Number.NEGATIVE_INFINITY) {
          continue;
        }
        const attachmentState = attachment.state;
        const { transformedSource: tsource } = attachmentState;
        const projectionParameters = view.projectionParameters.value;
        if (!tsource) {
          continue;
        }
        const pixelSize = projectionParameters.pixelSize * 1.1;
        const smallestVoxelSize = tsource.effectiveVoxelSize;
        this.leafRequestsActive.value = this.renderRatioLimit >= pixelSize / Math.min(...smallestVoxelSize);
        if (!this.leafRequestsActive.value) {
          continue;
        }
        const priorityTier = getPriorityTier(visibility);
        const basePriority = getBasePriority(visibility);
        const { chunkLayout } = tsource;
        const { size, finiteRank } = chunkLayout;
        const chunkSize = tempChunkSize3;
        const localCenter = tempCenter3;
        vec3_exports.copy(chunkSize, size);
        for (let i = finiteRank; i < 3; ++i) {
          chunkSize[i] = 0;
          localCenter[i] = 0;
        }
        const { centerDataPosition } = projectionParameters;
        chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);
        forEachPlaneIntersectingVolumetricChunk(projectionParameters, this.localPosition.value, tsource, getNormalizedChunkLayout(projectionParameters, chunkLayout), (positionInChunks) => {
          vec3_exports.multiply(tempChunkPosition3, positionInChunks, chunkSize);
          const priority = -vec3_exports.distance(localCenter, tempChunkPosition3);
          const { curPositionInChunks } = tsource;
          forEachVisibleSegment(this, (segment, _) => {
            if (isBaseSegmentId(segment, this.nBitsForLayerId.value))
              return;
            const chunk = source.getChunk(curPositionInChunks, segment.clone());
            chunkManager.requestChunk(chunk, priorityTier, basePriority + priority);
            ++this.numVisibleChunksNeeded;
            if (chunk.state === ChunkState.GPU_MEMORY) {
              ++this.numVisibleChunksAvailable;
            }
          });
        });
      }
    }
    forEachSelectedRootWithLeaves(callback) {
      const { source } = this;
      for (const chunk of source.chunks.values()) {
        if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER && chunk.priorityTier < ChunkPriorityTier.RECENT) {
          if (this.visibleSegments.has(chunk.segment) && chunk.leaves.length) {
            callback(chunk.segment.toString(), chunk.leaves);
          }
        }
      }
    }
    updateDisplayState() {
      const visibleLeaves = new Map();
      const capacities = new Map();
      this.forEachSelectedRootWithLeaves((rootObjectKey, leaves) => {
        if (!capacities.has(rootObjectKey)) {
          capacities.set(rootObjectKey, leaves.length);
        } else {
          capacities.set(rootObjectKey, capacities.get(rootObjectKey) + leaves.length);
        }
      });
      this.forEachSelectedRootWithLeaves((rootObjectKey, leaves) => {
        if (!visibleLeaves.has(rootObjectKey)) {
          visibleLeaves.set(rootObjectKey, new Uint64Set());
          visibleLeaves.get(rootObjectKey).reserve(capacities.get(rootObjectKey));
          visibleLeaves.get(rootObjectKey).add(Uint64.parseString(rootObjectKey));
        }
        visibleLeaves.get(rootObjectKey).add(leaves);
      });
      for (const [root, leaves] of visibleLeaves) {
        const filteredLeaves = [...leaves].filter((x) => !this.segmentEquivalences.has(x));
        const rootInt = Uint64.parseString(root);
        for (const leaf of filteredLeaves) {
          this.segmentEquivalences.link(rootInt, leaf);
        }
      }
    }
  };
  ChunkedGraphLayer = __decorateClass([
    registerSharedObject(CHUNKED_GRAPH_LAYER_RPC_ID)
  ], ChunkedGraphLayer);
  registerRPC(CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function(x) {
    const view = this.get(x.view);
    const layer = this.get(x.layer);
    const attachment = layer.attachments.get(view);
    attachment.state.transformedSource = deserializeTransformedSources(this, x.sources, layer)[0][0];
    attachment.state.displayDimensionRenderInfo = x.displayDimensionRenderInfo;
    layer.chunkManager.scheduleUpdateChunkPriorities();
  });
})();
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 The Neuroglancer Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 William Silvermsith.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 William Silversmith
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 William Silvermsith.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 William Silversmith
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2020 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
